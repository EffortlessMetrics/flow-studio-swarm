<!--
  THIS FILE IS GENERATED. DO NOT EDIT DIRECTLY.
  Source: swarm/tools/flow_studio_ui/fragments/*.html + css/flow-studio.base.css + js/*.js
  Generator: swarm/tools/gen_index_html.py
  Regenerate with: make gen-index-html
-->
<!DOCTYPE html>
<html lang="en" data-ui-ready="loading">
<head>
  <meta charset="UTF-8" />
  <title>Flow Studio</title>
  <link rel="icon" type="image/svg+xml" href="/static/favicon.svg" />
  <link rel="stylesheet" href="css/flow-studio.base.css" />
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
</head>
<body>
<div id="app" data-uiid="flow_studio">
  <header role="banner" data-uiid="flow_studio.header">
    <div>
      <h1>Flow Studio</h1>
      <div class="muted">Interactive node graph of flows, steps, and agents</div>
    <div class="search-container" data-uiid="flow_studio.header.search">
      <span class="search-icon" aria-hidden="true">&#128269;</span>
      <input type="text" id="search-input" class="search-input" placeholder="Search flows, steps, agents, artifacts... (press /)" autocomplete="off" aria-label="Search flows, steps, agents, and artifacts" data-uiid="flow_studio.header.search.input" />
      <div id="search-dropdown" class="search-dropdown" role="listbox" aria-label="Search results" data-uiid="flow_studio.header.search.results"></div>
    </div>
    </div>
    <nav style="display: flex; align-items: center; gap: 16px;" role="navigation" aria-label="Flow Studio controls" data-uiid="flow_studio.header.controls">
      <div class="tour-dropdown" id="tour-dropdown" data-uiid="flow_studio.header.tour">
        <button id="tour-btn" class="tour-dropdown-btn" title="Start a guided tour" aria-haspopup="true" aria-expanded="false" data-uiid="flow_studio.header.tour.trigger">
          <span>Tour</span>
          <span style="font-size: 10px;">‚ñº</span>
        </button>
        <div id="tour-menu" class="tour-dropdown-menu" role="menu" aria-label="Available tours" data-uiid="flow_studio.header.tour.menu"></div>
      </div>
      <div class="mode-toggle" role="group" aria-label="View mode" data-uiid="flow_studio.header.mode">
        <button id="mode-author" class="active" title="Show all paths, CLI commands, and technical details" aria-pressed="true" data-uiid="flow_studio.header.mode.author">Author</button>
        <button id="mode-operator" title="Simplified view focused on run status and decisions" aria-pressed="false" data-uiid="flow_studio.header.mode.operator">Operator</button>
      </div>
      <div id="profile-badge" class="muted fs-profile-badge" style="display: flex; align-items: center; gap: 6px; cursor: pointer;" title="Current swarm profile" role="status" aria-live="polite" data-uiid="flow_studio.header.profile">
        <span id="profile-icon" aria-hidden="true">&#128230;</span>
        <span id="profile-text">Profile: Loading...</span>
      </div>
      <div id="governance-badge" class="muted" style="display: flex; align-items: center; gap: 6px; padding: 4px 10px; background: #f3f4f6; border-radius: 4px; cursor: pointer;" title="Click to view governance status" role="status" aria-live="polite" data-uiid="flow_studio.header.governance">
        <span id="governance-icon" aria-hidden="true">‚è≥</span>
        <span id="governance-text">Checking...</span>
        <span id="governance-issues-count" class="governance-issues-badge" style="display: none;">0</span>
      </div>
      <label id="governance-toggle" class="governance-toggle author-only" title="Highlight governance issues on graph nodes" data-uiid="flow_studio.header.governance.overlay">
        <input type="checkbox" id="governance-overlay-checkbox" />
        <span>Show Issues</span>
      </label>
      <button id="teaching-mode-toggle" class="teaching-mode-toggle" title="Enable Teaching Mode for learning-focused features" aria-pressed="false" data-uiid="flow_studio.header.teaching_mode.toggle">
        <span class="teaching-mode-icon" aria-hidden="true">&#127891;</span>
        <span class="teaching-mode-label">Teach</span>
      </button>
      <div class="muted author-only" data-uiid="flow_studio.header.reload">
        <span class="mono">make dev-check</span>
        <button id="reload-btn" style="margin-left: 4px; padding: 4px 8px; font-size: 11px; cursor: pointer; border: 1px solid #d1d5db; background: #f3f4f6; border-radius: 3px;" data-uiid="flow_studio.header.reload.btn">Reload</button>
      </div>
      <button id="help-btn" style="display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; border-radius: 50%; background: #e5e7eb; color: #374151; font-size: 14px; font-weight: bold; border: none; cursor: pointer;" title="Flow Studio help" aria-label="Show keyboard shortcuts" data-uiid="flow_studio.header.help">?</button>
    </nav>
  </header>
  <div id="sdlc-bar" role="status" aria-label="SDLC progress" data-uiid="flow_studio.sdlc_bar">
    <span class="muted" style="font-size: 11px; margin-right: 8px;">SDLC:</span>
    <span id="sdlc-flows" class="muted" data-uiid="flow_studio.sdlc_bar.flows">Loading...</span>
  </div>
  <aside id="sidebar" role="complementary" aria-label="Flow navigation" data-uiid="flow_studio.sidebar">
    <div class="section-header">
      <h2>Flows</h2>
    </div>
    <!-- Run Control Panel -->
    <div class="run-control-panel" data-uiid="flow_studio.sidebar.run_control">
      <label class="muted" style="font-size: 10px; display: block; margin-bottom: 6px;">RUN CONTROL</label>
      <div class="run-control-buttons" data-uiid="flow_studio.sidebar.run_control.buttons">
        <button id="run-control-play" class="run-control-btn run-control-btn--play" title="Start run" aria-label="Start run" data-uiid="flow_studio.sidebar.run_control.play">
          <span class="run-control-icon">&#9654;</span>
          <span class="run-control-label">Start</span>
        </button>
        <button id="run-control-pause" class="run-control-btn run-control-btn--pause" title="Pause run" aria-label="Pause run" data-uiid="flow_studio.sidebar.run_control.pause" disabled>
          <span class="run-control-icon">&#10074;&#10074;</span>
          <span class="run-control-label">Pause</span>
        </button>
        <button id="run-control-resume" class="run-control-btn run-control-btn--resume" title="Resume run" aria-label="Resume run" data-uiid="flow_studio.sidebar.run_control.resume" disabled style="display: none;">
          <span class="run-control-icon">&#9654;</span>
          <span class="run-control-label">Resume</span>
        </button>
        <button id="run-control-cancel" class="run-control-btn run-control-btn--stop" title="Stop run" aria-label="Stop run" data-uiid="flow_studio.sidebar.run_control.stop" disabled>
          <span class="run-control-icon">&#9632;</span>
          <span class="run-control-label">Stop</span>
        </button>
      </div>
      <div id="run-control-status" class="run-control-status" data-uiid="flow_studio.sidebar.run_control.status">
        <span id="run-control-status-text" class="muted">No active run</span>
      </div>
    </div>
    <div style="margin-bottom: 12px;" data-uiid="flow_studio.sidebar.run_selector">
      <label class="muted" style="font-size: 10px; display: block; margin-bottom: 4px;" for="run-selector">RUN</label>
      <select id="run-selector" class="run-selector" style="width: 100%;" aria-label="Select run" data-uiid="flow_studio.sidebar.run_selector.select">
        <option value="">Loading...</option>
      </select>
      <div id="compare-selector-wrapper" class="compare-selector-wrapper operator-only" data-uiid="flow_studio.sidebar.compare_selector">
        <label class="muted" style="font-size: 10px; display: block; margin-bottom: 4px;" for="compare-selector">COMPARE WITH</label>
        <select id="compare-selector" class="run-selector" style="width: 100%;" aria-label="Select comparison run" data-uiid="flow_studio.sidebar.compare_selector.select">
          <option value="">None</option>
        </select>
      </div>
    </div>
    <div style="margin-bottom: 12px;" data-uiid="flow_studio.sidebar.view_toggle">
      <label class="muted" style="font-size: 10px; display: block; margin-bottom: 4px;">VIEW</label>
      <div class="view-toggle" role="group" aria-label="Graph view mode">
        <button id="view-agents" class="active" title="Show steps and agents" aria-pressed="true" data-uiid="flow_studio.sidebar.view_toggle.agents">Steps/Agents</button>
        <button id="view-artifacts" title="Show steps and artifacts" aria-pressed="false" data-uiid="flow_studio.sidebar.view_toggle.artifacts">Artifacts</button>
      </div>
    </div>
    <div style="margin-bottom: 12px;" data-uiid="flow_studio.sidebar.backend_selector">
      <label class="muted" style="font-size: 10px; display: block; margin-bottom: 4px;" for="backend-selector">BACKEND</label>
      <select id="backend-selector" class="run-selector" style="width: 100%;" aria-label="Select execution backend" data-uiid="flow_studio.sidebar.backend_selector.select">
        <option value="claude-harness">Claude CLI</option>
        <option value="claude-step-orchestrator">Claude Stepwise</option>
        <option value="gemini-step-orchestrator">Gemini Stepwise</option>
      </select>
    </div>
    <!-- Inventory Counts Panel -->
    <div id="inventory-counts-container" class="inventory-counts-container operator-only" data-uiid="flow_studio.sidebar.inventory_counts">
    </div>
    <nav id="flow-list" class="muted" role="navigation" aria-label="Flow list" data-uiid="flow_studio.sidebar.flow_list">Loading...</nav>
    <!-- Run History Panel (collapsible) -->
    <div class="run-history-section" data-uiid="flow_studio.sidebar.run_history">
      <div class="section-header run-history-header" style="margin-top: 16px;">
        <label class="muted" style="font-size: 10px;">RUN HISTORY</label>
        <button id="run-history-toggle" class="collapse-toggle" aria-expanded="true" aria-controls="run-history-list" title="Toggle run history">‚ñº</button>
      </div>
      <div id="run-history-filter" class="run-history-filter" data-uiid="flow_studio.sidebar.run_history.filter">
        <button class="filter-btn active" data-filter="all">All</button>
        <button class="filter-btn" data-filter="example">Examples</button>
        <button class="filter-btn" data-filter="active">Active</button>
      </div>
      <div id="run-history-list" class="run-history-list" role="list" aria-label="Run history" data-uiid="flow_studio.sidebar.run_history.list">
        <div class="muted" style="padding: 8px; font-size: 11px;">Loading...</div>
      </div>
    </div>
  </aside>
  <main id="graph" role="main" aria-label="Flow graph visualization" data-uiid="flow_studio.canvas">
    <!-- Empty state shown when no run is loaded -->
    <div id="canvas-empty-state" class="fs-empty" style="display: none; position: absolute; inset: 0; z-index: 5;" data-uiid="flow_studio.canvas.empty">
      <div class="fs-empty-icon">üìä</div>
      <p class="fs-empty-title">Welcome to Flow Studio</p>
      <p class="fs-empty-description">Select a run from the sidebar to visualize flows.</p>
      <div style="margin-top: 16px; text-align: center;">
        <p class="fs-text-sm fs-text-muted">Generate a demo run with:</p>
        <code class="mono" style="display: block; margin-top: 8px; padding: 8px 12px; background: #f3f4f6; border-radius: 4px; font-size: 12px;">make stepwise-sdlc-stub</code>
      </div>
    </div>
    <div id="legend" class="collapsed" data-uiid="flow_studio.canvas.legend">
      <div class="legend-header" id="legend-toggle" role="button" aria-expanded="false" aria-controls="legend-content" data-uiid="flow_studio.canvas.legend.toggle">
        <span>Legend</span>
        <span class="legend-arrow">‚ñº</span>
      </div>
      <div class="legend-content" id="legend-content" data-uiid="flow_studio.canvas.legend.content">
        <div class="legend-item"><span class="legend-color" style="background: #0f766e;"></span><span>Step (teal)</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #9ca3af;"></span><span>Agent (colored by role)</span></div>
        <div class="legend-separator"></div>
        <div class="legend-item"><span class="legend-line solid"></span><span>Step sequence</span></div>
        <div class="legend-item"><span class="legend-line dotted"></span><span>Step -&gt; Agent</span></div>
        <div class="legend-separator"></div>
        <div class="legend-section-title">Role colors</div>
        <div class="legend-item"><span class="legend-color" style="background: #facc15;"></span><span>Yellow: shaping</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #a855f7;"></span><span>Purple: spec/design</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #22c55e;"></span><span>Green: implementation</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #ef4444;"></span><span>Red: critic</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #3b82f6;"></span><span>Blue: verification</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #f97316;"></span><span>Orange: analytics</span></div>
        <div class="legend-item"><span class="legend-color" style="background: #ec4899;"></span><span>Pink: reporter</span></div>
      </div>
    </div>
    <!-- Semantic graph outline for accessibility and LLM agents -->
    <section id="flow-outline" class="visually-hidden" role="tree" aria-label="Flow outline" data-uiid="flow_studio.canvas.outline"></section>
  </main>
  <section id="details" role="region" aria-label="Node details" data-uiid="flow_studio.inspector">
    <h2>Details</h2>
    <div class="muted author-only">
      <strong>This graph shows:</strong>
      <ul style="margin: 8px 0 12px 16px; padding: 0; line-height: 1.6;">
        <li><span style="color: #14b8a6;">Teal nodes</span> = steps (flow order)</li>
        <li>Colored nodes = agents (by role family)</li>
        <li>Solid arrows = step -> next step</li>
        <li>Dotted arrows = step -> agent</li>
      </ul>
      <strong>Select a node</strong> to see its details.
      <br /><br />
      <strong>Use together with:</strong>
      <ul style="margin: 8px 0 12px 16px; padding: 0; line-height: 1.6;">
        <li><code>swarm/flows/flow-&lt;key&gt;.md</code> (spec)</li>
        <li><code>swarm/runs/&lt;run&gt;/&lt;flow&gt;/</code> (artifacts)</li>
      </ul>
      <strong>To change a flow:</strong>
      <pre class="mono">$EDITOR swarm/config/flows/&lt;key&gt;.yaml
uv run swarm/tools/gen_flows.py
make validate-swarm</pre>
      <p style="margin-top: 12px; font-size: 12px; color: #6b7280;">
        <strong>Keyboard shortcuts:</strong> Press <kbd>?</kbd> for help, <kbd>1-6</kbd> to jump to flows.
      </p>
    </div>
    <div class="muted operator-only">
      <strong>SDLC Status View</strong>
      <ul style="margin: 8px 0 12px 16px; padding: 0; line-height: 1.6;">
        <li>Select a <strong>run</strong> from the sidebar to see SDLC status</li>
        <li>Click a <strong>flow</strong> to see step completion</li>
        <li>Click a <strong>step</strong> to see artifact status</li>
      </ul>
      <div style="margin-top: 12px;">
        <strong>SDLC Bar:</strong> The colored bar shows overall progress.
        <ul style="margin: 8px 0 0 16px; padding: 0; line-height: 1.6; font-size: 11px;">
          <li><span style="color: #22c55e;">Green</span> = complete</li>
          <li><span style="color: #f59e0b;">Yellow</span> = partial</li>
          <li><span style="color: #9ca3af;">Gray</span> = not started</li>
        </ul>
      </div>
      <div style="margin-top: 12px;">
        <strong>Try a scenario:</strong>
        <div style="margin-top: 4px; font-size: 11px;">
          <code>health-check</code> ‚Äî baseline (all flows complete)<br/>
          <code>health-check-risky-deploy</code> ‚Äî conditional approval
        </div>
      </div>
    </div>
  </section>
</div>

<script type="module" src="js/main.js"></script>

<!-- Selftest step explanation modal -->
<div id="selftest-modal" class="selftest-modal" role="dialog" aria-modal="true" aria-labelledby="selftest-modal-title" data-uiid="flow_studio.modal.selftest">
  <div class="selftest-step-content">
    <button class="selftest-modal-close" onclick="toggleSelftestModal(false)" aria-label="Close selftest modal" data-uiid="flow_studio.modal.selftest.close">√ó</button>
    <h3 id="selftest-modal-title" class="visually-hidden">Selftest Step Details</h3>
    <div id="selftest-modal-body" data-uiid="flow_studio.modal.selftest.body">Loading...</div>
  </div>
</div>

<!-- Keyboard shortcuts modal -->
<div id="shortcuts-modal" class="shortcuts-modal" role="dialog" aria-modal="true" aria-labelledby="shortcuts-modal-title" data-uiid="flow_studio.modal.shortcuts">
  <div class="shortcuts-content">
    <h3 id="shortcuts-modal-title">Keyboard Shortcuts</h3>
    <div class="shortcut-row">
      <span class="shortcut-desc">Focus search</span>
      <span class="shortcut-key">/</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Close dropdown / modal</span>
      <span class="shortcut-key">Esc</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Previous step</span>
      <span class="shortcut-key">&#8592;</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Next step</span>
      <span class="shortcut-key">&#8594;</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Jump to Flow 1</span>
      <span class="shortcut-key">1</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Jump to Flow 2</span>
      <span class="shortcut-key">2</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Jump to Flow 3</span>
      <span class="shortcut-key">3</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Jump to Flow 4</span>
      <span class="shortcut-key">4</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Jump to Flow 5</span>
      <span class="shortcut-key">5</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Jump to Flow 6</span>
      <span class="shortcut-key">6</span>
    </div>
    <div class="shortcut-row">
      <span class="shortcut-desc">Show this help</span>
      <span class="shortcut-key">?</span>
    </div>
    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #e5e7eb; font-size: 12px; color: #6b7280;">
      <div>Full documentation: <code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px;">docs/FLOW_STUDIO.md</code></div>
      <div style="margin-top: 6px;">Color/governance rules: <code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px;">docs/VALIDATION_RULES.md</code></div>
    </div>
  </div>
</div>

<!-- Run Detail Modal -->
<div id="run-detail-modal" class="run-detail-modal" role="dialog" aria-modal="true" aria-labelledby="run-detail-modal-title" data-uiid="flow_studio.modal.run_detail">
  <div class="run-detail-content">
    <button id="run-detail-close" class="run-detail-close" aria-label="Close run detail modal" data-uiid="flow_studio.modal.run_detail.close">√ó</button>
    <h3 id="run-detail-modal-title">Run Details</h3>
    <div id="run-detail-body" data-uiid="flow_studio.modal.run_detail.body">
      <div class="run-detail-section">
        <div class="kv-label">RUN ID</div>
        <div id="run-detail-id" class="mono">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">STATUS</div>
        <div id="run-detail-status">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">BACKEND</div>
        <div id="run-detail-backend">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">PROFILE</div>
        <div id="run-detail-profile">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">FLOWS</div>
        <div id="run-detail-flows">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">CREATED</div>
        <div id="run-detail-created">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">COMPLETED</div>
        <div id="run-detail-completed">-</div>
      </div>
      <div class="run-detail-section" id="run-detail-error-section" style="display: none;">
        <div class="kv-label">ERROR</div>
        <div id="run-detail-error" class="run-detail-error">-</div>
      </div>
      <div class="run-detail-section">
        <div class="kv-label">TAGS</div>
        <div id="run-detail-tags">-</div>
      </div>
      <div class="run-detail-actions">
        <button id="run-detail-rerun" class="btn-primary" data-uiid="flow_studio.modal.run_detail.rerun">Re-run</button>
        <label class="exemplar-toggle">
          <input type="checkbox" id="run-detail-exemplar" />
          <span>Exemplar (teaching)</span>
        </label>
      </div>
    </div>
  </div>
</div>

<!-- Context Budget Settings Modal (v2.4.0) -->
<div id="context-budget-modal" class="settings-modal" role="dialog"
     aria-modal="true" aria-labelledby="context-budget-modal-title"
     data-uiid="flow_studio.modal.context_budget">
  <div class="settings-content">
    <button class="modal-close" aria-label="Close"
            data-uiid="flow_studio.modal.context_budget.close">&times;</button>

    <h3 id="context-budget-modal-title">Context Budget Settings</h3>
    <p class="settings-description">
      Configure history context limits for stepwise execution.
      These budgets control how much previous step output is included in prompts.
    </p>

    <div class="settings-section">
      <h4>Current Effective Values</h4>
      <div class="budget-display" data-uiid="flow_studio.modal.context_budget.effective">
        <!-- Populated by JavaScript -->
        <div class="budget-value"><strong>Total Budget:</strong> <span id="effective-total">200,000</span> chars</div>
        <div class="budget-value"><strong>Recent Step:</strong> <span id="effective-recent">60,000</span> chars</div>
        <div class="budget-value"><strong>Older Steps:</strong> <span id="effective-older">10,000</span> chars each</div>
        <div class="budget-source">Source: <code id="effective-source">default</code></div>
      </div>
    </div>

    <div class="settings-section">
      <h4>Profile Override</h4>
      <p class="settings-hint">
        Set custom values for this profile. Leave empty to use defaults.
      </p>
      <div class="budget-inputs" data-uiid="flow_studio.modal.context_budget.profile_form">
        <div class="input-group">
          <label for="budget-total">Total History Budget (chars)</label>
          <input type="number" id="budget-total"
                 min="10000" max="1000000" step="10000"
                 placeholder="200000"
                 data-uiid="flow_studio.modal.context_budget.input.total">
          <span class="input-hint">~<span id="budget-total-tokens">50</span>k tokens</span>
        </div>

        <div class="input-group">
          <label for="budget-recent">Recent Step Max (chars)</label>
          <input type="number" id="budget-recent"
                 min="1000" max="500000" step="5000"
                 placeholder="60000"
                 data-uiid="flow_studio.modal.context_budget.input.recent">
          <span class="input-hint">~<span id="budget-recent-tokens">15</span>k tokens</span>
        </div>

        <div class="input-group">
          <label for="budget-older">Older Step Max (chars)</label>
          <input type="number" id="budget-older"
                 min="500" max="100000" step="1000"
                 placeholder="10000"
                 data-uiid="flow_studio.modal.context_budget.input.older">
          <span class="input-hint">~<span id="budget-older-tokens">2.5</span>k tokens each</span>
        </div>
      </div>
    </div>

    <div class="settings-presets">
      <h4>Quick Presets</h4>
      <div class="preset-buttons">
        <button class="btn-preset" data-preset="lean" title="Minimal history for fast execution">
          Lean (25k tokens)
        </button>
        <button class="btn-preset" data-preset="balanced" title="Default balanced settings">
          Balanced (50k tokens)
        </button>
        <button class="btn-preset" data-preset="heavy" title="Maximum context for complex flows">
          Heavy (100k tokens)
        </button>
      </div>
    </div>

    <div class="settings-actions">
      <button class="btn-secondary" data-uiid="flow_studio.modal.context_budget.reset">
        Reset to Defaults
      </button>
      <button class="btn-primary" data-uiid="flow_studio.modal.context_budget.save">
        Save to Profile
      </button>
    </div>
  </div>
</div>

<style>
/* Context Budget Modal Styles */
#context-budget-modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 1000;
  justify-content: center;
  align-items: center;
}

#context-budget-modal.open {
  display: flex;
}

#context-budget-modal .settings-content {
  background: var(--bg-primary, #1e1e1e);
  border: 1px solid var(--border-color, #333);
  border-radius: 8px;
  padding: 24px;
  max-width: 500px;
  width: 90%;
  max-height: 90vh;
  overflow-y: auto;
  position: relative;
}

#context-budget-modal .modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  color: var(--text-secondary, #888);
  font-size: 24px;
  cursor: pointer;
  padding: 4px 8px;
  line-height: 1;
}

#context-budget-modal .modal-close:hover {
  color: var(--text-primary, #fff);
}

#context-budget-modal h3 {
  margin: 0 0 8px 0;
  color: var(--text-primary, #fff);
  font-size: 18px;
}

#context-budget-modal h4 {
  margin: 16px 0 8px 0;
  color: var(--text-primary, #fff);
  font-size: 14px;
  font-weight: 600;
}

#context-budget-modal .settings-description {
  color: var(--text-secondary, #888);
  font-size: 13px;
  margin: 0 0 16px 0;
}

#context-budget-modal .settings-hint {
  color: var(--text-tertiary, #666);
  font-size: 12px;
  margin: 0 0 12px 0;
}

#context-budget-modal .budget-display {
  background: var(--bg-secondary, #252525);
  border-radius: 4px;
  padding: 12px;
  font-family: var(--font-mono, monospace);
  font-size: 13px;
}

#context-budget-modal .budget-value {
  margin: 4px 0;
  color: var(--text-primary, #fff);
}

#context-budget-modal .budget-source {
  margin-top: 8px;
  color: var(--text-secondary, #888);
  font-size: 12px;
}

#context-budget-modal .budget-source code {
  background: var(--bg-tertiary, #333);
  padding: 2px 6px;
  border-radius: 3px;
}

#context-budget-modal .input-group {
  margin-bottom: 16px;
}

#context-budget-modal .input-group label {
  display: block;
  margin-bottom: 4px;
  color: var(--text-primary, #fff);
  font-size: 13px;
}

#context-budget-modal .input-group input {
  width: 100%;
  padding: 8px 12px;
  background: var(--bg-secondary, #252525);
  border: 1px solid var(--border-color, #333);
  border-radius: 4px;
  color: var(--text-primary, #fff);
  font-size: 14px;
  font-family: var(--font-mono, monospace);
}

#context-budget-modal .input-group input:focus {
  outline: none;
  border-color: var(--accent-color, #0078d4);
}

#context-budget-modal .input-hint {
  display: block;
  margin-top: 4px;
  color: var(--text-tertiary, #666);
  font-size: 11px;
}

#context-budget-modal .preset-buttons {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

#context-budget-modal .btn-preset {
  padding: 6px 12px;
  background: var(--bg-secondary, #252525);
  border: 1px solid var(--border-color, #333);
  border-radius: 4px;
  color: var(--text-secondary, #888);
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

#context-budget-modal .btn-preset:hover {
  background: var(--bg-tertiary, #333);
  color: var(--text-primary, #fff);
  border-color: var(--accent-color, #0078d4);
}

#context-budget-modal .settings-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  margin-top: 24px;
  padding-top: 16px;
  border-top: 1px solid var(--border-color, #333);
}

#context-budget-modal .btn-secondary {
  padding: 8px 16px;
  background: transparent;
  border: 1px solid var(--border-color, #333);
  border-radius: 4px;
  color: var(--text-secondary, #888);
  font-size: 13px;
  cursor: pointer;
}

#context-budget-modal .btn-secondary:hover {
  background: var(--bg-secondary, #252525);
  color: var(--text-primary, #fff);
}

#context-budget-modal .btn-primary {
  padding: 8px 16px;
  background: var(--accent-color, #0078d4);
  border: 1px solid var(--accent-color, #0078d4);
  border-radius: 4px;
  color: #fff;
  font-size: 13px;
  cursor: pointer;
}

#context-budget-modal .btn-primary:hover {
  background: var(--accent-hover, #106ebe);
}
</style>

<!-- Boundary Review Panel (dynamically rendered by BoundaryReview.ts component) -->
<!--
  This fragment provides the static container for the Boundary Review feature.
  The actual panel content is rendered dynamically by the BoundaryReview TypeScript component.

  This is the "human review at flow boundary" feature that shows:
  - Flow completion status (VERIFIED/UNVERIFIED)
  - Count of assumptions made in this flow
  - Count of decisions made in this flow
  - Key artifacts produced
  - MacroNavigator routing decision (if any)
  - "Approve & Continue" or "Review & Pause" buttons

  UIIDs exposed:
  - flow_studio.boundary_review.panel - Main overlay container
  - flow_studio.boundary_review.content - Panel content
  - flow_studio.boundary_review.approve - Approve button
  - flow_studio.boundary_review.pause - Pause/review button
-->

<!-- Boundary review container (renders dynamically via JS) -->
<div id="boundary-review-container" aria-live="polite" data-uiid="flow_studio.boundary_review.container">
  <!-- BoundaryReview component renders its content here when triggered -->
</div>

  <!-- Embedded Flow Studio assets for offline parity and test fixtures -->
  <style data-inline-source="flowstudio-base-css">
    /* =========================================================================
     * CSS Custom Properties (Design Tokens)
     * =========================================================================
     * These tokens provide consistent values across the UI.
     * Use these instead of literal values for maintainability and theming.
     */
    :root {
      /* Colors - Base */
      --fs-color-bg-base: #ffffff;
      --fs-color-bg-muted: #f9fafb;
      --fs-color-bg-subtle: #f3f4f6;
      --fs-color-border: #e5e7eb;
      --fs-color-border-strong: #d1d5db;
      --fs-color-text: #111827;
      --fs-color-text-muted: #6b7280;
      --fs-color-text-subtle: #9ca3af;

      /* Colors - Semantic */
      --fs-color-accent: #3b82f6;
      --fs-color-accent-hover: #2563eb;
      --fs-color-accent-bg: #dbeafe;
      --fs-color-success: #22c55e;
      --fs-color-success-bg: #dcfce7;
      --fs-color-warning: #f59e0b;
      --fs-color-warning-bg: #fef3c7;
      --fs-color-error: #ef4444;
      --fs-color-error-bg: #fee2e2;

      /* Graph colors */
      --fs-color-graph-edge: #818cf8;

      /* Agent role colors */
      --fs-color-step: #0f766e;
      --fs-color-shaping: #fbbf24;
      --fs-color-spec: #a855f7;
      --fs-color-implementation: #22c55e;
      --fs-color-critic: #ef4444;
      --fs-color-verification: #3b82f6;
      --fs-color-analytics: #f97316;
      --fs-color-reporter: #ec4899;
      --fs-color-infra: #06b6d4;

      /* Spacing */
      --fs-spacing-xs: 4px;
      --fs-spacing-sm: 8px;
      --fs-spacing-md: 12px;
      --fs-spacing-lg: 16px;
      --fs-spacing-xl: 24px;

      /* Border radius */
      --fs-radius-sm: 3px;
      --fs-radius-md: 4px;
      --fs-radius-lg: 6px;
      --fs-radius-xl: 8px;
      --fs-radius-pill: 100px;

      /* Typography */
      --fs-font-family-base: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --fs-font-family-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --fs-font-size-xs: 10px;
      --fs-font-size-sm: 11px;
      --fs-font-size-body: 12px;
      --fs-font-size-md: 13px;
      --fs-font-size-lg: 14px;
      --fs-font-size-xl: 16px;

      /* Shadows */
      --fs-shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --fs-shadow-md: 0 4px 12px rgba(0, 0, 0, 0.1);
      --fs-shadow-lg: 0 20px 40px rgba(0, 0, 0, 0.2);

      /* Transitions */
      --fs-transition-fast: 0.15s ease;
      --fs-transition-normal: 0.2s ease;

      /* Z-index layers */
      --fs-z-dropdown: 1000;
      --fs-z-tour: 1001;
      --fs-z-search: 1002;
      --fs-z-modal: 2000;
      --fs-z-toast: 3000;
    }

    /* Typography Utilities */
    .fs-text-xs { font-size: var(--fs-font-size-xs); }     /* 10px */
    .fs-text-sm { font-size: var(--fs-font-size-sm); }     /* 11px */
    .fs-text-body { font-size: var(--fs-font-size-body); } /* 12px */
    .fs-text-md { font-size: var(--fs-font-size-md); }     /* 13px */
    .fs-text-lg { font-size: var(--fs-font-size-lg); }     /* 14px */
    .fs-text-xl { font-size: var(--fs-font-size-xl); }     /* 16px */

    /* Monospace Utilities */
    .fs-mono {
      font-family: var(--fs-font-family-mono, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
    }
    .fs-mono-xs {
      font-family: var(--fs-font-family-mono, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
      font-size: var(--fs-font-size-xs);
    }
    .fs-mono-sm {
      font-family: var(--fs-font-family-mono, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
      font-size: var(--fs-font-size-sm);
    }

    /* Text Color Utilities */
    .fs-text-muted { color: var(--fs-color-text-muted); }
    .fs-text-subtle { color: var(--fs-color-text-subtle); }

    /* Label Utility */
    .fs-label {
      font-size: var(--fs-font-size-sm);
      color: var(--fs-color-text-muted);
      margin-bottom: 4px;
      font-weight: 500;
    }

    /* Button Utilities */
    .fs-button-small {
      margin: 4px;
      padding: 4px 8px;
      font-size: var(--fs-font-size-sm);
      cursor: pointer;
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      background: var(--fs-color-bg-subtle, #f3f4f6);
      border-radius: var(--fs-radius-sm, 3px);
      transition: background 0.15s ease;
    }
    .fs-button-small:hover {
      background: var(--fs-color-bg-hover, #e5e7eb);
    }

    .fs-button-primary {
      padding: 8px 16px;
      background: var(--fs-color-accent, #3b82f6);
      color: white;
      border: none;
      border-radius: var(--fs-radius-md, 4px);
      cursor: pointer;
      font-size: var(--fs-font-size-body);
      transition: background 0.15s ease;
    }
    .fs-button-primary:hover {
      background: var(--fs-color-accent-hover, #2563eb);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: var(--fs-font-family-base);
      color: var(--fs-color-text);
    }
    /* Visually hidden but accessible to screen readers and semantic agents */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    #app {
      display: grid;
      grid-template-columns: 260px 1fr 360px;
      grid-template-rows: 56px 40px 1fr;
      grid-template-areas:
        "header header header"
        "sidebar sdlc-bar sdlc-bar"
        "sidebar graph details";
      height: 100%;
    }
    header {
      grid-area: header;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px;
      border-bottom: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    h1 {
      margin: 0;
      font-size: 16px;
    }
    .muted {
      color: #6b7280;
      font-size: 12px;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
    }
    #sidebar {
      grid-area: sidebar;
      padding: 8px;
      border-right: 1px solid #e5e7eb;
      overflow-y: auto;
      font-size: 13px;
    }
    #sdlc-bar {
      grid-area: sdlc-bar;
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 12px;
      background: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      overflow-x: auto;
    }
    .sdlc-flow {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      white-space: nowrap;
      border: 1px solid transparent;
    }
    .sdlc-flow:hover {
      background: #e5e7eb;
    }
    .sdlc-flow.active {
      background: #dbeafe;
      border-color: #3b82f6;
    }
    .sdlc-flow .icon {
      font-size: 12px;
    }
    .sdlc-arrow {
      color: #9ca3af;
      font-size: 14px;
    }
    /* Wisdom indicator in SDLC bar */
    .wisdom-indicator-wrapper {
      display: inline-flex;
      align-items: center;
      margin-left: 8px;
    }
    .wisdom-indicator {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: help;
      padding: 4px;
    }
    .wisdom-indicator__dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
      transition: transform 0.15s ease;
    }
    .wisdom-indicator:hover .wisdom-indicator__dot {
      transform: scale(1.2);
    }
    .wisdom-indicator--ok .wisdom-indicator__dot {
      background: #22c55e; /* green-500 */
      box-shadow: 0 0 4px rgba(34, 197, 94, 0.4);
    }
    .wisdom-indicator--warning .wisdom-indicator__dot {
      background: #eab308; /* yellow-500 */
      box-shadow: 0 0 4px rgba(234, 179, 8, 0.4);
    }
    .wisdom-indicator--error .wisdom-indicator__dot {
      background: #ef4444; /* red-500 */
      box-shadow: 0 0 4px rgba(239, 68, 68, 0.4);
    }
    .wisdom-indicator--unknown .wisdom-indicator__dot {
      background: #9ca3af; /* gray-400 */
      box-shadow: none;
    }
    #graph {
      grid-area: graph;
      position: relative;
    }
    #graph > div {
      width: 100%;
      height: 100%;
    }
    #details {
      grid-area: details;
      padding: 10px 12px;
      border-left: 1px solid #e5e7eb;
      overflow-y: auto;
      font-size: 13px;
    }
    h2 {
      margin: 0 0 6px;
      font-size: 14px;
    }
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .run-selector {
      padding: 4px 8px;
      font-size: 11px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
    }
    .flow-item {
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .flow-item:hover {
      background: #f3f4f6;
    }
    .flow-item.active {
      background: #e5f2ff;
      border-left: 3px solid #2563eb;
    }
    .flow-status-icon {
      font-size: 12px;
      flex-shrink: 0;
    }
    .flow-item-content {
      flex: 1;
      min-width: 0;
    }
    .flow-title {
      font-weight: 600;
      font-size: 13px;
    }
    .flow-sub {
      font-size: 11px;
      color: #6b7280;
    }
    .kv-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6b7280;
      margin-top: 8px;
      margin-bottom: 2px;
    }
    pre {
      background: #f3f4f6;
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 12px;
      overflow-x: auto;
    }
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 8px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 4px;
    }
    .tab {
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px 4px 0 0;
      border: 1px solid transparent;
    }
    .tab:hover {
      background: #f3f4f6;
    }
    .tab.active {
      background: #e5f2ff;
      border-color: #d1d5db;
      border-bottom-color: #fff;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .artifact-table {
      width: 100%;
      font-size: 11px;
      border-collapse: collapse;
    }
    .artifact-table th, .artifact-table td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }
    .artifact-table th {
      background: #f9fafb;
      font-weight: 600;
    }
    .status-complete { color: #059669; }
    .status-partial { color: #d97706; }
    .status-missing { color: #dc2626; }
    .status-na { color: #6b7280; }
    .mode-toggle {
      display: flex;
      gap: 0;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      overflow: hidden;
      font-size: 11px;
    }
    .mode-toggle button {
      padding: 4px 10px;
      border: none;
      background: #f9fafb;
      cursor: pointer;
      transition: background 0.15s;
    }
    .mode-toggle button:hover {
      background: #e5e7eb;
    }
    .mode-toggle button.active {
      background: #3b82f6;
      color: white;
    }
    .mode-toggle button:first-child {
      border-right: 1px solid #d1d5db;
    }
    .author-only {
      display: block;
    }
    .operator-only {
      display: none;
    }
    body.mode-operator .author-only {
      display: none;
    }
    body.mode-operator .operator-only {
      display: block;
    }

    /* Comparison styles */
    .compare-selector-wrapper {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #e5e7eb;
    }
    .compare-summary {
      display: flex;
      gap: 12px;
      margin-bottom: 12px;
      font-size: 11px;
    }
    .compare-summary-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .change-improved { color: #059669; }
    .change-regressed { color: #dc2626; }
    .change-unchanged { color: #6b7280; }
    .sdlc-flow-compare {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 9px;
      line-height: 1.2;
    }
    .sdlc-flow-compare .run-label {
      font-size: 8px;
      color: #6b7280;
    }
    .comparison-table {
      width: 100%;
      font-size: 11px;
      border-collapse: collapse;
    }
    .comparison-table th, .comparison-table td {
      padding: 4px 6px;
      text-align: left;
      border-bottom: 1px solid #e5e7eb;
    }
    .comparison-table th {
      background: #f9fafb;
      font-weight: 600;
    }
    .arrow-improved { color: #059669; font-weight: bold; }
    .arrow-regressed { color: #dc2626; font-weight: bold; }
    .arrow-unchanged { color: #6b7280; }

    /* Tour system styles */
    .tour-dropdown {
      position: relative;
      display: inline-block;
    }
    .tour-dropdown-btn {
      padding: 4px 10px;
      font-size: 11px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .tour-dropdown-btn:hover {
      background: #e5e7eb;
    }
    .tour-dropdown-btn.active {
      background: #dbeafe;
      border-color: #3b82f6;
    }
    .tour-dropdown-menu {
      position: absolute;
      top: 100%;
      left: 0;
      margin-top: 4px;
      min-width: 200px;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      z-index: 1001;
      display: none;
    }
    .tour-dropdown-menu.open {
      display: block;
    }
    .tour-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f3f4f6;
    }
    .tour-menu-item:last-child {
      border-bottom: none;
    }
    .tour-menu-item:hover {
      background: #f3f4f6;
    }
    .tour-menu-item.selected {
      background: #dbeafe;
    }
    .tour-menu-title {
      font-weight: 600;
      font-size: 12px;
    }
    .tour-menu-desc {
      font-size: 10px;
      color: #6b7280;
      margin-top: 2px;
    }
    .tour-card {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      max-width: 400px;
      min-width: 320px;
    }
    .tour-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .tour-step-number {
      font-size: 11px;
      color: #6b7280;
    }
    .tour-exit-btn {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #6b7280;
      padding: 0;
      line-height: 1;
    }
    .tour-exit-btn:hover {
      color: #111827;
    }
    .tour-card-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 6px;
    }
    .tour-card-text {
      font-size: 13px;
      line-height: 1.5;
      color: #374151;
      margin-bottom: 12px;
    }
    .tour-card-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .tour-nav-btn {
      padding: 6px 12px;
      font-size: 12px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      border-radius: 4px;
      cursor: pointer;
    }
    .tour-nav-btn:hover {
      background: #e5e7eb;
    }
    .tour-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .tour-nav-btn.primary {
      background: #3b82f6;
      border-color: #3b82f6;
      color: white;
    }
    .tour-nav-btn.primary:hover {
      background: #2563eb;
    }
    .tour-highlight {
      box-shadow: 0 0 0 3px #3b82f6, 0 0 20px rgba(59, 130, 246, 0.5) !important;
      z-index: 10 !important;
    }
    .tour-dimmed {
      opacity: 0.4 !important;
    }
    /* Governance overlay styles */
    .governance-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      padding: 4px 8px;
      background: #f9fafb;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      cursor: pointer;
    }
    .governance-toggle:hover {
      background: #e5e7eb;
    }
    .governance-toggle.active {
      background: #fef3c7;
      border-color: #f59e0b;
    }
    .governance-toggle input {
      margin: 0;
    }
    .governance-issues-badge {
      background: #f59e0b;
      color: white;
      padding: 1px 5px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: 600;
    }
    .flow-governance-badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      font-size: 10px;
      color: #6b7280;
    }
    .flow-governance-badge.has-issues {
      color: #f59e0b;
    }
    .governance-section {
      margin-top: 12px;
      padding: 8px;
      background: #fffbeb;
      border: 1px solid #fcd34d;
      border-radius: 4px;
    }
    .governance-section.healthy {
      background: #f0fdf4;
      border-color: #86efac;
    }
    .governance-section h3 {
      margin: 0 0 6px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .governance-check {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 4px 0;
      border-bottom: 1px solid #e5e7eb;
      font-size: 11px;
    }
    .governance-check:last-child {
      border-bottom: none;
    }
    .governance-check-name {
      font-weight: 500;
      color: #374151;
    }
    .governance-check-status {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .governance-check-status.pass { color: #059669; }
    .governance-check-status.fail { color: #dc2626; }
    .governance-check-status.warn { color: #d97706; }
    .governance-fix {
      margin-top: 4px;
      font-size: 10px;
      color: #6b7280;
      font-style: italic;
    }

    /* FR status badges */
    .fr-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 8px;
    }

    .fr-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: bold;
      cursor: help;
    }

    .fr-pass {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .fr-warn {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }

    .fr-fail {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .fr-none {
      color: #999;
      font-style: italic;
    }

    /* Graph node FR status overlays */
    .fr-status-pass {
      border-width: 3px !important;
      border-color: #28a745 !important;
    }

    .fr-status-warn {
      border-width: 3px !important;
      border-color: #ffc107 !important;
      animation: pulse-warn 2s infinite;
    }

    .fr-status-fail {
      border-width: 3px !important;
      border-color: #dc3545 !important;
      animation: pulse-fail 1s infinite;
    }

    @keyframes pulse-warn {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    @keyframes pulse-fail {
      0%, 100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
      50% { box-shadow: 0 0 0 8px rgba(220, 53, 69, 0); }
    }

    /* Timeline styles */
    .timeline-container {
      margin-top: 12px;
      font-size: 12px;
    }
    .timeline-header {
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid #e5e7eb;
    }
    .timeline-event {
      display: flex;
      gap: 8px;
      padding: 4px 0;
      border-left: 2px solid #e5e7eb;
      margin-left: 4px;
      padding-left: 12px;
    }
    .timeline-event.started {
      border-left-color: #3b82f6;
    }
    .timeline-event.completed {
      border-left-color: #22c55e;
    }
    .timeline-event.failed {
      border-left-color: #ef4444;
    }
    .timeline-time {
      font-family: ui-monospace, monospace;
      font-size: 11px;
      color: #6b7280;
      min-width: 50px;
    }
    .timeline-icon {
      font-size: 12px;
    }
    .timeline-flow {
      font-weight: 500;
    }
    .timeline-status {
      color: #6b7280;
    }
    .timeline-duration {
      color: #059669;
      font-weight: 500;
    }
    .timeline-note {
      font-size: 11px;
      color: #6b7280;
      margin-left: 70px;
      margin-top: 2px;
    }
    .timeline-total {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid #e5e7eb;
      font-weight: 600;
    }

    /* Timing summary styles */
    .timing-summary {
      margin-top: 12px;
      padding: 8px;
      background: #f9fafb;
      border-radius: 6px;
      font-size: 12px;
    }
    .timing-summary-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .timing-summary-duration {
      font-size: 18px;
      font-weight: 600;
      color: #111827;
    }
    .timing-summary-range {
      font-size: 11px;
      color: #6b7280;
    }
    .timing-bar-container {
      margin-top: 8px;
    }
    .timing-bar-label {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      margin-bottom: 2px;
    }
    .timing-bar {
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 6px;
    }
    .timing-bar-fill {
      height: 100%;
      background: #3b82f6;
      border-radius: 4px;
    }
    .timing-bar-fill.slow {
      background: #f59e0b;
    }

    /* Step timing inline */
    .step-timing {
      margin-top: 8px;
      padding: 6px 8px;
      background: #f0fdf4;
      border-radius: 4px;
      font-size: 11px;
    }
    .step-timing-row {
      display: flex;
      justify-content: space-between;
      padding: 2px 0;
    }
    .step-timing-label {
      color: #6b7280;
    }
    .step-timing-value {
      font-family: ui-monospace, monospace;
      color: #059669;
    }
    /* View toggle styles */
    .view-toggle {
      display: flex;
      gap: 0;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      overflow: hidden;
      font-size: 11px;
      margin-bottom: 12px;
    }
    .view-toggle button {
      flex: 1;
      padding: 6px 10px;
      border: none;
      background: #f9fafb;
      cursor: pointer;
      transition: background 0.15s;
      font-size: 11px;
    }
    .view-toggle button:hover {
      background: #e5e7eb;
    }
    .view-toggle button.active {
      background: #0f766e;
      color: white;
    }
    .view-toggle button:first-child {
      border-right: 1px solid #d1d5db;
    }
    /* Artifact status colors */
    .artifact-present { background-color: #22c55e !important; }
    .artifact-missing { background-color: #ef4444 !important; }
    .artifact-unknown { background-color: #9ca3af !important; }

    /* Search box styles */
    .search-container {
      position: relative;
      flex: 0 0 280px;
    }
    .search-input {
      width: 100%;
      padding: 6px 12px 6px 32px;
      font-size: 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: white;
      outline: none;
    }
    .search-input:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
    }
    .search-input::placeholder {
      color: #9ca3af;
    }
    .search-icon {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      color: #9ca3af;
      font-size: 14px;
      pointer-events: none;
    }
    .search-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      z-index: 1002;
      display: none;
      max-height: 320px;
      overflow-y: auto;
    }
    .search-dropdown.open {
      display: block;
    }
    .search-result {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f3f4f6;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .search-result:last-child {
      border-bottom: none;
    }
    .search-result:hover, .search-result.selected {
      background: #f3f4f6;
    }
    .search-result-type {
      font-size: 9px;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 3px;
      background: #e5e7eb;
      color: #4b5563;
      flex-shrink: 0;
    }
    .search-result-type.flow { background: #dbeafe; color: #1e40af; }
    .search-result-type.step { background: #d1fae5; color: #065f46; }
    .search-result-type.agent { background: #fef3c7; color: #92400e; }
    .search-result-type.artifact { background: #ede9fe; color: #5b21b6; }
    .search-result-label {
      font-size: 12px;
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .search-no-results {
      padding: 16px;
      text-align: center;
      color: #6b7280;
      font-size: 12px;
    }

    /* Legend box - positioned top-right, collapsed by default */
    #legend {
      position: absolute;
      top: 12px;
      right: 12px;
      max-width: 260px;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 11px;
      pointer-events: auto;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      transition: all 0.2s ease;
    }
    .legend-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      font-weight: 600;
      color: #374151;
      padding: 2px 0;
      user-select: none;
    }
    .legend-arrow {
      font-size: 10px;
      transition: transform 0.2s ease;
      margin-left: 8px;
    }
    #legend.collapsed .legend-arrow {
      transform: rotate(-90deg);
    }
    .legend-content {
      margin-top: 8px;
      overflow: hidden;
      transition: max-height 0.2s ease, opacity 0.2s ease;
      max-height: 400px;
    }
    #legend.collapsed .legend-content {
      max-height: 0;
      margin-top: 0;
      opacity: 0;
    }
    #legend h3 {
      margin: 0 0 8px 0;
      font-size: 11px;
      font-weight: 600;
      color: #374151;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }
    .legend-item:last-child {
      margin-bottom: 0;
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    .legend-line {
      width: 20px;
      height: 2px;
      flex-shrink: 0;
    }
    .legend-line.solid {
      background: var(--fs-color-graph-edge);
    }
    .legend-line.dotted {
      background: repeating-linear-gradient(90deg, var(--fs-color-graph-edge) 0, var(--fs-color-graph-edge) 3px, transparent 3px, transparent 6px);
    }
    .legend-separator {
      border-top: 1px solid #e5e7eb;
      margin: 8px 0;
    }
    .legend-section-title {
      font-size: 9px;
      text-transform: uppercase;
      color: #6b7280;
      margin-bottom: 4px;
    }

    /* Copy button styles */
    .copy-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 2px 6px;
      font-size: 10px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      border-radius: 3px;
      cursor: pointer;
      margin-left: 6px;
      transition: all 0.15s;
    }
    .copy-btn:hover {
      background: #e5e7eb;
      border-color: #9ca3af;
    }
    .copy-btn.copied {
      background: #d1fae5;
      border-color: #10b981;
      color: #065f46;
    }
    .path-with-copy {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .quick-commands {
      margin-top: 12px;
      padding: 8px;
      background: #f3f4f6;
      border-radius: 4px;
    }
    .quick-commands .kv-label {
      margin-top: 0;
    }
    .command-line {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #e5e7eb;
    }
    .command-line:last-child {
      border-bottom: none;
    }
    .command-text {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 11px;
      color: #374151;
    }

    /* Keyboard shortcuts modal */
    .shortcuts-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .shortcuts-modal.open {
      display: flex;
    }
    .shortcuts-content {
      background: white;
      border-radius: 8px;
      padding: 20px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }
    .shortcuts-content h3 {
      margin: 0 0 16px 0;
      font-size: 14px;
    }
    .shortcut-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0;
      border-bottom: 1px solid #f3f4f6;
    }
    .shortcut-row:last-child {
      border-bottom: none;
    }
    .shortcut-key {
      display: inline-block;
      padding: 2px 8px;
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      font-family: ui-monospace, SFMono-Regular, monospace;
      font-size: 11px;
    }
    .shortcut-desc {
      font-size: 12px;
      color: #4b5563;
    }

    /* Selftest modal and step explanation */
    .selftest-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }
    .selftest-modal.open {
      display: flex;
    }
    .selftest-step-content {
      background: white;
      border-radius: 8px;
      padding: 24px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    }
    .selftest-step-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid #e5e7eb;
    }
    .selftest-step-id {
      font-family: ui-monospace, SFMono-Regular, monospace;
      font-size: 13px;
      font-weight: 600;
      color: #111827;
    }
    .selftest-step-tier-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .selftest-step-tier-badge.kernel {
      background: #fee2e2;
      color: #991b1b;
    }
    .selftest-step-tier-badge.governance {
      background: #fef3c7;
      color: #92400e;
    }
    .selftest-step-tier-badge.optional {
      background: #dbeafe;
      color: #0c4a6e;
    }
    .selftest-step-title {
      margin: 0 0 12px 0;
      font-size: 16px;
      font-weight: 600;
    }
    .selftest-step-description {
      margin-bottom: 16px;
      font-size: 13px;
      line-height: 1.6;
      color: #374151;
    }
    .selftest-step-metadata {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 16px;
      padding: 12px;
      background: #f9fafb;
      border-radius: 6px;
      font-size: 12px;
    }
    .selftest-metadata-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .selftest-metadata-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #6b7280;
      font-weight: 600;
    }
    .selftest-metadata-value {
      font-size: 12px;
      color: #111827;
    }
    .selftest-dependencies {
      margin-bottom: 16px;
      padding: 12px;
      background: #eff6ff;
      border-left: 3px solid #3b82f6;
      border-radius: 4px;
      font-size: 12px;
    }
    .selftest-dependencies-title {
      font-weight: 600;
      margin-bottom: 6px;
      color: #1e40af;
    }
    .selftest-dependencies-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .selftest-dep-badge {
      display: inline-block;
      padding: 2px 6px;
      background: white;
      border: 1px solid #3b82f6;
      border-radius: 3px;
      font-family: ui-monospace, monospace;
      font-size: 11px;
      color: #1e40af;
    }
    .selftest-commands {
      margin-bottom: 16px;
      padding: 12px;
      background: #f9fafb;
      border-radius: 6px;
    }
    .selftest-commands-title {
      font-weight: 600;
      font-size: 12px;
      margin-bottom: 8px;
      color: #374151;
    }
    .selftest-command {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      font-family: ui-monospace, monospace;
      font-size: 11px;
      padding: 6px 8px;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
      word-break: break-all;
    }
    .selftest-command:last-child {
      margin-bottom: 0;
    }
    .selftest-command-copy-btn {
      background: none;
      border: none;
      color: #3b82f6;
      cursor: pointer;
      font-size: 12px;
      padding: 0;
      flex-shrink: 0;
    }
    .selftest-command-copy-btn:hover {
      color: #1e40af;
    }
    .selftest-modal-close {
      float: right;
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #6b7280;
      padding: 0;
      line-height: 1;
      margin-top: -8px;
    }
    .selftest-modal-close:hover {
      color: #111827;
    }
    /* AC (Acceptance Criteria) badges */
    .selftest-ac-container {
      margin-bottom: 16px;
      padding: 12px;
      background: #f0fdf4;
      border-left: 3px solid #10b981;
      border-radius: 4px;
    }
    .selftest-ac-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #047857;
      font-weight: 600;
      margin-bottom: 8px;
      display: block;
    }
    .selftest-ac-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .selftest-ac-badge {
      display: inline-block;
      padding: 4px 8px;
      background: white;
      border: 1px solid #d1fae5;
      border-radius: 3px;
      font-family: ui-monospace, SFMono-Regular, monospace;
      font-size: 11px;
      color: #047857;
      font-weight: 500;
    }
    .selftest-ac-badge:hover {
      background: #f0fdf4;
      border-color: #6ee7b7;
      cursor: help;
    }
    .selftest-ac-badge.pass {
      border-color: #86efac;
      color: #15803d;
    }
    .selftest-ac-badge.warning {
      background: #fef3c7;
      border-color: #fcd34d;
      color: #92400e;
    }
    .selftest-ac-badge.critical {
      background: #fee2e2;
      border-color: #fca5a5;
      color: #991b1b;
    }
    .selftest-plan-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .selftest-plan-item {
      padding: 10px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .selftest-plan-item:hover {
      background: #f9fafb;
      border-color: #d1d5db;
    }
    .selftest-plan-item.kernel {
      border-left: 3px solid #dc2626;
    }
    .selftest-plan-item.governance {
      border-left: 3px solid #f59e0b;
    }
    .selftest-plan-item.optional {
      border-left: 3px solid #3b82f6;
    }
    .selftest-plan-item-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .selftest-plan-item-id {
      font-family: ui-monospace, monospace;
      font-size: 11px;
      font-weight: 600;
      color: #111827;
      flex: 0 0 auto;
      min-width: 100px;
    }
    .selftest-plan-item-desc {
      font-size: 12px;
      color: #374151;
      flex: 1;
    }
    .selftest-plan-item-icon {
      font-size: 14px;
      flex-shrink: 0;
    }

    /* Enhanced empty state */
    .welcome-panel {
      padding: 16px;
    }
    .welcome-panel h2 {
      margin-bottom: 12px;
    }
    .welcome-section {
      margin-bottom: 16px;
    }
    .welcome-section h3 {
      font-size: 12px;
      font-weight: 600;
      margin: 0 0 8px 0;
      color: #374151;
    }
    .welcome-list {
      margin: 0;
      padding-left: 20px;
      font-size: 12px;
      line-height: 1.6;
      color: #4b5563;
    }
    .welcome-hint {
      font-size: 11px;
      color: #6b7280;
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid #e5e7eb;
    }

    /* =========================================================================
     * State Components (Empty, Loading, Error)
     * =========================================================================
     * Consistent state treatment across all surfaces.
     */

    /* Empty state - no data available */
    .fs-empty {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: var(--fs-spacing-xl);
      text-align: center;
      color: var(--fs-color-text-muted);
    }
    .fs-empty-icon {
      font-size: 32px;
      margin-bottom: var(--fs-spacing-md);
      opacity: 0.5;
    }
    .fs-empty-title {
      font-size: var(--fs-font-size-lg);
      font-weight: 600;
      color: var(--fs-color-text);
      margin: 0 0 var(--fs-spacing-sm) 0;
    }
    .fs-empty-description {
      font-size: var(--fs-font-size-body);
      color: var(--fs-color-text-muted);
      margin: 0 0 var(--fs-spacing-lg) 0;
      max-width: 280px;
    }
    .fs-empty-action {
      padding: var(--fs-spacing-sm) var(--fs-spacing-lg);
      font-size: var(--fs-font-size-body);
      background: var(--fs-color-accent);
      color: white;
      border: none;
      border-radius: var(--fs-radius-md);
      cursor: pointer;
      transition: background var(--fs-transition-fast);
    }
    .fs-empty-action:hover {
      background: var(--fs-color-accent-hover);
    }
    .fs-empty-command {
      font-size: 11px;
      padding: 4px 8px;
      background: #f3f4f6;
      border-radius: var(--fs-radius-sm);
    }

    /* Keyboard hint styling */
    .fs-kbd {
      background: #f3f4f6;
      padding: 1px 4px;
      border-radius: 2px;
      font-size: 10px;
      font-family: var(--fs-font-mono);
    }

    /* Error state - something went wrong */
    .fs-error {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: var(--fs-spacing-xl);
      text-align: center;
      background: var(--fs-color-error-bg);
      border: 1px solid var(--fs-color-error);
      border-radius: var(--fs-radius-lg);
    }
    .fs-error-icon {
      font-size: 32px;
      margin-bottom: var(--fs-spacing-md);
    }
    .fs-error-title {
      font-size: var(--fs-font-size-lg);
      font-weight: 600;
      color: #991b1b;
      margin: 0 0 var(--fs-spacing-sm) 0;
    }
    .fs-error-description {
      font-size: var(--fs-font-size-body);
      color: #7f1d1d;
      margin: 0 0 var(--fs-spacing-lg) 0;
      max-width: 320px;
    }
    .fs-error-action {
      padding: var(--fs-spacing-sm) var(--fs-spacing-lg);
      font-size: var(--fs-font-size-body);
      background: var(--fs-color-error);
      color: white;
      border: none;
      border-radius: var(--fs-radius-md);
      cursor: pointer;
      transition: background var(--fs-transition-fast);
    }
    .fs-error-action:hover {
      background: #dc2626;
    }
    .fs-error-details {
      margin-top: var(--fs-spacing-md);
      padding: var(--fs-spacing-sm);
      background: rgba(0, 0, 0, 0.05);
      border-radius: var(--fs-radius-sm);
      font-family: var(--fs-font-family-mono);
      font-size: var(--fs-font-size-sm);
      color: #7f1d1d;
      max-width: 100%;
      overflow-x: auto;
    }

    /* Loading state - data is being fetched */
    .fs-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: var(--fs-spacing-xl);
      text-align: center;
      color: var(--fs-color-text-muted);
    }
    .fs-loading-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--fs-color-border);
      border-top-color: var(--fs-color-accent);
      border-radius: 50%;
      animation: fs-spin 1s linear infinite;
      margin-bottom: var(--fs-spacing-md);
    }
    .fs-loading-text {
      font-size: var(--fs-font-size-body);
      color: var(--fs-color-text-muted);
    }
    @keyframes fs-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Skeleton loading - placeholder content */
    .fs-skeleton {
      background: linear-gradient(90deg, var(--fs-color-bg-subtle) 25%, var(--fs-color-bg-muted) 50%, var(--fs-color-bg-subtle) 75%);
      background-size: 200% 100%;
      animation: fs-shimmer 1.5s infinite;
      border-radius: var(--fs-radius-md);
    }
    .fs-skeleton-text {
      height: 14px;
      margin-bottom: var(--fs-spacing-sm);
    }
    .fs-skeleton-text:last-child {
      margin-bottom: 0;
      width: 60%;
    }
    .fs-skeleton-card {
      height: 60px;
      margin-bottom: var(--fs-spacing-sm);
    }
    @keyframes fs-shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }

    /* Inline status badges */
    .fs-status-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--fs-spacing-xs);
      padding: 2px var(--fs-spacing-sm);
      font-size: var(--fs-font-size-xs);
      font-weight: 600;
      border-radius: var(--fs-radius-sm);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .fs-status-badge.success {
      background: var(--fs-color-success-bg);
      color: #14532d;
    }
    .fs-status-badge.warning {
      background: var(--fs-color-warning-bg);
      color: #92400e;
    }
    .fs-status-badge.error {
      background: var(--fs-color-error-bg);
      color: #991b1b;
    }
    .fs-status-badge.info {
      background: var(--fs-color-accent-bg);
      color: #1e40af;
    }

    /* Profile badge - header status indicator */
    .fs-profile-badge {
      padding: 0.25rem 0.75rem;
      border-radius: var(--fs-radius-md);
      font-size: 0.85rem;
      background: var(--fs-color-accent-bg);
      color: var(--fs-color-text-muted);
    }
    .fs-profile-badge--none {
      background: var(--fs-color-bg-subtle);
      color: var(--fs-color-text-muted);
    }
    .fs-profile-badge--error {
      background: var(--fs-color-error-bg);
      color: #991b1b;
    }

    /* =========================================================================
     * Run History Panel
     * =========================================================================
     */
    .run-history-section {
      margin-top: var(--fs-spacing-lg);
      border-top: 1px solid var(--fs-color-border);
      padding-top: var(--fs-spacing-md);
    }

    .run-history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--fs-spacing-sm);
    }

    .run-history-header .collapse-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 10px;
      color: var(--fs-color-text-muted);
      padding: 2px 4px;
      transition: transform 0.2s ease;
    }

    .run-history-header .collapse-toggle[aria-expanded="false"] {
      transform: rotate(-90deg);
    }

    .run-history-filter {
      display: flex;
      gap: var(--fs-spacing-xs);
      margin-bottom: var(--fs-spacing-sm);
    }

    .run-history-filter .filter-btn {
      padding: 2px 8px;
      font-size: 10px;
      border: 1px solid var(--fs-color-border);
      background: var(--fs-color-bg-base);
      border-radius: var(--fs-radius-sm);
      cursor: pointer;
      color: var(--fs-color-text-muted);
      transition: all 0.15s ease;
    }

    .run-history-filter .filter-btn:hover {
      border-color: var(--fs-color-accent);
    }

    .run-history-filter .filter-btn.active {
      background: var(--fs-color-accent-bg);
      border-color: var(--fs-color-accent);
      color: var(--fs-color-accent);
    }

    .run-history-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid var(--fs-color-border);
      border-radius: var(--fs-radius-md);
      background: var(--fs-color-bg-base);
    }

    .run-history-list.collapsed {
      display: none;
    }

    .run-history-item {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-sm);
      padding: var(--fs-spacing-sm);
      border-bottom: 1px solid var(--fs-color-border);
      cursor: pointer;
      transition: background-color 0.15s ease;
    }

    .run-history-item:last-child {
      border-bottom: none;
    }

    .run-history-item:hover {
      background: var(--fs-color-bg-muted);
    }

    .run-history-item.active {
      background: var(--fs-color-accent-bg);
    }

    .run-history-item-status {
      flex-shrink: 0;
      width: 16px;
      text-align: center;
    }

    .run-history-item-content {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .run-history-item-title {
      font-size: 11px;
      font-weight: 500;
      color: var(--fs-color-text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .run-history-item-meta {
      display: flex;
      gap: var(--fs-spacing-sm);
      font-size: 10px;
      color: var(--fs-color-text-muted);
      margin-top: 2px;
    }

    .run-history-item-badge {
      padding: 1px 4px;
      border-radius: var(--fs-radius-sm);
      font-size: 9px;
      text-transform: uppercase;
    }

    .run-history-item-badge.example {
      background: var(--fs-color-accent-bg);
      color: var(--fs-color-accent);
    }

    .run-history-item-badge.active {
      background: var(--fs-color-success-bg);
      color: #16a34a;
    }

    .run-history-item-badge.exemplar {
      background: var(--fs-color-warning-bg);
      color: #b45309;
    }

    .run-history-item-badge.backend {
      background: var(--fs-color-muted-bg, #f0f0f0);
      color: var(--fs-color-muted, #6b7280);
    }

    .run-history-item-actions {
      flex-shrink: 0;
    }

    .run-history-item-actions button {
      padding: 2px 6px;
      font-size: 10px;
      background: none;
      border: 1px solid var(--fs-color-border);
      border-radius: var(--fs-radius-sm);
      cursor: pointer;
      color: var(--fs-color-text-muted);
    }

    .run-history-item-actions button:hover {
      border-color: var(--fs-color-accent);
      color: var(--fs-color-accent);
    }

    /* =========================================================================
     * Run Detail Modal
     * =========================================================================
     */
    .run-detail-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .run-detail-modal.visible {
      display: flex;
    }

    .run-detail-content {
      background: var(--fs-color-bg-base);
      border-radius: var(--fs-radius-lg);
      padding: var(--fs-spacing-xl);
      max-width: 480px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1),
                  0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    .run-detail-close {
      position: absolute;
      top: var(--fs-spacing-md);
      right: var(--fs-spacing-md);
      width: 28px;
      height: 28px;
      border: none;
      background: var(--fs-color-bg-subtle);
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--fs-color-text-muted);
      transition: all 0.15s ease;
    }

    .run-detail-close:hover {
      background: var(--fs-color-error-bg);
      color: var(--fs-color-error);
    }

    .run-detail-content h3 {
      margin: 0 0 var(--fs-spacing-lg) 0;
      font-size: 16px;
      color: var(--fs-color-text);
    }

    .run-detail-section {
      margin-bottom: var(--fs-spacing-md);
    }

    .run-detail-section .kv-label {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--fs-color-text-subtle);
      margin-bottom: 2px;
    }

    .run-detail-error {
      padding: var(--fs-spacing-sm);
      background: var(--fs-color-error-bg);
      color: #991b1b;
      border-radius: var(--fs-radius-sm);
      font-size: 12px;
      font-family: var(--fs-font-mono);
    }

    .run-detail-actions {
      display: flex;
      gap: var(--fs-spacing-md);
      align-items: center;
      margin-top: var(--fs-spacing-lg);
      padding-top: var(--fs-spacing-md);
      border-top: 1px solid var(--fs-color-border);
    }

    .btn-primary {
      padding: var(--fs-spacing-sm) var(--fs-spacing-md);
      background: var(--fs-color-accent);
      color: white;
      border: none;
      border-radius: var(--fs-radius-md);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: background-color 0.15s ease;
    }

    .btn-primary:hover {
      background: var(--fs-color-accent-hover);
    }

    .btn-primary:disabled {
      background: var(--fs-color-bg-subtle);
      color: var(--fs-color-text-muted);
      cursor: not-allowed;
    }

    .exemplar-toggle {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-sm);
      font-size: 12px;
      color: var(--fs-color-text-muted);
      cursor: pointer;
    }

    .exemplar-toggle input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    /* Status badges for run detail */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--fs-spacing-xs);
      padding: 2px 8px;
      border-radius: var(--fs-radius-sm);
      font-size: 11px;
      font-weight: 500;
    }

    .status-badge.pending {
      background: var(--fs-color-bg-subtle);
      color: var(--fs-color-text-muted);
    }

    .status-badge.running {
      background: var(--fs-color-accent-bg);
      color: var(--fs-color-accent);
    }

    .status-badge.succeeded {
      background: var(--fs-color-success-bg);
      color: #16a34a;
    }

    .status-badge.failed {
      background: var(--fs-color-error-bg);
      color: #dc2626;
    }

    .status-badge.canceled {
      background: var(--fs-color-warning-bg);
      color: #b45309;
    }

    /* =========================================================================
     * Teaching Mode Toggle
     * =========================================================================
     * A toggle button in the header that enables pedagogical features.
     */
    .teaching-mode-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      font-size: 11px;
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      background: var(--fs-color-bg-muted, #f9fafb);
      border-radius: var(--fs-radius-md, 4px);
      cursor: pointer;
      transition: all var(--fs-transition-fast, 0.15s ease);
      color: var(--fs-color-text-muted, #6b7280);
    }

    .teaching-mode-toggle:hover {
      background: var(--fs-color-bg-subtle, #f3f4f6);
      border-color: var(--fs-color-accent, #3b82f6);
    }

    .teaching-mode-toggle.active {
      background: #fef3c7;
      border-color: #f59e0b;
      color: #92400e;
    }

    .teaching-mode-toggle.active .teaching-mode-icon {
      animation: teaching-pulse 2s ease-in-out infinite;
    }

    .teaching-mode-icon {
      font-size: 14px;
    }

    .teaching-mode-label {
      font-weight: 500;
    }

    @keyframes teaching-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    /* Teaching Mode Active Indicator */
    body.teaching-mode .teaching-mode-indicator {
      display: block;
    }

    .teaching-mode-indicator {
      display: none;
      position: fixed;
      top: 60px;
      right: 16px;
      padding: 4px 10px;
      background: #fef3c7;
      border: 1px solid #f59e0b;
      border-radius: var(--fs-radius-md, 4px);
      font-size: 10px;
      color: #92400e;
      z-index: 100;
      pointer-events: none;
    }

    /* Teaching Mode - subtle visual cues */
    body.teaching-mode #app {
      /* Subtle warm tint to indicate teaching mode */
      box-shadow: inset 0 0 0 2px rgba(245, 158, 11, 0.1);
    }

    body.teaching-mode .run-history-item-badge.example {
      /* Highlight examples more prominently in teaching mode */
      background: #fef3c7;
      color: #92400e;
      border: 1px solid #f59e0b;
    }

    /* =========================================================================
     * Teaching Callout in Step Details
     * =========================================================================
     * A callout displayed in the step details panel when Teaching Mode is on.
     * Shows teaching notes that explain why a step matters and what to look for.
     */
    .teaching-callout {
      display: none;
      margin: 12px 0;
      padding: 12px;
      background: linear-gradient(135deg, #fef3c7 0%, #fefce8 100%);
      border: 1px solid #f59e0b;
      border-left: 4px solid #f59e0b;
      border-radius: var(--fs-radius-md, 4px);
    }

    body.teaching-mode .teaching-callout {
      display: flex;
      gap: 10px;
      align-items: flex-start;
    }

    .teaching-callout-icon {
      font-size: 20px;
      line-height: 1;
      flex-shrink: 0;
    }

    .teaching-callout-content {
      flex: 1;
      min-width: 0;
    }

    .teaching-callout-label {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #92400e;
      margin-bottom: 4px;
    }

    .teaching-callout-text {
      font-size: 13px;
      line-height: 1.5;
      color: #78350f;
    }

    /* =========================================================================
     * Exemplar Badge for Run History Items
     * =========================================================================
     * Marks runs that are curated best-practice examples.
     */
    .run-history-item-badge.exemplar {
      background: var(--fs-color-warning-bg, #fef3c7);
      color: #b45309;
      font-weight: 600;
    }

    body.teaching-mode .run-history-item-badge.exemplar {
      background: #fef3c7;
      border: 1px solid #f59e0b;
      animation: exemplar-pulse 2s ease-in-out infinite;
    }

    @keyframes exemplar-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* =========================================================================
     * Transcript Tab Styles
     * ========================================================================= */

    .transcript-container {
      padding: 8px;
      max-height: 500px;
      overflow-y: auto;
    }

    .transcript-engine {
      margin-bottom: 12px;
      font-size: 12px;
      color: var(--fs-color-text-muted, #6b7280);
    }

    .transcript-message {
      margin-bottom: 12px;
      padding: 8px 12px;
      border-left: 3px solid #e5e7eb;
      background: #f9fafb;
      border-radius: 4px;
    }

    .transcript-message.transcript-role-system {
      border-left-color: #f59e0b;
      background: #fffbeb;
    }

    .transcript-message.transcript-role-user {
      border-left-color: #3b82f6;
      background: #eff6ff;
    }

    .transcript-message.transcript-role-assistant {
      border-left-color: #10b981;
      background: #ecfdf5;
    }

    .transcript-header {
      margin-bottom: 4px;
    }

    .transcript-role {
      font-weight: 600;
      font-size: 11px;
      text-transform: uppercase;
      color: #374151;
    }

    .transcript-content {
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.5;
      color: #1f2937;
    }

    /* =========================================================================
     * Engine/Mode/Provider Badges for Run Detail Panel
     * =========================================================================
     * Visual indicators showing execution metadata from step receipts.
     */

    .run-detail-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
      margin-bottom: 8px;
    }

    .run-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: var(--fs-radius-sm, 3px);
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      border: 1px solid;
    }

    .run-badge-label {
      color: #6b7280;
      font-weight: 400;
      margin-right: 2px;
    }

    /* Engine badges */
    .run-badge.engine {
      background: #dbeafe;
      border-color: #93c5fd;
      color: #1e40af;
    }

    .run-badge.engine.claude-step {
      background: #fce7f3;
      border-color: #f9a8d4;
      color: #9d174d;
    }

    .run-badge.engine.gemini-step {
      background: #dcfce7;
      border-color: #86efac;
      color: #166534;
    }

    /* Mode badges */
    .run-badge.mode {
      background: #f3f4f6;
      border-color: #d1d5db;
      color: #374151;
    }

    .run-badge.mode.stub {
      background: #fef3c7;
      border-color: #fcd34d;
      color: #92400e;
    }

    .run-badge.mode.sdk {
      background: #d1fae5;
      border-color: #6ee7b7;
      color: #047857;
    }

    .run-badge.mode.cli {
      background: #e0e7ff;
      border-color: #a5b4fc;
      color: #4338ca;
    }

    /* Provider badges */
    .run-badge.provider {
      background: #f5f3ff;
      border-color: #c4b5fd;
      color: #6d28d9;
    }

    .run-badge.provider.anthropic {
      background: #fff1f2;
      border-color: #fda4af;
      color: #be123c;
    }

    .run-badge.provider.gemini {
      background: #ecfdf5;
      border-color: #6ee7b7;
      color: #065f46;
    }

    .run-badge.provider.none {
      background: #f3f4f6;
      border-color: #d1d5db;
      color: #6b7280;
    }

    /* Badge loading state */
    .run-detail-badges .loading {
      font-size: 10px;
      color: #9ca3af;
      font-style: italic;
    }

    /* =========================================================================
     * Structured Teaching Notes
     * =========================================================================
     * Displays teaching_notes in a structured format with inputs, outputs,
     * emphasizes, and constraints sections.
     */
    .teaching-notes-structured {
      display: none;
      margin: 12px 0;
      padding: 12px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 4px;
    }

    body.teaching-mode .teaching-notes-structured {
      display: block;
    }

    .teaching-notes-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e5e7eb;
    }

    .teaching-notes-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .teaching-notes-section { margin-bottom: 10px; }
    .teaching-notes-label { font-size: 11px; font-weight: 600; color: #6b7280; margin-bottom: 4px; }
    .teaching-notes-list { margin: 0; padding-left: 16px; font-size: 11px; }
    .teaching-notes-list.inputs li, .teaching-notes-list.outputs li { color: #3b82f6; }
    .teaching-notes-list.emphasizes li { color: #22c55e; }
    .teaching-notes-list.constraints li { color: #ef4444; }

    /* =========================================================================
     * Routing Decision Display
     * =========================================================================
     * Shows routing decision information from step receipts.
     */
    .routing-decision {
      margin-top: 12px;
      padding: 10px;
      background: #f3f4f6;
      border-radius: 4px;
      border-left: 3px solid #3b82f6;
    }

    .routing-decision-header {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      color: #6b7280;
      margin-bottom: 8px;
    }

    .routing-kind-badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .routing-kind-badge.linear { background: #f9fafb; color: #6b7280; border: 1px solid #e5e7eb; }
    .routing-kind-badge.microloop { background: #dbeafe; color: #1e40af; }

    .routing-detail {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid #e5e7eb;
      font-size: 11px;
    }
    .routing-detail:last-child { border-bottom: none; }
    .routing-label { color: #6b7280; }
    .routing-value { font-weight: 500; }
    .routing-value.exit-reason.success { color: #22c55e; }
    .routing-value.exit-reason.warning { color: #f59e0b; }

    /* =========================================================================
     * Run Control Panel
     * =========================================================================
     * Controls for starting, pausing, resuming, and canceling runs.
     */
    .run-control-panel {
      margin-bottom: var(--fs-spacing-md, 12px);
      padding: var(--fs-spacing-sm, 8px);
      background: var(--fs-color-bg-subtle, #f3f4f6);
      border: 1px solid var(--fs-color-border, #e5e7eb);
      border-radius: var(--fs-radius-md, 4px);
    }

    .run-control-buttons {
      display: flex;
      gap: var(--fs-spacing-xs, 4px);
      margin-bottom: var(--fs-spacing-sm, 8px);
    }

    .run-control-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--fs-spacing-xs, 4px);
      flex: 1;
      padding: var(--fs-spacing-sm, 8px) var(--fs-spacing-md, 12px);
      font-size: var(--fs-font-size-sm, 11px);
      font-weight: 500;
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      border-radius: var(--fs-radius-md, 4px);
      background: var(--fs-color-bg-base, #ffffff);
      color: var(--fs-color-text, #111827);
      cursor: pointer;
      transition: all var(--fs-transition-fast, 0.15s ease);
    }

    .run-control-btn:hover:not(:disabled) {
      background: var(--fs-color-bg-muted, #f9fafb);
      border-color: var(--fs-color-accent, #3b82f6);
    }

    .run-control-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .run-control-btn:focus {
      outline: none;
      box-shadow: 0 0 0 2px var(--fs-color-accent-bg, #dbeafe);
    }

    .run-control-icon {
      font-size: 12px;
      line-height: 1;
    }

    .run-control-label {
      display: none;
    }

    @media (min-width: 1200px) {
      .run-control-label {
        display: inline;
      }
    }

    /* Play/Start button */
    .run-control-btn--play {
      background: var(--fs-color-success-bg, #dcfce7);
      border-color: var(--fs-color-success, #22c55e);
      color: #166534;
    }

    .run-control-btn--play:hover:not(:disabled) {
      background: #bbf7d0;
      border-color: #16a34a;
    }

    /* Pause button */
    .run-control-btn--pause {
      background: var(--fs-color-warning-bg, #fef3c7);
      border-color: var(--fs-color-warning, #f59e0b);
      color: #92400e;
    }

    .run-control-btn--pause:hover:not(:disabled) {
      background: #fde68a;
      border-color: #d97706;
    }

    /* Resume button */
    .run-control-btn--resume {
      background: var(--fs-color-accent-bg, #dbeafe);
      border-color: var(--fs-color-accent, #3b82f6);
      color: #1e40af;
    }

    .run-control-btn--resume:hover:not(:disabled) {
      background: #bfdbfe;
      border-color: #2563eb;
    }

    /* Stop button (formerly cancel) */
    .run-control-btn--stop,
    .run-control-btn--cancel /* deprecated alias */ {
      background: var(--fs-color-warning-bg, #fef3c7);
      border-color: var(--fs-color-warning, #f59e0b);
      color: #92400e;
    }

    .run-control-btn--stop:hover:not(:disabled),
    .run-control-btn--cancel:hover:not(:disabled) /* deprecated alias */ {
      background: #fde68a;
      border-color: #d97706;
    }

    /* Status display */
    .run-control-status {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-sm, 8px);
      padding: var(--fs-spacing-xs, 4px) var(--fs-spacing-sm, 8px);
      background: var(--fs-color-bg-base, #ffffff);
      border-radius: var(--fs-radius-sm, 3px);
      font-size: var(--fs-font-size-xs, 10px);
      min-height: 24px;
      position: relative;
      overflow: hidden;
    }

    .run-control-status-text {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .run-control-status-text--loading {
      color: var(--fs-color-text-muted, #6b7280);
      animation: run-control-pulse 1.5s ease-in-out infinite;
    }

    .run-control-status-text--running {
      color: var(--fs-color-accent, #3b82f6);
      font-weight: 500;
    }

    .run-control-status-text--paused {
      color: var(--fs-color-warning, #f59e0b);
      font-weight: 500;
    }

    .run-control-status-text--completed {
      color: var(--fs-color-success, #22c55e);
      font-weight: 500;
    }

    .run-control-status-text--failed {
      color: var(--fs-color-error, #ef4444);
      font-weight: 500;
    }

    .run-control-status-text--stopped {
      color: var(--fs-color-warning, #f59e0b);
      font-weight: 500;
    }

    @keyframes run-control-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Progress bar */
    .run-control-progress {
      position: absolute;
      bottom: 0;
      left: 0;
      height: 2px;
      background: var(--fs-color-accent, #3b82f6);
      transition: width 0.3s ease;
    }

    /* State-based styling */
    .run-control-status--pending {
      border-left: 3px solid var(--fs-color-border, #e5e7eb);
    }

    .run-control-status--running {
      border-left: 3px solid var(--fs-color-accent, #3b82f6);
      background: linear-gradient(90deg, var(--fs-color-accent-bg, #dbeafe) 0%, var(--fs-color-bg-base, #ffffff) 100%);
    }

    .run-control-status--paused {
      border-left: 3px solid var(--fs-color-warning, #f59e0b);
      background: linear-gradient(90deg, var(--fs-color-warning-bg, #fef3c7) 0%, var(--fs-color-bg-base, #ffffff) 100%);
    }

    .run-control-status--completed {
      border-left: 3px solid var(--fs-color-success, #22c55e);
      background: linear-gradient(90deg, var(--fs-color-success-bg, #dcfce7) 0%, var(--fs-color-bg-base, #ffffff) 100%);
    }

    .run-control-status--failed {
      border-left: 3px solid var(--fs-color-error, #ef4444);
      background: linear-gradient(90deg, var(--fs-color-error-bg, #fee2e2) 0%, var(--fs-color-bg-base, #ffffff) 100%);
    }

    .run-control-status--stopped {
      border-left: 3px solid var(--fs-color-warning, #f59e0b);
      background: linear-gradient(90deg, var(--fs-color-warning-bg, #fef3c7) 0%, var(--fs-color-bg-base, #ffffff) 100%);
    }

    /* Spinner for loading states */
    .run-control-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid var(--fs-color-border, #e5e7eb);
      border-top-color: var(--fs-color-accent, #3b82f6);
      border-radius: 50%;
      animation: run-control-spin 0.8s linear infinite;
    }

    @keyframes run-control-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* =========================================================================
     * Node Inspector
     * =========================================================================
     * Form-based editor for flow step properties.
     */
    .node-inspector {
      display: flex;
      flex-direction: column;
      height: 100%;
      padding: var(--fs-spacing-md, 12px);
    }

    .node-inspector__header {
      margin-bottom: var(--fs-spacing-lg, 16px);
      padding-bottom: var(--fs-spacing-md, 12px);
      border-bottom: 1px solid var(--fs-color-border, #e5e7eb);
    }

    .node-inspector__title {
      margin: 0;
      font-size: var(--fs-font-size-lg, 14px);
      font-weight: 600;
      color: var(--fs-color-text, #111827);
    }

    /* Loading state */
    .node-inspector__loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: var(--fs-spacing-md, 12px);
      padding: var(--fs-spacing-xl, 24px);
      color: var(--fs-color-text-muted, #6b7280);
    }

    .node-inspector__spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--fs-color-border, #e5e7eb);
      border-top-color: var(--fs-color-accent, #3b82f6);
      border-radius: 50%;
      animation: run-control-spin 0.8s linear infinite;
    }

    /* Error state */
    .node-inspector__error {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--fs-spacing-md, 12px);
      padding: var(--fs-spacing-xl, 24px);
      text-align: center;
    }

    .node-inspector__error-icon {
      font-size: 32px;
      color: var(--fs-color-warning, #f59e0b);
    }

    .node-inspector__error-message {
      color: var(--fs-color-error, #ef4444);
      font-size: var(--fs-font-size-sm, 11px);
    }

    .node-inspector__retry-btn {
      padding: var(--fs-spacing-sm, 8px) var(--fs-spacing-md, 12px);
      background: var(--fs-color-bg-subtle, #f3f4f6);
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      border-radius: var(--fs-radius-md, 4px);
      cursor: pointer;
      font-size: var(--fs-font-size-sm, 11px);
      transition: all var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__retry-btn:hover {
      background: var(--fs-color-bg-muted, #f9fafb);
      border-color: var(--fs-color-accent, #3b82f6);
    }

    /* Form */
    .node-inspector__form {
      flex: 1;
      overflow-y: auto;
      padding-right: var(--fs-spacing-xs, 4px);
    }

    .node-inspector__field {
      margin-bottom: var(--fs-spacing-lg, 16px);
    }

    .node-inspector__field--checkbox {
      display: flex;
      flex-direction: column;
      gap: var(--fs-spacing-xs, 4px);
    }

    .node-inspector__field--collapsed {
      display: none;
    }

    .node-inspector__label {
      display: block;
      margin-bottom: var(--fs-spacing-xs, 4px);
      font-size: var(--fs-font-size-xs, 10px);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--fs-color-text-muted, #6b7280);
    }

    .node-inspector__readonly {
      padding: var(--fs-spacing-sm, 8px);
      background: var(--fs-color-bg-subtle, #f3f4f6);
      border-radius: var(--fs-radius-sm, 3px);
      font-size: var(--fs-font-size-body, 12px);
      color: var(--fs-color-text-muted, #6b7280);
    }

    .node-inspector__textarea,
    .node-inspector__select {
      width: 100%;
      padding: var(--fs-spacing-sm, 8px);
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      border-radius: var(--fs-radius-md, 4px);
      font-family: inherit;
      font-size: var(--fs-font-size-body, 12px);
      resize: vertical;
      transition: border-color var(--fs-transition-fast, 0.15s ease),
                  box-shadow var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__textarea:focus,
    .node-inspector__select:focus {
      outline: none;
      border-color: var(--fs-color-accent, #3b82f6);
      box-shadow: 0 0 0 2px var(--fs-color-accent-bg, #dbeafe);
    }

    .node-inspector__input--error {
      border-color: var(--fs-color-error, #ef4444) !important;
    }

    .node-inspector__input--error:focus {
      box-shadow: 0 0 0 2px var(--fs-color-error-bg, #fee2e2) !important;
    }

    .node-inspector__field-error {
      margin-top: var(--fs-spacing-xs, 4px);
      font-size: var(--fs-font-size-xs, 10px);
      color: var(--fs-color-error, #ef4444);
    }

    .node-inspector__field-description {
      font-size: var(--fs-font-size-xs, 10px);
      color: var(--fs-color-text-subtle, #9ca3af);
    }

    /* Tag input */
    .node-inspector__tag-input {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--fs-spacing-xs, 4px);
      padding: var(--fs-spacing-xs, 4px) var(--fs-spacing-sm, 8px);
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      border-radius: var(--fs-radius-md, 4px);
      min-height: 36px;
      cursor: text;
      transition: border-color var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__tag-input:focus-within {
      border-color: var(--fs-color-accent, #3b82f6);
      box-shadow: 0 0 0 2px var(--fs-color-accent-bg, #dbeafe);
    }

    .node-inspector__tags {
      display: flex;
      flex-wrap: wrap;
      gap: var(--fs-spacing-xs, 4px);
    }

    .node-inspector__tag {
      display: inline-flex;
      align-items: center;
      gap: var(--fs-spacing-xs, 4px);
      padding: 2px 6px;
      background: var(--fs-color-accent-bg, #dbeafe);
      border-radius: var(--fs-radius-sm, 3px);
      font-size: var(--fs-font-size-xs, 10px);
      color: var(--fs-color-accent, #3b82f6);
    }

    .node-inspector__tag-remove {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      padding: 0;
      border: none;
      background: none;
      color: var(--fs-color-accent, #3b82f6);
      cursor: pointer;
      font-size: 12px;
      border-radius: 50%;
      transition: all var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__tag-remove:hover {
      background: var(--fs-color-error-bg, #fee2e2);
      color: var(--fs-color-error, #ef4444);
    }

    .node-inspector__tag-input-field {
      flex: 1;
      min-width: 80px;
      border: none;
      outline: none;
      font-size: var(--fs-font-size-sm, 11px);
      padding: var(--fs-spacing-xs, 4px);
      background: transparent;
    }

    /* List editor */
    .node-inspector__list-editor {
      border: 1px solid var(--fs-color-border, #e5e7eb);
      border-radius: var(--fs-radius-md, 4px);
      overflow: hidden;
    }

    .node-inspector__list-items {
      max-height: 120px;
      overflow-y: auto;
    }

    .node-inspector__list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--fs-spacing-sm, 8px);
      border-bottom: 1px solid var(--fs-color-border, #e5e7eb);
    }

    .node-inspector__list-item:last-child {
      border-bottom: none;
    }

    .node-inspector__list-item-text {
      flex: 1;
      font-size: var(--fs-font-size-sm, 11px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .node-inspector__list-item-remove {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      padding: 0;
      border: none;
      background: none;
      color: var(--fs-color-text-muted, #6b7280);
      cursor: pointer;
      font-size: 14px;
      transition: color var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__list-item-remove:hover {
      color: var(--fs-color-error, #ef4444);
    }

    .node-inspector__list-add {
      display: flex;
      padding: var(--fs-spacing-xs, 4px);
      background: var(--fs-color-bg-subtle, #f3f4f6);
      border-top: 1px solid var(--fs-color-border, #e5e7eb);
    }

    .node-inspector__list-add-input {
      flex: 1;
      padding: var(--fs-spacing-xs, 4px) var(--fs-spacing-sm, 8px);
      border: 1px solid var(--fs-color-border, #e5e7eb);
      border-radius: var(--fs-radius-sm, 3px);
      font-size: var(--fs-font-size-sm, 11px);
    }

    .node-inspector__list-add-input:focus {
      outline: none;
      border-color: var(--fs-color-accent, #3b82f6);
    }

    .node-inspector__list-add-btn {
      margin-left: var(--fs-spacing-xs, 4px);
      padding: var(--fs-spacing-xs, 4px) var(--fs-spacing-sm, 8px);
      background: var(--fs-color-accent, #3b82f6);
      border: none;
      border-radius: var(--fs-radius-sm, 3px);
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background-color var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__list-add-btn:hover {
      background: var(--fs-color-accent-hover, #2563eb);
    }

    /* Checkbox */
    .node-inspector__checkbox-label {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-sm, 8px);
      cursor: pointer;
    }

    .node-inspector__checkbox-label input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .node-inspector__checkbox-text {
      font-size: var(--fs-font-size-body, 12px);
      color: var(--fs-color-text, #111827);
    }

    /* Actions */
    .node-inspector__actions {
      display: flex;
      gap: var(--fs-spacing-md, 12px);
      padding-top: var(--fs-spacing-lg, 16px);
      margin-top: var(--fs-spacing-md, 12px);
      border-top: 1px solid var(--fs-color-border, #e5e7eb);
    }

    .node-inspector__btn {
      flex: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--fs-spacing-sm, 8px);
      padding: var(--fs-spacing-sm, 8px) var(--fs-spacing-md, 12px);
      border-radius: var(--fs-radius-md, 4px);
      font-size: var(--fs-font-size-body, 12px);
      font-weight: 500;
      cursor: pointer;
      transition: all var(--fs-transition-fast, 0.15s ease);
    }

    .node-inspector__btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .node-inspector__btn--primary {
      background: var(--fs-color-accent, #3b82f6);
      border: none;
      color: white;
    }

    .node-inspector__btn--primary:hover:not(:disabled) {
      background: var(--fs-color-accent-hover, #2563eb);
    }

    .node-inspector__btn--secondary {
      background: var(--fs-color-bg-base, #ffffff);
      border: 1px solid var(--fs-color-border-strong, #d1d5db);
      color: var(--fs-color-text, #111827);
    }

    .node-inspector__btn--secondary:hover:not(:disabled) {
      background: var(--fs-color-bg-subtle, #f3f4f6);
    }

    .node-inspector__btn-spinner {
      width: 12px;
      height: 12px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-top-color: white;
      border-radius: 50%;
      animation: run-control-spin 0.8s linear infinite;
    }

    /* =========================================================================
     * Inventory Counts Component
     * =========================================================================
     * Displays inventory marker counts (REQ/SOL/TRC/ASM/DEC) with deltas.
     * Appears in the sidebar in operator mode.
     */
    .inventory-counts-container {
      margin-bottom: var(--fs-spacing-md);
      padding: var(--fs-spacing-sm);
      background: var(--fs-color-bg-muted);
      border-radius: var(--fs-radius-md);
      border: 1px solid var(--fs-color-border);
    }

    .inventory-counts {
      font-size: var(--fs-font-size-sm);
    }

    .inventory-counts__loading {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-sm);
      color: var(--fs-color-text-muted);
      font-style: italic;
    }

    .inventory-counts__spinner {
      width: 14px;
      height: 14px;
      border: 2px solid var(--fs-color-border);
      border-top-color: var(--fs-color-accent);
      border-radius: 50%;
      animation: run-control-spin 0.8s linear infinite;
    }

    .inventory-counts__error {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-xs);
      color: var(--fs-color-error);
      font-size: var(--fs-font-size-xs);
    }

    .inventory-counts__error-icon {
      font-size: 14px;
    }

    .inventory-counts__empty {
      color: var(--fs-color-text-subtle);
      font-size: var(--fs-font-size-xs);
      text-align: center;
      padding: var(--fs-spacing-sm) 0;
    }

    .inventory-counts__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--fs-spacing-sm);
    }

    .inventory-counts__title {
      font-weight: 600;
      font-size: var(--fs-font-size-xs);
      color: var(--fs-color-text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .inventory-counts__total {
      font-size: var(--fs-font-size-xs);
      color: var(--fs-color-text-subtle);
    }

    .inventory-counts__expand-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 10px;
      color: var(--fs-color-text-muted);
      padding: 2px 4px;
      border-radius: var(--fs-radius-sm);
      transition: background-color var(--fs-transition-fast);
    }

    .inventory-counts__expand-btn:hover {
      background: var(--fs-color-bg-subtle);
    }

    .inventory-counts__bar {
      display: flex;
      gap: var(--fs-spacing-sm);
      flex-wrap: wrap;
    }

    .inventory-counts__item {
      display: flex;
      align-items: center;
      gap: 3px;
      padding: 2px 4px;
      border-radius: var(--fs-radius-sm);
      background: var(--fs-color-bg-base);
      transition: background-color var(--fs-transition-fast);
    }

    .inventory-counts__item:hover {
      background: var(--fs-color-bg-subtle);
    }

    .inventory-counts__icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 14px;
      height: 14px;
      border-radius: 2px;
      font-size: 9px;
      font-weight: 700;
      color: white;
    }

    .inventory-counts__count {
      font-size: var(--fs-font-size-xs);
      font-weight: 500;
      color: var(--fs-color-text);
      min-width: 12px;
      text-align: center;
    }

    .inventory-counts__delta {
      font-size: 9px;
      font-weight: 600;
      margin-left: 2px;
    }

    .inventory-counts__delta--positive {
      color: var(--fs-color-success);
    }

    .inventory-counts__delta--negative {
      color: var(--fs-color-error);
    }

    /* Expanded details section */
    .inventory-counts__details {
      margin-top: var(--fs-spacing-sm);
      padding-top: var(--fs-spacing-sm);
      border-top: 1px solid var(--fs-color-border);
    }

    .inventory-counts__section {
      margin-bottom: var(--fs-spacing-sm);
    }

    .inventory-counts__section:last-child {
      margin-bottom: 0;
    }

    .inventory-counts__section-header {
      font-size: var(--fs-font-size-xs);
      font-weight: 600;
      color: var(--fs-color-text-muted);
      margin-bottom: var(--fs-spacing-xs);
    }

    .inventory-counts__flow-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .inventory-counts__flow-item {
      display: flex;
      align-items: center;
      gap: var(--fs-spacing-sm);
      padding: 3px var(--fs-spacing-xs);
      border-radius: var(--fs-radius-sm);
      transition: background-color var(--fs-transition-fast);
    }

    .inventory-counts__flow-item:hover {
      background: var(--fs-color-bg-subtle);
    }

    .inventory-counts__flow-name {
      font-size: var(--fs-font-size-xs);
      font-weight: 500;
      color: var(--fs-color-text);
      min-width: 50px;
    }

    .inventory-counts__flow-counts {
      display: flex;
      gap: var(--fs-spacing-xs);
      flex: 1;
    }

    .inventory-counts__flow-total {
      font-size: var(--fs-font-size-xs);
      color: var(--fs-color-text-subtle);
    }

    .inventory-counts__mini-count {
      font-size: 9px;
      font-weight: 600;
    }

    .inventory-counts__delta-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .inventory-counts__delta-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 3px var(--fs-spacing-xs);
      border-radius: var(--fs-radius-sm);
      transition: background-color var(--fs-transition-fast);
    }

    .inventory-counts__delta-item:hover {
      background: var(--fs-color-bg-subtle);
    }

    .inventory-counts__delta-steps {
      font-size: 9px;
      color: var(--fs-color-text-muted);
      font-family: var(--fs-font-family-mono);
    }

    .inventory-counts__delta-changes {
      display: flex;
      gap: var(--fs-spacing-xs);
    }

    .inventory-counts__delta-change {
      font-size: 9px;
      font-weight: 600;
    }

    .inventory-counts__delta-change--positive {
      opacity: 1;
    }

    .inventory-counts__delta-change--negative {
      opacity: 0.8;
    }
  </style>
  <script type="application/json" data-inline-source="flowstudio-js-bundle">
// api.js
// swarm/tools/flow_studio_ui/src/api.ts
// Centralized API client for Flow Studio
/**
 * Fetch JSON with error handling
 */
async function fetchJSON(url, options) {
    const resp = await fetch(url, options);
    if (!resp.ok) {
        throw new Error(`HTTP ${resp.status} for ${url}`);
    }
    return resp.json();
}
/**
 * API client with methods for all Flow Studio endpoints
 */
export const Api = {
    // ============================================================================
    // Runs
    // ============================================================================
    /**
     * Get list of available runs with pagination.
     * Optionally filter by flow key.
     *
     * @param options - Optional parameters for pagination and filtering
     * @param options.flowKey - Optional flow key to filter runs
     * @param options.limit - Maximum number of runs to return (default 100, max 500)
     * @param options.offset - Number of runs to skip from the beginning (default 0)
     */
    getRuns(options) {
        const params = new URLSearchParams();
        if (options?.flowKey) {
            params.set("flow", options.flowKey);
        }
        if (options?.limit !== undefined) {
            params.set("limit", String(options.limit));
        }
        if (options?.offset !== undefined) {
            params.set("offset", String(options.offset));
        }
        const queryString = params.toString();
        return fetchJSON(`/api/runs${queryString ? `?${queryString}` : ""}`);
    },
    /**
     * Get list of exemplar runs (curated examples).
     * These are runs marked as reference implementations.
     */
    listExemplars() {
        return fetchJSON("/api/runs/exemplars");
    },
    /**
     * Get run summary/status
     */
    getRunSummary(runId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/summary`);
    },
    /**
     * Get run timeline events
     */
    getRunTimeline(runId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/timeline`);
    },
    /**
     * Get all events for a run (from runtime layer).
     * Returns structured events like tool_start, tool_end, flow_start, etc.
     */
    getRunEvents(runId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/events`);
    },
    /**
     * Get run timing data
     */
    getRunTiming(runId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/timing`);
    },
    /**
     * Get flow-specific timing for a run
     */
    getFlowTiming(runId, flowKey) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/flows/${encodeURIComponent(flowKey)}/timing`);
    },
    /**
     * Compare two runs
     */
    compareRuns({ runA, runB, flow }) {
        return fetchJSON(`/api/runs/compare?run_a=${encodeURIComponent(runA)}&run_b=${encodeURIComponent(runB)}&flow=${encodeURIComponent(flow)}`);
    },
    // ============================================================================
    // Backends
    // ============================================================================
    /**
     * Get list of available backends and their capabilities.
     * Used to populate the backend selector in the UI.
     */
    getBackends() {
        return fetchJSON("/api/backends");
    },
    // ============================================================================
    // Flows & Graph
    // ============================================================================
    /**
     * Get all flows
     */
    getFlows() {
        return fetchJSON("/api/flows");
    },
    /**
     * Get flow details
     */
    getFlowDetail(flowKey) {
        return fetchJSON(`/api/flows/${encodeURIComponent(flowKey)}`);
    },
    /**
     * Get flow graph with agents view
     */
    getFlowGraphAgents(flowKey) {
        return fetchJSON(`/api/graph/${encodeURIComponent(flowKey)}`);
    },
    /**
     * Get flow graph with artifacts view
     */
    getFlowGraphArtifacts(flowKey, runId) {
        const runParam = runId ? `?run_id=${encodeURIComponent(runId)}` : "";
        return fetchJSON(`/api/graph/${encodeURIComponent(flowKey)}/artifacts${runParam}`);
    },
    // ============================================================================
    // Agents
    // ============================================================================
    /**
     * Get agent usage data across flows
     */
    getAgentUsage(agentKey) {
        return fetchJSON(`/api/agents/${encodeURIComponent(agentKey)}/usage`);
    },
    // ============================================================================
    // Search
    // ============================================================================
    /**
     * Search across flows, steps, agents, artifacts
     */
    search(query) {
        return fetchJSON(`/api/search?q=${encodeURIComponent(query)}`);
    },
    // ============================================================================
    // Governance & Validation
    // ============================================================================
    /**
     * Get governance/platform status
     */
    getGovernanceStatus() {
        return fetchJSON("/platform/status");
    },
    /**
     * Get validation data for overlays
     */
    getValidationData() {
        return fetchJSON("/api/validation");
    },
    // ============================================================================
    // Tours
    // ============================================================================
    /**
     * Get available tours
     */
    getTours() {
        return fetchJSON("/api/tours");
    },
    /**
     * Get tour by ID
     */
    getTourById(id) {
        return fetchJSON(`/api/tours/${encodeURIComponent(id)}`);
    },
    // ============================================================================
    // Selftest
    // ============================================================================
    /**
     * Get selftest plan
     */
    getSelftestPlan() {
        return fetchJSON("/api/selftest/plan");
    },
    // ============================================================================
    // Transcripts
    // ============================================================================
    /**
     * Get LLM transcript for a specific step (stepwise runs only)
     */
    getStepTranscript(runId, flowKey, stepId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/flows/${encodeURIComponent(flowKey)}/steps/${encodeURIComponent(stepId)}/transcript`);
    },
    /**
     * Get step receipt (execution metadata) for a specific step (stepwise runs only)
     */
    getStepReceipt(runId, flowKey, stepId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/flows/${encodeURIComponent(flowKey)}/steps/${encodeURIComponent(stepId)}/receipt`);
    },
    // ============================================================================
    // Wisdom
    // ============================================================================
    /**
     * Get wisdom summary for a run.
     * Returns structured wisdom data including flow statuses, metrics, and labels.
     * Throws 404 error if no wisdom summary exists for this run.
     *
     * @param runId - The run ID to get wisdom summary for
     * @returns WisdomSummary with flow status, metrics, labels, and key artifacts
     */
    getRunWisdom(runId) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/wisdom/summary`);
    },
    // ============================================================================
    // Boundary Review
    // ============================================================================
    /**
     * Get boundary review summary for a run.
     * Aggregates assumptions, decisions, detours, and verification results
     * for operator review at flow boundaries.
     *
     * @param runId - The run ID to get boundary review for
     * @param options - Optional parameters
     * @param options.scope - "flow" for current flow only, "run" for entire run (default "flow")
     * @param options.flowKey - Optional flow key to filter (when scope="flow")
     * @returns BoundaryReviewResponse with comprehensive boundary review data
     */
    getBoundaryReview(runId, options) {
        const params = new URLSearchParams();
        if (options?.scope) {
            params.set("scope", options.scope);
        }
        if (options?.flowKey) {
            params.set("flow_key", options.flowKey);
        }
        const queryString = params.toString();
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/boundary-review${queryString ? `?${queryString}` : ""}`);
    },
    // ============================================================================
    // Config
    // ============================================================================
    /**
     * Reload configuration
     */
    reloadConfig() {
        return fetchJSON("/api/reload", { method: "POST" });
    },
    // ============================================================================
    // Profiles
    // ============================================================================
    /**
     * Get current profile info
     */
    getCurrentProfile() {
        return fetchJSON("/api/profile");
    },
    /**
     * List all available profiles
     */
    listProfiles() {
        return fetchJSON("/api/profiles");
    },
    // ============================================================================
    // Run Actions
    // ============================================================================
    /**
     * Set or unset a run as an exemplar.
     * Exemplar runs are highlighted as reference implementations.
     *
     * @param runId - The run ID to modify
     * @param isExemplar - Whether to mark as exemplar (true) or unmark (false)
     */
    setRunExemplar(runId, isExemplar) {
        return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/exemplar`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ is_exemplar: isExemplar }),
        });
    },
    /**
     * Start a new run with the specified configuration.
     * Can be used to re-run an existing run's configuration or start fresh.
     *
     * @param params - Run configuration
     * @param params.flows - Array of flow keys to run (e.g., ["signal", "plan", "build"])
     * @param params.profile_id - Optional profile ID to use
     * @param params.backend - Optional backend identifier (e.g., "local", "github")
     * @returns Object containing the new run_id
     */
    startRun(params) {
        return fetchJSON("/api/run", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(params),
        });
    }
};
// For backwards compatibility, also export fetchJSON
export { fetchJSON };
// details.js
// swarm/tools/flow_studio_ui/src/details.ts
// Details panel rendering for Flow Studio
//
// This module handles the right-hand details panel, including:
// - Step details (with Node/Run/Selftest tabs)
// - Agent details (with usage information)
// - Artifact details
// - Timeline and timing visualizations
import { state } from "./state.js";
import { Api } from "./api.js";
import { getTeachingMode } from "./teaching_mode.js";
import { formatDuration, formatTime, formatDateTime, createQuickCommands, escapeHtml } from "./utils.js";
import { renderSelectNodeHint, renderAgentUsageItem, renderAgentLocationInfo, renderAgentCategoryHint, renderArtifactProducerHint, renderTabs, } from "./ui_fragments.js";
// ============================================================================
// Empty State
// ============================================================================
/**
 * Show the default empty state in the details panel.
 * Called when no node is selected.
 */
export function showEmptyState() {
    const detailsEl = document.getElementById("details");
    if (!detailsEl)
        return;
    detailsEl.innerHTML = renderSelectNodeHint();
}
/**
 * Render run-level timeline in the container
 */
export async function renderRunTimeline(container) {
    if (!state.currentRunId) {
        container.innerHTML = '<div class="muted">Select a run to see timeline</div>';
        return;
    }
    container.innerHTML = '<div class="muted">Loading timeline...</div>';
    try {
        const data = await Api.getRunTimeline(state.currentRunId);
        const events = data.events || [];
        if (events.length === 0) {
            container.innerHTML = '<div class="muted">No timeline data available for this run</div>';
            return;
        }
        let html = '<div class="timeline-container">';
        html += '<div class="timeline-header">Run Timeline</div>';
        events.forEach((event) => {
            const icon = event.status === 'started' ? '\u25CF' :
                event.status === 'completed' ? '\u2713' :
                    event.status === 'failed' ? '\u2717' : '\u2022';
            const time = formatTime(event.timestamp);
            const duration = event.duration_ms ? formatDuration(event.duration_ms / 1000) : '';
            html += `
        <div class="timeline-event ${event.status || ''}">
          <span class="timeline-time">${time}</span>
          <span class="timeline-icon">${icon}</span>
          <span class="timeline-flow">${event.flow}</span>
          <span class="timeline-status">${event.status || ''}</span>
          ${duration ? `<span class="timeline-duration">(${duration})</span>` : ''}
        </div>
      `;
            if (event.note) {
                html += `<div class="timeline-note">\u2514\u2500 ${event.note}</div>`;
            }
        });
        // Add total duration if available
        try {
            const timingData = await Api.getRunTiming(state.currentRunId);
            if (timingData.timing?.total_duration_seconds) {
                html += `<div class="timeline-total">Total: ${formatDuration(timingData.timing.total_duration_seconds)}</div>`;
            }
        }
        catch {
            // Timing data optional
        }
        html += '</div>';
        container.innerHTML = html;
    }
    catch (err) {
        console.error("Failed to load timeline", err);
        container.innerHTML = '<div class="muted">Timeline not available</div>';
    }
}
/**
 * Render flow timing summary in the container
 */
export async function renderFlowTiming(container, flowKey) {
    if (!state.currentRunId || !flowKey) {
        return;
    }
    try {
        const data = await Api.getFlowTiming(state.currentRunId, flowKey);
        const timing = data.timing;
        if (!timing || !timing.duration_seconds) {
            // In operator mode, show a helpful message about missing timing data
            if (state.currentMode === "operator") {
                container.insertAdjacentHTML('beforeend', `
          <div class="timing-empty-state">
            <div class="fs-text-sm fs-text-subtle" style="font-style: italic;">
              No timing data recorded for this flow.
              <br/><span class="fs-text-muted">Timing is captured in <code>flow_history.json</code> during flow execution.</span>
            </div>
          </div>
        `);
            }
            return;
        }
        let html = '<div class="timing-summary">';
        html += '<div class="timing-summary-header">';
        html += `<span class="timing-summary-duration">${formatDuration(timing.duration_seconds)}</span>`;
        if (timing.started_at && timing.ended_at) {
            html += `<span class="timing-summary-range">${formatDateTime(timing.started_at)} \u2192 ${formatDateTime(timing.ended_at)}</span>`;
        }
        html += '</div>';
        // Render step timing bars if we have step data
        const steps = timing.steps || [];
        if (steps.length > 0 && steps.some(s => s.duration_seconds)) {
            // Sort by duration descending, take top 5
            const sortedSteps = steps
                .filter(s => s.duration_seconds)
                .sort((a, b) => (b.duration_seconds || 0) - (a.duration_seconds || 0))
                .slice(0, 5);
            if (sortedSteps.length > 0) {
                const maxDuration = sortedSteps[0].duration_seconds || 1;
                html += '<div class="timing-bar-container">';
                html += '<div class="fs-text-sm fs-text-muted" style="margin-bottom: 6px;">Slowest Steps</div>';
                sortedSteps.forEach(step => {
                    const pct = Math.round(((step.duration_seconds || 0) / maxDuration) * 100);
                    const isSlow = (step.duration_seconds || 0) > timing.duration_seconds * 0.3;
                    html += `
            <div class="timing-bar-label">
              <span>${step.step_id}</span>
              <span>${formatDuration(step.duration_seconds || 0)}</span>
            </div>
            <div class="timing-bar">
              <div class="timing-bar-fill ${isSlow ? 'slow' : ''}" style="width: ${pct}%"></div>
            </div>
          `;
                });
                html += '</div>';
            }
        }
        html += '</div>';
        container.insertAdjacentHTML('beforeend', html);
    }
    catch (err) {
        console.error("Failed to load flow timing", err);
        // Silently fail - timing is optional
    }
}
/**
 * Render step timing inline
 */
export function renderStepTiming(timing) {
    if (!timing || (!timing.started_at && !timing.duration_seconds)) {
        return '';
    }
    let html = '<div class="step-timing">';
    if (timing.started_at) {
        html += `
      <div class="step-timing-row">
        <span class="step-timing-label">Started</span>
        <span class="step-timing-value">${formatTime(timing.started_at)}</span>
      </div>
    `;
    }
    if (timing.ended_at) {
        html += `
      <div class="step-timing-row">
        <span class="step-timing-label">Ended</span>
        <span class="step-timing-value">${formatTime(timing.ended_at)}</span>
      </div>
    `;
    }
    if (timing.duration_seconds) {
        html += `
      <div class="step-timing-row">
        <span class="step-timing-label">Duration</span>
        <span class="step-timing-value">${formatDuration(timing.duration_seconds)}</span>
      </div>
    `;
    }
    html += '</div>';
    return html;
}
// ============================================================================
// Agent Usage Rendering
// ============================================================================
/**
 * Render agent usage as clickable links
 */
export function renderAgentUsage(container, usage, callbacks = {}) {
    const { setActiveFlow, showStepDetails } = callbacks;
    container.innerHTML = '<div class="kv-label">Used in</div>';
    if (!usage.length) {
        const empty = document.createElement("div");
        empty.className = "muted";
        empty.textContent = "Not used in any flows";
        container.appendChild(empty);
        return;
    }
    const list = document.createElement("div");
    list.className = "fs-text-body";
    list.style.lineHeight = "1.8";
    usage.forEach(u => {
        const item = document.createElement("div");
        item.style.cursor = "pointer";
        item.style.padding = "2px 0";
        item.innerHTML = renderAgentUsageItem(u.flow_title, u.step_title);
        item.title = `Click to navigate to ${u.flow}:${u.step}`;
        item.addEventListener("click", async () => {
            if (setActiveFlow) {
                await setActiveFlow(u.flow, true);
                // After graph loads, select the step node
                setTimeout(() => {
                    if (state.cy) {
                        const nodeId = `step:${u.flow}:${u.step}`;
                        const node = state.cy.getElementById(nodeId);
                        if (node) {
                            state.cy.fit(50);
                            node.select();
                            if (showStepDetails) {
                                showStepDetails(node.data());
                            }
                        }
                    }
                }, 300);
            }
        });
        item.addEventListener("mouseenter", () => { item.style.background = "#f3f4f6"; });
        item.addEventListener("mouseleave", () => { item.style.background = "transparent"; });
        list.appendChild(item);
    });
    container.appendChild(list);
}
// ============================================================================
// Teaching Callout
// ============================================================================
/**
 * Render a teaching note callout for a step.
 * Only visible when Teaching Mode is enabled.
 *
 * @param teachingNote - The teaching note text to display
 * @returns HTML string for the teaching callout
 */
function renderTeachingCallout(teachingNote) {
    if (!teachingNote)
        return "";
    return `
    <div class="teaching-callout" data-uiid="flow_studio.inspector.teaching_note">
      <span class="teaching-callout-icon">&#x1F4A1;</span>
      <div class="teaching-callout-content">
        <div class="teaching-callout-label">Teaching Note</div>
        <div class="teaching-callout-text">${teachingNote}</div>
      </div>
    </div>
  `;
}
/**
 * Render structured teaching notes for a step.
 * Shows inputs, outputs, emphasizes, and constraints in a formatted display.
 * Only visible when Teaching Mode is enabled.
 */
function renderStructuredTeachingNotes(notes) {
    if (!notes)
        return "";
    const hasContent = (notes.inputs?.length ?? 0) > 0 ||
        (notes.outputs?.length ?? 0) > 0 ||
        (notes.emphasizes?.length ?? 0) > 0 ||
        (notes.constraints?.length ?? 0) > 0;
    if (!hasContent)
        return "";
    let html = `<div class="teaching-notes-structured" data-uiid="flow_studio.inspector.teaching_notes_structured">
    <div class="teaching-notes-header">
      <span class="teaching-notes-icon">&#x1F4D6;</span>
      <span class="teaching-notes-title">Step Context</span>
    </div>`;
    if (notes.inputs?.length) {
        html += `<div class="teaching-notes-section">
      <div class="teaching-notes-label">&#x1F4E5; Inputs</div>
      <ul class="teaching-notes-list inputs">
        ${notes.inputs.map(p => `<li class="mono">${p}</li>`).join('')}
      </ul>
    </div>`;
    }
    if (notes.outputs?.length) {
        html += `<div class="teaching-notes-section">
      <div class="teaching-notes-label">&#x1F4E4; Outputs</div>
      <ul class="teaching-notes-list outputs">
        ${notes.outputs.map(p => `<li class="mono">${p}</li>`).join('')}
      </ul>
    </div>`;
    }
    if (notes.emphasizes?.length) {
        html += `<div class="teaching-notes-section">
      <div class="teaching-notes-label">&#x2728; Emphasizes</div>
      <ul class="teaching-notes-list emphasizes">
        ${notes.emphasizes.map(e => `<li>${e}</li>`).join('')}
      </ul>
    </div>`;
    }
    if (notes.constraints?.length) {
        html += `<div class="teaching-notes-section">
      <div class="teaching-notes-label">&#x26D4; Constraints</div>
      <ul class="teaching-notes-list constraints">
        ${notes.constraints.map(c => `<li>${c}</li>`).join('')}
      </ul>
    </div>`;
    }
    html += '</div>';
    return html;
}
// ============================================================================
// Transcript Helpers
// ============================================================================
/**
 * Load and render transcript for a step
 */
async function loadTranscript(container, runId, flowKey, stepId) {
    container.innerHTML = '<div class="muted">Loading transcript...</div>';
    try {
        const resp = await Api.getStepTranscript(runId, flowKey, stepId);
        container.innerHTML = renderTranscript(resp);
    }
    catch {
        container.innerHTML = '<div class="muted">No transcript available for this step</div>';
    }
}
/**
 * Render transcript response to HTML
 */
function renderTranscript(resp) {
    if (!resp.messages || resp.messages.length === 0) {
        return '<div class="muted">No messages in transcript</div>';
    }
    let html = '<div class="transcript-container">';
    if (resp.engine) {
        html += `<div class="transcript-engine">Engine: <span class="mono">${escapeHtml(resp.engine)}</span></div>`;
    }
    resp.messages.forEach(msg => {
        const roleClass = `transcript-role-${msg.role}`;
        const contentPreview = msg.content.length > 500 ? msg.content.substring(0, 500) + '...' : msg.content;
        html += `
      <div class="transcript-message ${roleClass}">
        <div class="transcript-header">
          <span class="transcript-role">${escapeHtml(msg.role)}</span>
        </div>
        <div class="transcript-content">${escapeHtml(contentPreview)}</div>
      </div>
    `;
    });
    html += '</div>';
    return html;
}
// ============================================================================
// Receipt Badges Rendering
// ============================================================================
/**
 * Load and render engine/mode/provider badges for a step
 */
async function loadReceiptBadges(container, runId, flowKey, stepId) {
    container.innerHTML = '<span class="loading">Loading execution info...</span>';
    try {
        const resp = await Api.getStepReceipt(runId, flowKey, stepId);
        container.innerHTML = renderReceiptBadges(resp);
    }
    catch {
        // No receipt available - this is fine for non-stepwise runs
        container.innerHTML = '<span class="muted fs-text-sm">No execution metadata available</span>';
    }
}
/**
 * Render receipt badges HTML
 */
function renderReceiptBadges(resp) {
    const receipt = resp.receipt;
    if (!receipt) {
        return '<span class="muted fs-text-sm">No execution metadata</span>';
    }
    const badges = [];
    // Engine badge
    if (receipt.engine) {
        const engineClass = receipt.engine.replace(/\s+/g, '-').toLowerCase();
        badges.push(`<span class="run-badge engine ${engineClass}" title="Execution engine">${escapeHtml(receipt.engine)}</span>`);
    }
    // Mode badge
    if (receipt.mode) {
        const modeClass = receipt.mode.toLowerCase();
        badges.push(`<span class="run-badge mode ${modeClass}" title="Execution mode">${escapeHtml(receipt.mode)}</span>`);
    }
    // Provider badge
    if (receipt.provider) {
        const providerClass = receipt.provider.toLowerCase();
        badges.push(`<span class="run-badge provider ${providerClass}" title="LLM provider">${escapeHtml(receipt.provider)}</span>`);
    }
    if (badges.length === 0) {
        return '<span class="muted fs-text-sm">No execution metadata</span>';
    }
    // Add truncation info section if available
    const truncationHtml = renderContextTruncation(receipt.context_truncation);
    return badges.join('') + truncationHtml;
}
/**
 * Render context truncation metrics as a detailed section.
 * Shows history steps included/total, character budget usage, and priority distribution.
 */
function renderContextTruncation(truncation) {
    if (!truncation)
        return "";
    const { steps_included, steps_total, chars_used, budget_chars, truncated, priority_distribution } = truncation;
    const utilization = budget_chars > 0 ? Math.round((chars_used / budget_chars) * 100) : 0;
    // Color coding based on truncation status
    const bgColor = truncated ? "#fef2f2" : "#f0fdf4";
    const borderColor = truncated ? "#fecaca" : "#dcfce7";
    const statusColor = truncated ? "#dc2626" : "#059669";
    const statusText = truncated ? "TRUNCATED" : "Complete";
    // Priority distribution display
    let priorityHtml = "";
    if (priority_distribution) {
        const { CRITICAL, HIGH, MEDIUM, LOW } = priority_distribution;
        priorityHtml = `
      <div style="margin-top: 6px; font-size: 10px; color: #6b7280;">
        <span title="Critical priority items">C:${CRITICAL}</span>
        <span style="margin-left: 6px;" title="High priority items">H:${HIGH}</span>
        <span style="margin-left: 6px;" title="Medium priority items">M:${MEDIUM}</span>
        <span style="margin-left: 6px;" title="Low priority items">L:${LOW}</span>
      </div>
    `;
    }
    return `
    <div class="context-truncation-section" style="background: ${bgColor}; border-left: 3px solid ${borderColor}; padding: 8px; margin-top: 8px; border-radius: 4px;">
      <div style="font-weight: 500; margin-bottom: 4px; font-size: 11px; color: #374151;">Context Budget</div>
      <div style="font-size: 11px; line-height: 1.5;">
        <div><span style="color: #6b7280;">History:</span> ${steps_included}/${steps_total} steps</div>
        <div><span style="color: #6b7280;">Budget:</span> ${(chars_used / 1000).toFixed(0)}k/${(budget_chars / 1000).toFixed(0)}k chars (${utilization}%)</div>
        <div><span style="color: ${statusColor}; font-weight: 500;">${statusText}</span></div>
      </div>
      ${priorityHtml}
    </div>
  `;
}
/**
 * Render routing decision information from a step receipt.
 * Shows loop iteration, max iterations, decision type, and reason.
 */
function renderRoutingDecision(routing) {
    if (!routing)
        return "";
    let html = '<div class="routing-decision">';
    html += '<div class="routing-decision-header">Routing Decision</div>';
    const kindClass = routing.decision === 'loop' ? 'microloop' : 'linear';
    html += `<div class="routing-kind-badge ${kindClass}">${routing.decision.toUpperCase()}</div>`;
    if (routing.loop_iteration > 0 || routing.max_iterations) {
        html += `<div class="routing-detail">
      <span class="routing-label">Iteration</span>
      <span class="routing-value">${routing.loop_iteration} / ${routing.max_iterations ?? '\u221E'}</span>
    </div>`;
    }
    if (routing.reason) {
        const exitClass = routing.reason.toLowerCase().includes('verified') ? 'success' : 'warning';
        html += `<div class="routing-detail">
      <span class="routing-label">Reason</span>
      <span class="routing-value exit-reason ${exitClass}">${routing.reason}</span>
    </div>`;
    }
    html += '</div>';
    return html;
}
/**
 * Show step details in the details panel
 */
export async function showStepDetails(data, callbacks = {}) {
    const { renderSelftestTab, getNodeGovernanceInfo, renderGovernanceSection, selectAgent } = callbacks;
    const detailsEl = document.getElementById("details");
    if (!detailsEl)
        return;
    detailsEl.innerHTML = "";
    const h2 = document.createElement("h2");
    h2.textContent = `Step: ${data.label.replace(/^[\u2705\u26a0\ufe0f\u274c\u2014] /, "")}`;
    // Tabs - default based on mode (Node for author, Run for operator)
    const defaultTab = state.currentMode === "operator" ? "run" : "node";
    const tabs = document.createElement("div");
    tabs.className = "tabs";
    tabs.innerHTML = renderTabs([
        { id: "node", label: "Node", active: defaultTab === "node" },
        { id: "run", label: "Run", active: defaultTab === "run" },
        { id: "transcript", label: "Transcript" },
        { id: "selftest", label: "Selftest" }
    ]);
    // Fetch flow detail to get step agents and teaching notes
    let stepAgents = [];
    let stepDescription = "";
    let stepTeachingNote = "";
    if (data.flow) {
        try {
            const flowDetail = await Api.getFlowDetail(data.flow);
            const stepInfo = flowDetail.steps?.find((s) => s.id === data.step_id);
            if (stepInfo) {
                stepAgents = stepInfo.agents || [];
                // Use role as description if available
                stepDescription = stepInfo.role || data.role || "";
                // Get teaching note for teaching mode
                stepTeachingNote = stepInfo.teaching_note || "";
            }
        }
        catch (err) {
            console.error("Failed to fetch flow detail for step agents", err);
        }
    }
    // Create teaching note callout (shown when Teaching Mode is enabled)
    const teachingCallout = document.createElement("div");
    if (stepTeachingNote && getTeachingMode()) {
        teachingCallout.innerHTML = renderTeachingCallout(stepTeachingNote);
    }
    // Node tab content
    const nodeTab = document.createElement("div");
    nodeTab.className = `tab-content ${defaultTab === "node" ? "active" : ""}`;
    nodeTab.dataset.tab = "node";
    // Build the node tab HTML
    let nodeTabHtml = `
    <div class="author-only">
      <div class="kv-label">Step id</div>
      <div class="mono">${data.step_id || ""}</div>
      <div class="kv-label">Flow</div>
      <div class="mono">${data.flow || ""}</div>
    </div>
  `;
    // What this step does section
    nodeTabHtml += `
    <div class="kv-section">
      <div class="kv-label">What this step does</div>
      <div class="fs-text-body" style="line-height: 1.4;">${stepDescription || data.role || "\u2014"}</div>
    </div>
  `;
    // Agents section (placeholder - will add interactive links below)
    nodeTabHtml += `
    <div class="kv-section">
      <div class="kv-label">Agents</div>
      <div id="step-agents-list" class="fs-text-body" style="line-height: 1.8;"></div>
    </div>
  `;
    // Author-only sections: Spec, Edit step, Artifacts template
    nodeTabHtml += `
    <div class="author-only">
      <div class="kv-section">
        <div class="kv-label">Spec</div>
        <div class="fs-text-sm">
          <span class="mono">swarm/flows/flow-${data.flow}.md</span>
        </div>
      </div>
      <div class="kv-section">
        <div class="fs-text-sm fs-text-muted" style="margin-bottom: 4px;">Edit step:</div>
        <pre class="mono fs-text-xs" style="margin: 0;">$EDITOR swarm/config/flows/${data.flow}.yaml</pre>
      </div>
      <div class="kv-section">
        <div class="kv-label">Artifacts</div>
        <div class="mono fs-text-sm">swarm/runs/&lt;run&gt;/${data.flow}/${data.step_id || ""}/</div>
      </div>
    </div>
    <div class="operator-only">
      <div class="muted fs-text-sm" style="margin-top: 8px;">
        See <strong>Run</strong> tab for artifact status.
      </div>
    </div>
  `;
    nodeTab.innerHTML = nodeTabHtml;
    // Now add clickable agent links
    const agentsListEl = nodeTab.querySelector("#step-agents-list");
    if (agentsListEl) {
        if (stepAgents.length === 0) {
            agentsListEl.innerHTML = '<span class="muted">No agents assigned</span>';
        }
        else {
            stepAgents.forEach(agentKey => {
                const agentLink = document.createElement("div");
                agentLink.style.cursor = "pointer";
                agentLink.style.padding = "2px 0";
                agentLink.style.color = "#3b82f6";
                agentLink.innerHTML = `<span class="mono">${agentKey}</span>`;
                agentLink.title = `Click to view agent: ${agentKey}`;
                agentLink.addEventListener("click", async () => {
                    if (selectAgent) {
                        await selectAgent(agentKey, data.flow);
                    }
                });
                agentLink.addEventListener("mouseenter", () => {
                    agentLink.style.background = "#f3f4f6";
                    agentLink.style.textDecoration = "underline";
                });
                agentLink.addEventListener("mouseleave", () => {
                    agentLink.style.background = "transparent";
                    agentLink.style.textDecoration = "none";
                });
                agentsListEl.appendChild(agentLink);
            });
        }
    }
    // Run tab content
    const runTab = document.createElement("div");
    runTab.className = `tab-content ${defaultTab === "run" ? "active" : ""}`;
    runTab.dataset.tab = "run";
    // Get step status from cached run data
    const flowData = state.runStatus.flows?.[data.flow];
    const stepData = flowData?.steps?.[data.step_id || ""];
    const stepStatus = stepData?.status || "n/a";
    const artifacts = stepData?.artifacts || [];
    const statusClassMap = {
        complete: "status-complete",
        partial: "status-partial",
        missing: "status-missing",
        "n/a": "status-na"
    };
    const statusClass = statusClassMap[stepStatus] || "status-na";
    let artifactRows = "";
    if (artifacts.length === 0) {
        artifactRows = '<tr><td colspan="3" class="muted">No artifacts defined for this step</td></tr>';
    }
    else {
        artifacts.forEach(a => {
            const icon = a.status === "present" ? "\u2705" : "\u274c";
            const req = a.required ? "Required" : "Optional";
            artifactRows += `<tr>
        <td>${icon}</td>
        <td class="mono">${a.path}</td>
        <td class="muted">${req}</td>
      </tr>`;
        });
    }
    // Get step timing if available
    const stepTimingHtml = stepData?.timing ? renderStepTiming(stepData.timing) : '';
    runTab.innerHTML = `
    <div class="kv-label">Run</div>
    <div class="mono">${state.currentRunId || "None selected"}</div>
    <div class="kv-label">Step Status</div>
    <div class="${statusClass}" style="font-weight: 600;">${stepStatus.toUpperCase()}</div>
    <div class="fs-text-sm fs-text-muted" style="margin-top: 2px;">
      ${stepData?.required_present || 0}/${stepData?.required_total || 0} required,
      ${stepData?.optional_present || 0}/${stepData?.optional_total || 0} optional
    </div>
    ${stepData?.note ? `<div class="muted" style="margin-top: 4px; font-style: italic;">${stepData.note}</div>` : ""}
    <div class="kv-label" style="margin-top: 8px;">Execution</div>
    <div class="run-detail-badges" id="step-receipt-badges"></div>
    ${stepTimingHtml}
    <div class="kv-label">Artifacts</div>
    <table class="artifact-table">
      <thead>
        <tr><th></th><th>Path</th><th>Type</th></tr>
      </thead>
      <tbody>${artifactRows}</tbody>
    </table>
    <div class="kv-label" style="margin-top: 12px;">Artifact Directory</div>
    <div class="mono fs-text-sm">swarm/runs/${state.currentRunId || "<run>"}/${data.flow}/</div>
  `;
    // Load receipt badges asynchronously if we have run context
    if (state.currentRunId && data.flow && data.step_id) {
        const badgesContainer = runTab.querySelector("#step-receipt-badges");
        if (badgesContainer) {
            loadReceiptBadges(badgesContainer, state.currentRunId, data.flow, data.step_id);
        }
    }
    // Selftest tab content (never active by default)
    const selftestTab = document.createElement("div");
    selftestTab.className = "tab-content";
    selftestTab.dataset.tab = "selftest";
    if (renderSelftestTab) {
        await renderSelftestTab(selftestTab);
    }
    else {
        selftestTab.innerHTML = '<div class="muted">Selftest info not available</div>';
    }
    // Transcript tab content (lazy-loaded)
    const transcriptTab = document.createElement("div");
    transcriptTab.className = "tab-content";
    transcriptTab.dataset.tab = "transcript";
    transcriptTab.innerHTML = '<div class="muted">Select a step to view transcript</div>';
    detailsEl.appendChild(h2);
    // Add teaching callout if available and teaching mode is on
    if (teachingCallout.innerHTML) {
        detailsEl.appendChild(teachingCallout);
    }
    detailsEl.appendChild(tabs);
    detailsEl.appendChild(nodeTab);
    detailsEl.appendChild(runTab);
    detailsEl.appendChild(transcriptTab);
    detailsEl.appendChild(selftestTab);
    // Add quick commands section
    const quickCmds = createQuickCommands([
        "ls swarm/runs/" + (state.currentRunId || "<run>") + "/" + data.flow + "/",
        "cat swarm/flows/flow-" + data.flow + ".md",
        "code swarm/config/flows/" + data.flow + ".yaml"
    ]);
    quickCmds.classList.add("author-only");
    nodeTab.appendChild(quickCmds);
    // Tab switching
    tabs.querySelectorAll(".tab").forEach(tab => {
        tab.addEventListener("click", () => {
            tabs.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
            detailsEl.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
            tab.classList.add("active");
            const tabName = tab.dataset.tab;
            const content = detailsEl.querySelector(`.tab-content[data-tab="${tabName}"]`);
            if (content)
                content.classList.add("active");
            // Lazy load transcript when tab is clicked
            if (tabName === "transcript" && state.currentRunId && data.flow && data.step_id) {
                loadTranscript(transcriptTab, state.currentRunId, data.flow, data.step_id);
            }
        });
    });
    // Add governance section if there are issues
    if (getNodeGovernanceInfo && renderGovernanceSection) {
        const govInfo = getNodeGovernanceInfo(data);
        if (govInfo) {
            renderGovernanceSection(detailsEl, govInfo);
        }
    }
}
/**
 * Show agent details in the details panel
 */
export async function showAgentDetails(data, callbacks = {}) {
    const { setActiveFlow, showStepDetails: showStepDetailsFn, getNodeGovernanceInfo, renderGovernanceSection } = callbacks;
    const agentKey = data.agent_key || data.label;
    const detailsEl = document.getElementById("details");
    if (!detailsEl)
        return;
    detailsEl.innerHTML = "";
    const h2 = document.createElement("h2");
    h2.textContent = `Agent: ${agentKey}`;
    // What this agent does - use description if available, fall back to short_role
    const agentDescription = data.description || data.short_role || "";
    const descSection = document.createElement("div");
    descSection.className = "kv-section";
    descSection.innerHTML = `
    <div class="kv-label">What this agent does</div>
    <div class="fs-text-body" style="line-height: 1.4;">${agentDescription || "\u2014"}</div>
  `;
    const meta = document.createElement("div");
    meta.innerHTML = `
    <div class="author-only">
      <div class="kv-label">Agent key</div>
      <div class="mono">${agentKey}</div>
    </div>
    <div class="kv-label">Category</div>
    <div>${data.category || "unknown"}</div>
    <div class="kv-label">Model</div>
    <div class="mono">${data.model || "inherit"}</div>
  `;
    // Fetch agent usage
    const usageSection = document.createElement("div");
    usageSection.innerHTML = '<div class="kv-label">Used in</div><div class="muted">Loading...</div>';
    const authorOnly = document.createElement("div");
    authorOnly.className = "author-only";
    authorOnly.innerHTML = renderAgentLocationInfo(agentKey);
    const operatorOnly = document.createElement("div");
    operatorOnly.className = "operator-only";
    operatorOnly.innerHTML = renderAgentCategoryHint(data.category || "", data.model || "");
    detailsEl.appendChild(h2);
    detailsEl.appendChild(descSection);
    detailsEl.appendChild(meta);
    detailsEl.appendChild(usageSection);
    detailsEl.appendChild(authorOnly);
    detailsEl.appendChild(operatorOnly);
    // Add quick commands for agent
    const agentCmds = createQuickCommands([
        "cat swarm/config/agents/" + agentKey + ".yaml",
        "cat .claude/agents/" + agentKey + ".md",
        "code swarm/config/agents/" + agentKey + ".yaml"
    ]);
    agentCmds.classList.add("author-only");
    authorOnly.appendChild(agentCmds);
    // Add governance section if there are issues
    if (getNodeGovernanceInfo && renderGovernanceSection) {
        const govInfo = getNodeGovernanceInfo(data);
        if (govInfo) {
            renderGovernanceSection(detailsEl, govInfo);
        }
    }
    // Load and render agent usage asynchronously
    try {
        const usageData = await Api.getAgentUsage(agentKey);
        renderAgentUsage(usageSection, usageData.usage || [], {
            setActiveFlow,
            showStepDetails: showStepDetailsFn
        });
    }
    catch (err) {
        console.error("Failed to load agent usage", err);
        usageSection.innerHTML = '<div class="kv-label">Used in</div><div class="muted">Failed to load usage</div>';
    }
}
/**
 * Show artifact details in the details panel
 */
export function showArtifactDetails(data) {
    const detailsEl = document.getElementById("details");
    if (!detailsEl)
        return;
    detailsEl.innerHTML = "";
    const h2 = document.createElement("h2");
    h2.textContent = `Artifact: ${data.filename || data.label}`;
    const statusIconMap = {
        present: "\u2705",
        missing: "\u274c",
        unknown: "\u2014"
    };
    const statusIcon = statusIconMap[data.status || "unknown"] || "\u2014";
    const statusClassMap = {
        present: "status-complete",
        missing: "status-missing",
        unknown: "status-na"
    };
    const statusClass = statusClassMap[data.status || "unknown"] || "status-na";
    const meta = document.createElement("div");
    meta.innerHTML = `
    <div class="kv-label">Filename</div>
    <div class="mono">${data.filename || data.label}</div>
    <div class="kv-label">Type</div>
    <div>${data.required ? "Required" : "Optional"}</div>
    <div class="kv-label">Status</div>
    <div class="${statusClass}" style="font-weight: 600;">${statusIcon} ${(data.status || "unknown").toUpperCase()}</div>
    ${data.is_decision ? '<div class="kv-label">Decision Artifact</div><div style="color: #3b82f6; font-weight: 600;">Yes - This is the flow\'s decision artifact</div>' : ''}
    <div class="kv-label">Produced by Step</div>
    <div class="mono">${data.step_id || ""}</div>
    ${data.note ? '<div class="kv-label">Note</div><div class="muted" style="font-style: italic;">' + data.note + '</div>' : ''}
  `;
    const pathSection = document.createElement("div");
    pathSection.className = "author-only";
    const runPath = state.currentRunId ?
        (state.currentRunId.includes('health-check') || state.currentRunId.includes('example') ?
            `swarm/examples/${state.currentRunId}/${data.flow}/${data.filename || ""}` :
            `swarm/runs/${state.currentRunId}/${data.flow}/${data.filename || ""}`) :
        `swarm/runs/<run-id>/${data.flow}/${data.filename || ""}`;
    pathSection.innerHTML = `
    <div class="kv-label">Path</div>
    <div class="mono fs-text-sm">${runPath}</div>
    <div class="kv-label" style="margin-top: 12px;">Copy Command</div>
    <pre class="mono">cat ${runPath}</pre>
  `;
    const operatorOnly = document.createElement("div");
    operatorOnly.className = "operator-only";
    operatorOnly.innerHTML = renderArtifactProducerHint(data.step_id || "", data.flow || "");
    detailsEl.appendChild(h2);
    detailsEl.appendChild(meta);
    detailsEl.appendChild(pathSection);
    detailsEl.appendChild(operatorOnly);
}
// domain.js
/**
 * Flow Studio Domain Types
 *
 * CANONICAL SOURCE: src/domain.ts
 * The js/domain.d.ts file is GENERATED from this file ‚Äî do not edit it directly.
 * Run `make ts-build` to regenerate declaration files after editing this source.
 *
 * These types define the core data structures used throughout Flow Studio.
 * They serve as the contract between:
 * - Python backend (FastAPI endpoints)
 * - TypeScript frontend (browser modules)
 * - Tests and tooling
 */
/**
 * Query an element by its data-uiid attribute with type safety.
 * Returns null if not found.
 *
 * @example
 * const searchInput = qsByUiid("flow_studio.header.search.input");
 * if (searchInput) searchInput.focus();
 */
export function qsByUiid(id) {
    return document.querySelector(`[data-uiid="${id}"]`);
}
/**
 * Query all elements matching a data-uiid prefix.
 * Useful for dynamic IDs like "flow_studio.canvas.outline.step:*".
 *
 * @example
 * const steps = qsAllByUiidPrefix("flow_studio.canvas.outline.step:");
 */
export function qsAllByUiidPrefix(prefix) {
    return document.querySelectorAll(`[data-uiid^="${prefix}"]`);
}
/**
 * Check if the Flow Studio UI is ready for interaction.
 * @returns true if data-ui-ready="ready" on <html>
 */
export function isUIReady() {
    return document.documentElement.dataset.uiReady === "ready";
}
/**
 * Check if the Flow Studio UI failed to initialize.
 * @returns true if data-ui-ready="error" on <html>
 */
export function isUIError() {
    return document.documentElement.dataset.uiReady === "error";
}
/**
 * Get the current UI readiness state.
 * @returns "loading" | "ready" | "error"
 */
export function getUIReadyState() {
    return document.documentElement.dataset.uiReady || "loading";
}
/**
 * Wait for the Flow Studio UI to be ready.
 * Resolves when data-ui-ready="ready", rejects if "error" or timeout.
 *
 * @param timeoutMs - Maximum time to wait (default: 10000ms)
 * @returns Promise that resolves with the SDK when ready
 * @throws Error if UI fails to initialize or times out
 *
 * @example
 * // In test or automation code:
 * try {
 *   const sdk = await waitForUIReady();
 *   await sdk.setActiveFlow("build");
 * } catch (err) {
 *   console.error("Flow Studio failed to initialize", err);
 * }
 */
export async function waitForUIReady(timeoutMs = 10000) {
    const startTime = Date.now();
    return new Promise((resolve, reject) => {
        // Check immediately
        const state = getUIReadyState();
        if (state === "ready" && window.__flowStudio) {
            return resolve(window.__flowStudio);
        }
        if (state === "error") {
            return reject(new Error("Flow Studio initialization failed"));
        }
        // Set up polling
        const checkInterval = 100;
        const check = () => {
            const elapsed = Date.now() - startTime;
            const currentState = getUIReadyState();
            if (currentState === "ready" && window.__flowStudio) {
                resolve(window.__flowStudio);
                return;
            }
            if (currentState === "error") {
                reject(new Error("Flow Studio initialization failed"));
                return;
            }
            if (elapsed >= timeoutMs) {
                reject(new Error(`Flow Studio initialization timed out after ${timeoutMs}ms (state: ${currentState})`));
                return;
            }
            setTimeout(check, checkInterval);
        };
        setTimeout(check, checkInterval);
    });
}
/**
 * Safely get the Flow Studio SDK, returning null if not ready.
 * Use this for code that should gracefully handle the SDK being unavailable.
 *
 * @returns The SDK if ready, null otherwise
 *
 * @example
 * const sdk = getSDKIfReady();
 * if (sdk) {
 *   // Use SDK
 * } else {
 *   // Graceful fallback
 * }
 */
export function getSDKIfReady() {
    return isUIReady() ? window.__flowStudio || null : null;
}
// flow-studio-app.js
// swarm/tools/flow_studio_ui/src/flow-studio-app.ts
// Bootstrap shell for Flow Studio
//
// This file is the main entry point that:
// - Initializes and configures all modules
// - Handles mode/view toggling
// - Manages URL deep linking
// - Wires up event listeners
// ============================================================================
// Imports
// ============================================================================
// Core state and utilities
import { state } from "./state.js";
import { Api } from "./api.js";
import { qsByUiid, qsAllByUiidPrefix } from "./domain.js";
// Selection management
import { configure as configureSelection, selectNode, selectStep, selectAgent, clearSelection, getSelectionForUrl, parseStepParam } from "./selection.js";
// Details panel
import { showStepDetails as showStepDetailsBase, showAgentDetails as showAgentDetailsBase, showArtifactDetails, showEmptyState, renderRunTimeline, renderFlowTiming } from "./details.js";
// Graph
import { renderGraphCore } from "./graph.js";
// Runs/flows orchestration
import { configure as configureRunsFlows, loadRuns, loadRunStatus, loadFlows, setActiveFlow, setCompareRun, updateCompareSelector, refreshCurrentFlow, clearWisdomCache } from "./runs_flows.js";
// Search
import { configure as configureSearch, initSearchHandlers, } from "./search.js";
// Keyboard shortcuts
import { configure as configureShortcuts, initKeyboardShortcuts, initShortcutsModal, toggleShortcutsModal } from "./shortcuts.js";
// Governance UI
import { loadGovernanceStatus, updateFlowListGovernance, toggleGovernanceOverlay, getNodeGovernanceInfo, renderGovernanceSection, showGovernanceDetails } from "./governance_ui.js";
// Tours
import { configure as configureTours, loadTours, initTourHandlers, startTour } from "./tours.js";
// Selftest modal
import { initSelftestModal, toggleSelftestModal, renderSelftestTab } from "./selftest_ui.js";
// Teaching mode
import { initTeachingMode, initToggleButtonHandler as initTeachingModeToggle, getTeachingMode, setTeachingMode } from "./teaching_mode.js";
// Context budget settings
import { initContextBudgetSettings, initContextBudgetModalHandlers, getContextBudgets, setContextBudgets, openContextBudgetModal } from "./context_budget_settings.js";
// Run history panel
import { configure as configureRunHistory, initRunHistory, setSelectedRunId as setRunHistorySelectedRunId } from "./run_history.js";
// Run detail modal
import { configure as configureRunDetailModal, showRunDetailModal } from "./run_detail_modal.js";
// Run control panel
import { configure as configureRunControl, initRunControl, setActiveRun as setRunControlActiveRun, clearActiveRun as clearRunControlActiveRun } from "./run_control.js";
// Graph semantic companion
import { renderFlowOutline, getCurrentGraphState } from "./graph_outline.js";
// Layout spec for SDK
import { screens as layoutScreens, getScreenById as getLayoutScreenByIdImpl, getAllKnownUIIDs as getAllKnownUIIDsImpl } from "./layout_spec.js";
// Boundary Review - flow completion summaries
import { BoundaryReview, createBoundaryReview, extractBoundaryReviewData, } from "./components/BoundaryReview.js";
// Inventory Counts - marker statistics
import { InventoryCounts } from "./components/InventoryCounts.js";
// ============================================================================
// Details Wrappers
// ============================================================================
// Wrapper functions for details module - provide callbacks from this module
async function showStepDetails(data) {
    return showStepDetailsBase(data, {
        renderSelftestTab,
        getNodeGovernanceInfo,
        renderGovernanceSection,
        selectAgent
    });
}
async function showAgentDetails(data) {
    return showAgentDetailsBase(data, {
        setActiveFlow,
        showStepDetails,
        getNodeGovernanceInfo,
        renderGovernanceSection
    });
}
// ============================================================================
// Profile Status
// ============================================================================
/**
 * Load and display the current profile status.
 */
async function loadProfileStatus() {
    const profileText = document.getElementById("profile-text");
    const profileBadge = document.getElementById("profile-badge");
    if (!profileText || !profileBadge)
        return;
    // Helper to reset modifier classes
    const resetModifiers = () => {
        profileBadge.classList.remove("fs-profile-badge--none", "fs-profile-badge--error");
    };
    try {
        const data = await Api.getCurrentProfile();
        if (data.profile) {
            profileText.textContent = `Profile: ${data.profile.label || data.profile.id}`;
            profileBadge.title = `Profile: ${data.profile.id}\nLoaded: ${data.profile.loaded_at || "unknown"}\nBranch: ${data.profile.source_branch || "unknown"}`;
            resetModifiers(); // Default state (light blue via base class)
        }
        else {
            profileText.textContent = "Profile: (none)";
            profileBadge.title = data.message || "No profile loaded";
            resetModifiers();
            profileBadge.classList.add("fs-profile-badge--none");
        }
    }
    catch (err) {
        console.error("Failed to load profile status", err);
        profileText.textContent = "Profile: (unavailable)";
        profileBadge.title = "Profile status unavailable";
        resetModifiers();
        profileBadge.classList.add("fs-profile-badge--error");
    }
}
// ============================================================================
// Backend Loading
// ============================================================================
/** Track the currently selected backend ID */
let selectedBackendId = "claude-harness";
/** Global inventory counts component instance */
let inventoryCountsComponent = null;
/** Debounce timer for inventory counts updates */
let inventoryCountsDebounceTimer = null;
/** Debounce delay for inventory counts updates (ms) */
const INVENTORY_COUNTS_DEBOUNCE_MS = 250;
// ============================================================================
// Inventory Counts
// ============================================================================
/**
 * Initialize and load the inventory counts component.
 */
function initInventoryCounts() {
    const container = document.getElementById("inventory-counts-container");
    if (!container)
        return;
    // Create component instance if not already created
    if (!inventoryCountsComponent) {
        inventoryCountsComponent = new InventoryCounts({
            container,
            onTypeClick: (markerType) => {
                // Could navigate to filtered facts view in future
                console.log("Clicked marker type:", markerType);
            },
            onFlowClick: async (flowKey) => {
                // Navigate to the flow
                await setActiveFlow(flowKey, true);
            },
            onStepClick: async (flowKey, stepId) => {
                // Navigate to the step
                await setActiveFlow(flowKey, true);
                setTimeout(() => {
                    selectStep(flowKey, stepId, { fitGraph: true });
                }, 300);
            },
        });
    }
    // Load data if we have a run selected
    if (state.currentRunId) {
        inventoryCountsComponent.load(state.currentRunId).catch((err) => {
            console.warn("Failed to load inventory counts:", err);
        });
    }
    else {
        inventoryCountsComponent.clear();
    }
}
/**
 * Update inventory counts when run changes.
 * Debounced to prevent excessive API calls under bursty SSE events.
 */
function updateInventoryCounts(runId) {
    // Cancel any pending debounced update
    if (inventoryCountsDebounceTimer !== null) {
        clearTimeout(inventoryCountsDebounceTimer);
        inventoryCountsDebounceTimer = null;
    }
    inventoryCountsDebounceTimer = setTimeout(() => {
        inventoryCountsDebounceTimer = null;
        if (!inventoryCountsComponent) {
            initInventoryCounts();
        }
        if (runId && inventoryCountsComponent) {
            inventoryCountsComponent.load(runId).catch((err) => {
                console.warn("Failed to load inventory counts:", err);
            });
        }
        else if (inventoryCountsComponent) {
            inventoryCountsComponent.clear();
        }
    }, INVENTORY_COUNTS_DEBOUNCE_MS);
}
/**
 * Update inventory counts selected step.
 */
function updateInventoryCountsSelectedStep(flowKey, stepId) {
    if (inventoryCountsComponent) {
        inventoryCountsComponent.setSelectedStep(flowKey, stepId);
    }
}
/**
 * Load and display available backends in the selector.
 */
async function loadBackends() {
    const selector = document.getElementById("backend-selector");
    if (!selector)
        return;
    try {
        const data = await Api.getBackends();
        const backends = data.backends || [];
        selector.innerHTML = "";
        if (!backends.length) {
            selector.innerHTML = '<option value="claude-harness">Claude CLI</option>';
            return;
        }
        for (const backend of backends) {
            const opt = document.createElement("option");
            opt.value = backend.id;
            opt.textContent = backend.label;
            // Add tooltip with capability info
            const caps = [];
            if (backend.supports_streaming)
                caps.push("streaming");
            if (backend.supports_events)
                caps.push("events");
            if (backend.supports_cancel)
                caps.push("cancel");
            if (backend.supports_replay)
                caps.push("replay");
            opt.title = `Supports: ${caps.join(", ") || "basic execution"}`;
            selector.appendChild(opt);
        }
        // Restore previous selection if it still exists
        const prevSelected = selector.querySelector(`option[value="${selectedBackendId}"]`);
        if (prevSelected) {
            selector.value = selectedBackendId;
        }
        else if (backends.length > 0) {
            selectedBackendId = backends[0].id;
        }
    }
    catch (err) {
        console.error("Failed to load backends", err);
        selector.innerHTML = '<option value="claude-harness">Claude CLI</option>';
    }
}
// ============================================================================
// Mode and View Management
// ============================================================================
/**
 * Set the application mode (author vs operator).
 */
function setMode(mode) {
    state.currentMode = mode;
    document.body.classList.remove("mode-author", "mode-operator");
    document.body.classList.add("mode-" + mode);
    // Update toggle buttons
    const authorBtn = document.getElementById("mode-author");
    const operatorBtn = document.getElementById("mode-operator");
    if (authorBtn)
        authorBtn.classList.toggle("active", mode === "author");
    if (operatorBtn)
        operatorBtn.classList.toggle("active", mode === "operator");
    // Update URL
    updateURL();
    // Refresh timeline display when switching to operator mode
    if (mode === "operator" && state.currentRunId && state.currentFlowKey) {
        const timelineContainer = document.getElementById("flow-overview-timeline");
        if (timelineContainer) {
            renderRunTimeline(timelineContainer);
            renderFlowTiming(timelineContainer, state.currentFlowKey);
        }
    }
}
/**
 * Set the view mode (agents vs artifacts).
 */
async function setViewMode(viewMode) {
    state.currentViewMode = viewMode;
    // Update toggle buttons
    const agentsBtn = document.getElementById("view-agents");
    const artifactsBtn = document.getElementById("view-artifacts");
    if (agentsBtn)
        agentsBtn.classList.toggle("active", viewMode === "agents");
    if (artifactsBtn)
        artifactsBtn.classList.toggle("active", viewMode === "artifacts");
    // Update URL
    updateURL();
    // Reload graph with new view mode if we have a flow selected
    if (state.currentFlowKey) {
        await refreshCurrentFlow();
    }
}
/**
 * Update URL to reflect current state (for shareable deep links).
 */
function updateURL() {
    const url = new URL(window.location.href);
    // Set mode
    if (state.currentMode && state.currentMode !== "author") {
        url.searchParams.set("mode", state.currentMode);
    }
    else {
        url.searchParams.delete("mode");
    }
    // Set run
    if (state.currentRunId) {
        url.searchParams.set("run", state.currentRunId);
    }
    else {
        url.searchParams.delete("run");
    }
    // Set flow
    if (state.currentFlowKey) {
        url.searchParams.set("flow", state.currentFlowKey);
    }
    else {
        url.searchParams.delete("flow");
    }
    // Set view mode (only if not default)
    if (state.currentViewMode && state.currentViewMode !== "agents") {
        url.searchParams.set("view", state.currentViewMode);
    }
    else {
        url.searchParams.delete("view");
    }
    // Set selection (step or agent)
    const selection = getSelectionForUrl();
    if (selection.step) {
        url.searchParams.set("step", selection.step);
        url.searchParams.delete("agent");
    }
    else if (selection.agent) {
        url.searchParams.set("agent", selection.agent);
        url.searchParams.delete("step");
    }
    else {
        url.searchParams.delete("step");
        url.searchParams.delete("agent");
    }
    window.history.pushState({ flowStudio: true }, "", url.toString());
}
/**
 * Get URL params for deep linking.
 */
function getURLParams() {
    const url = new URL(window.location.href);
    return {
        mode: url.searchParams.get("mode"),
        run: url.searchParams.get("run"),
        flow: url.searchParams.get("flow"),
        step: url.searchParams.get("step"),
        agent: url.searchParams.get("agent"),
        view: url.searchParams.get("view"),
        tour: url.searchParams.get("tour"),
        tab: url.searchParams.get("tab")
    };
}
// Cached URL params from initial load
let initialURLParams = null;
/**
 * Initialize mode from URL or default.
 */
function initMode() {
    initialURLParams = getURLParams();
    const mode = initialURLParams.mode;
    if (mode === "operator") {
        setMode("operator");
    }
    else {
        setMode("author");
    }
    // Initialize view mode from URL
    const view = initialURLParams.view;
    if (view === "artifacts") {
        state.currentViewMode = "artifacts";
        const agentsBtn = document.getElementById("view-agents");
        const artifactsBtn = document.getElementById("view-artifacts");
        if (agentsBtn)
            agentsBtn.classList.remove("active");
        if (artifactsBtn)
            artifactsBtn.classList.add("active");
    }
}
/**
 * Apply deep link params after data is loaded.
 */
async function applyDeepLinkParams() {
    if (!initialURLParams)
        return;
    const { run, flow, step, agent, tour, tab } = initialURLParams;
    // Apply run selection if specified
    if (run) {
        const runSelector = document.getElementById("run-selector");
        if (runSelector) {
            const optionExists = Array.from(runSelector.options).some(opt => opt.value === run);
            if (optionExists) {
                state.currentRunId = run;
                runSelector.value = run;
                updateCompareSelector();
                await loadRunStatus();
                // Sync run history selection (handles race where initRunHistory finishes after deep link)
                setRunHistorySelectedRunId(run);
            }
        }
    }
    // Apply flow selection if specified
    if (flow) {
        const flowExists = document.querySelector(`.flow-item[data-key="${flow}"]`);
        if (flowExists) {
            await setActiveFlow(flow, true);
        }
    }
    // Apply step selection if specified (uses unified selection)
    if (step && flow) {
        setTimeout(async () => {
            await selectStep(flow, step, { skipUrlUpdate: true, fitGraph: true });
        }, 300);
    }
    // Apply agent selection if specified (uses unified selection)
    else if (agent && flow) {
        setTimeout(async () => {
            await selectAgent(agent, flow, { skipUrlUpdate: true, fitGraph: true });
        }, 300);
    }
    // Apply tab selection if specified
    if (tab) {
        setTimeout(() => {
            const tabEl = document.querySelector(`.tab[data-tab="${tab}"]`);
            if (tabEl) {
                tabEl.click();
            }
        }, 400);
    }
    // Start tour if specified
    if (tour) {
        setTimeout(() => {
            startTour(tour);
        }, 500);
    }
}
/**
 * Handle browser back/forward navigation.
 */
function handlePopState(event) {
    // Only handle our own history entries
    if (!event.state?.flowStudio) {
        return;
    }
    const params = getURLParams();
    // Apply mode
    if (params.mode === "operator") {
        setMode("operator");
    }
    else {
        setMode("author");
    }
    // Apply view mode
    if (params.view === "artifacts") {
        setViewMode("artifacts");
    }
    else if (state.currentViewMode !== "agents") {
        setViewMode("agents");
    }
    // Apply flow and selection
    if (params.flow) {
        setActiveFlow(params.flow, true).then(() => {
            if (params.step) {
                selectStep(params.flow, params.step, { skipUrlUpdate: true, fitGraph: true });
            }
            else if (params.agent) {
                selectAgent(params.agent, params.flow, { skipUrlUpdate: true, fitGraph: true });
            }
        });
    }
}
// ============================================================================
// Graph and Details Rendering
// ============================================================================
/**
 * Handle node click from graph.
 * Uses the unified selection module for consistent behavior.
 */
function handleNodeClick(data) {
    // Build node ID from data
    let nodeId;
    if (data.type === "step") {
        nodeId = data.id || `step:${data.flow}:${data.step_id}`;
    }
    else if (data.type === "agent") {
        nodeId = data.id || `agent:${data.agent_key}`;
    }
    else if (data.type === "artifact") {
        nodeId = data.id || `artifact:${data.flow}:${data.label}`;
    }
    else {
        return;
    }
    // Use unified selection - graph click doesn't need flow switch or fit
    selectNode(nodeId, {
        nodeData: data,
        fitGraph: false,
        skipUrlUpdate: false
    });
}
/**
 * Show flow details in the details panel.
 */
function showFlowDetails(detail) {
    const flow = detail.flow || { key: detail.key, title: detail.title, description: detail.description };
    const steps = detail.steps || detail.steps || [];
    const detailsEl = document.getElementById("details");
    if (!detailsEl)
        return;
    detailsEl.innerHTML = "";
    const h2 = document.createElement("h2");
    h2.textContent = flow.title || flow.key || "Flow";
    const desc = document.createElement("div");
    desc.className = "muted";
    desc.textContent = flow.description || "";
    const meta = document.createElement("div");
    meta.innerHTML = `
    <div class="kv-label">Flow key</div>
    <div class="mono">${flow.key || ""}</div>
    <div class="kv-label">Steps</div>
    <div>${steps.length} step(s)</div>
  `;
    const hint = document.createElement("div");
    hint.className = "welcome-panel author-only";
    hint.innerHTML = `
    <div class="welcome-section" style="margin-bottom: 12px;">
      <div style="font-size: 11px; color: #6b7280; margin-bottom: 8px;">
        Click a node for details. Press <kbd class="shortcut-key">?</kbd> for shortcuts.
      </div>
      <div style="font-size: 11px; color: #9ca3af;">
        Artifacts: <code class="mono" style="font-size: 10px;">swarm/runs/&lt;run&gt;/${flow.key || "&lt;flow&gt;"}/</code>
      </div>
    </div>
    <div class="welcome-section">
      <div style="font-size: 11px; color: #6b7280; margin-bottom: 4px;">Edit flow:</div>
      <pre class="mono" style="font-size: 10px; margin: 0;">$EDITOR swarm/config/flows/${flow.key || "&lt;key&gt;"}.yaml</pre>
    </div>
  `;
    const operatorHint = document.createElement("div");
    operatorHint.className = "operator-only";
    operatorHint.id = "flow-overview-timeline";
    if (state.currentMode === "operator" && state.currentRunId) {
        operatorHint.innerHTML = '<div class="muted">Loading timeline...</div>';
    }
    else {
        operatorHint.innerHTML = `
      <div class="muted" style="margin-top: 8px; font-size: 11px;">
        Select a step for status and artifacts.
      </div>
    `;
    }
    detailsEl.appendChild(h2);
    detailsEl.appendChild(desc);
    detailsEl.appendChild(meta);
    detailsEl.appendChild(hint);
    detailsEl.appendChild(operatorHint);
    // Load timeline in operator mode after DOM is ready
    if (state.currentMode === "operator" && state.currentRunId && flow.key) {
        renderRunTimeline(operatorHint);
        renderFlowTiming(operatorHint, flow.key);
    }
}
/**
 * Render graph and show flow details.
 */
function renderGraph(graph, detail) {
    renderGraphCore(graph, { onNodeClick: handleNodeClick });
    showFlowDetails(detail);
    // Update semantic outline after graph render
    renderFlowOutline();
}
// ============================================================================
// Config Reload
// ============================================================================
/**
 * Reload configuration from server.
 */
async function reloadConfig() {
    const btn = document.getElementById("reload-btn");
    if (!btn)
        return;
    btn.disabled = true;
    btn.textContent = "Reloading\u2026";
    try {
        await Api.reloadConfig();
        await loadFlows();
        btn.textContent = "Reload";
    }
    catch (err) {
        console.error("Failed to reload config", err);
        const listEl = document.getElementById("flow-list");
        if (listEl)
            listEl.textContent = "Reload failed: " + err.message;
        btn.textContent = "Reload";
    }
    finally {
        btn.disabled = false;
    }
}
// ============================================================================
// UI Ready Handshake
// ============================================================================
/**
 * Mark the UI as ready for interaction.
 */
function markUiReady() {
    document.documentElement.dataset.uiReady = "ready";
}
/**
 * Mark the UI as loading (initialization in progress).
 */
function markUiLoading() {
    document.documentElement.dataset.uiReady = "loading";
}
/**
 * Mark the UI as failed (initialization error).
 */
function markUiError() {
    document.documentElement.dataset.uiReady = "error";
}
// ============================================================================
// Initialization
// ============================================================================
window.addEventListener("load", async () => {
    // Mark UI as loading during initialization
    markUiLoading();
    // Performance measurement (opt-in via ?debugPerf=1)
    const debugPerf = new URL(window.location.href).searchParams.has("debugPerf");
    const t0 = debugPerf ? performance.now() : 0;
    try {
        // Initialize mode from URL
        initMode();
        // Configure runs/flows module with callbacks
        configureRunsFlows({
            onFlowDetails: showFlowDetails,
            onNodeClick: handleNodeClick,
            onURLUpdate: updateURL,
            updateFlowListGovernance: updateFlowListGovernance
        });
        // Configure search module
        configureSearch({
            setActiveFlow: setActiveFlow
        });
        // Configure shortcuts module
        configureShortcuts({
            setActiveFlow: setActiveFlow,
            showStepDetails: showStepDetails,
            toggleSelftestModal: toggleSelftestModal
        });
        // Configure tours module
        configureTours({
            setActiveFlow: setActiveFlow
        });
        // Configure selection module (unified selection for all surfaces)
        configureSelection({
            setActiveFlow: setActiveFlow,
            showStepDetails: showStepDetails,
            showAgentDetails: showAgentDetails,
            showArtifactDetails: showArtifactDetails,
            showEmptyState: showEmptyState,
            updateURL: updateURL,
            onStepSelected: updateInventoryCountsSelectedStep
        });
        // Initialize search handlers
        initSearchHandlers();
        // Handle browser back/forward navigation
        window.addEventListener("popstate", handlePopState);
        // Initialize keyboard shortcuts
        initKeyboardShortcuts();
        initShortcutsModal();
        initSelftestModal();
        // Initialize teaching mode
        initTeachingMode();
        initTeachingModeToggle();
        // Initialize context budget settings
        initContextBudgetSettings();
        initContextBudgetModalHandlers();
        // Mode toggle handlers
        const authorBtn = document.getElementById("mode-author");
        const operatorBtn = document.getElementById("mode-operator");
        if (authorBtn)
            authorBtn.addEventListener("click", () => setMode("author"));
        if (operatorBtn)
            operatorBtn.addEventListener("click", () => setMode("operator"));
        // View toggle handlers
        const viewAgentsBtn = document.getElementById("view-agents");
        const viewArtifactsBtn = document.getElementById("view-artifacts");
        if (viewAgentsBtn)
            viewAgentsBtn.addEventListener("click", () => setViewMode("agents"));
        if (viewArtifactsBtn)
            viewArtifactsBtn.addEventListener("click", () => setViewMode("artifacts"));
        // Reload button handler
        const btn = document.getElementById("reload-btn");
        if (btn) {
            btn.addEventListener("click", reloadConfig);
        }
        // Help button handler
        const helpBtn = document.getElementById("help-btn");
        if (helpBtn) {
            helpBtn.addEventListener("click", () => toggleShortcutsModal(true));
        }
        // Governance badge click handler
        const govBadge = document.getElementById("governance-badge");
        if (govBadge) {
            govBadge.addEventListener("click", showGovernanceDetails);
        }
        // Governance overlay toggle handler
        const govOverlayCheckbox = document.getElementById("governance-overlay-checkbox");
        if (govOverlayCheckbox) {
            govOverlayCheckbox.addEventListener("change", (e) => {
                toggleGovernanceOverlay(e.target.checked);
            });
        }
        // Run selector change handler
        const runSelector = document.getElementById("run-selector");
        if (runSelector) {
            runSelector.addEventListener("change", async (e) => {
                const runId = e.target.value;
                state.currentRunId = runId;
                clearWisdomCache(); // Clear wisdom cache when run changes
                updateCompareSelector();
                await loadRunStatus();
                // Update inventory counts for new run
                updateInventoryCounts(runId || null);
                // Sync run history selection
                setRunHistorySelectedRunId(runId);
                // Sync run control panel to monitor this run
                if (runId) {
                    void setRunControlActiveRun(runId);
                }
                else {
                    clearRunControlActiveRun();
                }
                // Refresh artifact view if in artifact mode
                if (state.currentViewMode === "artifacts" && state.currentFlowKey) {
                    setActiveFlow(state.currentFlowKey, true);
                }
            });
        }
        // Compare selector change handler (operator mode)
        const compareSelector = document.getElementById("compare-selector");
        if (compareSelector) {
            compareSelector.addEventListener("change", async (e) => {
                await setCompareRun(e.target.value);
            });
        }
        // Backend selector change handler
        const backendSelector = document.getElementById("backend-selector");
        if (backendSelector) {
            backendSelector.addEventListener("change", (e) => {
                selectedBackendId = e.target.value;
            });
        }
        // ========================================================================
        // CRITICAL PATH: Only await what's needed for initial render
        // Non-critical loads run in background to reduce time-to-interactive
        // ========================================================================
        // Phase 1: Start background loads for non-critical UI elements
        // These populate header badges and selectors but don't block core UI
        // Error handling is centralized in the .then() below
        const backgroundLoadNames = ["profile status", "backends", "governance status", "tours"];
        const backgroundLoads = Promise.allSettled([
            loadProfileStatus(),
            loadBackends(),
            loadGovernanceStatus(),
            loadTours()
        ]);
        // Phase 2: Critical path - runs and flows are needed for main UI
        // Load runs first (populates run selector), then flows (renders graph)
        try {
            await loadRuns();
        }
        catch (err) {
            console.error("Failed to load runs", err);
        }
        try {
            await loadFlows();
        }
        catch (err) {
            const listEl = document.getElementById("flow-list");
            if (listEl)
                listEl.textContent = "Failed to load flows: " + err.message;
        }
        // Initialize tour system (sync handlers only)
        initTourHandlers();
        // Log any background load failures (non-blocking)
        backgroundLoads.then(results => {
            // Guard against ordering drift if loads/names get out of sync
            if (results.length !== backgroundLoadNames.length) {
                console.warn("Background load names list out of sync with loads", {
                    results: results.length,
                    names: backgroundLoadNames.length
                });
            }
            results.forEach((result, idx) => {
                if (result.status === "rejected") {
                    console.error(`Failed to load ${backgroundLoadNames[idx]}:`, result.reason);
                }
            });
        });
        // Configure and initialize run history panel
        configureRunHistory({
            onRunSelect: async (runId) => {
                // Update the main run selector to match
                const runSelector = document.getElementById("run-selector");
                if (runSelector) {
                    runSelector.value = runId;
                }
                state.currentRunId = runId;
                updateCompareSelector();
                await loadRunStatus();
                // Refresh artifact view if in artifact mode
                if (state.currentViewMode === "artifacts" && state.currentFlowKey) {
                    await setActiveFlow(state.currentFlowKey, true);
                }
            },
            onRunDetailOpen: async (runId) => {
                await showRunDetailModal(runId);
            }
        });
        // Configure run detail modal
        configureRunDetailModal({
            onClose: () => {
                // Optional: any cleanup after modal closes
            },
            onRerun: async (_runId) => {
                // Re-run functionality - for now just log
                // Future: call Api.startRun() with appropriate params
            }
        });
        // Initialize boundary review component for flow completion summaries
        const boundaryReview = createBoundaryReview({
            onApprove: (flowKey) => {
                console.log(`[BoundaryReview] Approved flow: ${flowKey}`);
                // Continue to next flow automatically if applicable
            },
            onPause: (flowKey) => {
                console.log(`[BoundaryReview] Paused for review: ${flowKey}`);
                // User wants to pause and review - no automatic continuation
            },
            onClose: () => {
                // Refresh status after review
                void loadRunStatus();
            }
        });
        // Helper to show boundary review for a completed flow
        async function showBoundaryReviewPanel(flowKey, runId) {
            try {
                // Fetch boundary review data from the dedicated API endpoint
                const boundary = await Api.getBoundaryReview(runId, { scope: "flow", flowKey });
                // Derive status from verification results
                let status = "UNKNOWN";
                if (boundary.verification_failed > 0) {
                    status = "UNVERIFIED";
                }
                else if (boundary.verification_passed > 0) {
                    status = "VERIFIED";
                }
                else if (boundary.assumptions_count === 0 && boundary.decisions_count === 0) {
                    // No data available - check if there's anything at all
                    status = "BLOCKED";
                }
                // Get artifacts from RunSummary for display (boundary API doesn't include them)
                const artifacts = [];
                try {
                    const summary = await Api.getRunSummary(runId);
                    const flowStatus = summary?.flows?.[flowKey];
                    if (flowStatus?.steps) {
                        for (const step of Object.values(flowStatus.steps)) {
                            if (step.artifacts) {
                                artifacts.push(...step.artifacts);
                            }
                        }
                    }
                }
                catch {
                    // Artifacts are optional for display, continue without them
                    console.warn("[BoundaryReview] Could not load artifacts from run summary");
                }
                // Get flow title from flows list
                const flowsResponse = await Api.getFlows();
                const flowInfo = flowsResponse.flows.find(f => f.key === flowKey);
                const flowTitle = flowInfo?.title || flowKey;
                // Extract blocking issues and warnings from verifications
                const blockingIssues = [];
                const warnings = [];
                for (const v of boundary.verifications) {
                    if (!v.verified && v.issues.length > 0) {
                        blockingIssues.push(...v.issues);
                    }
                }
                // Add uncertainty notes as warnings
                if (boundary.uncertainty_notes && boundary.uncertainty_notes.length > 0) {
                    warnings.push(...boundary.uncertainty_notes);
                }
                // Create review data using endpoint response fields
                const reviewData = extractBoundaryReviewData(flowKey, flowTitle, status, artifacts, {
                    assumptionsCount: boundary.assumptions_count,
                    decisionsCount: boundary.decisions_count,
                    confidenceScore: boundary.confidence_score,
                    blockingIssues: blockingIssues.length > 0 ? blockingIssues : undefined,
                    warnings: warnings.length > 0 ? warnings : undefined
                });
                // Show the boundary review panel
                return await boundaryReview.show(reviewData);
            }
            catch (err) {
                console.error("[BoundaryReview] Error loading review data:", err);
                return "cancel";
            }
        }
        // Configure and initialize run control panel
        configureRunControl({
            onRunStart: (runId) => {
                // Update run selector when a new run starts
                const runSelector = document.getElementById("run-selector");
                if (runSelector) {
                    // Add new run option if not present
                    const existingOption = runSelector.querySelector(`option[value="${runId}"]`);
                    if (!existingOption) {
                        const newOption = document.createElement("option");
                        newOption.value = runId;
                        newOption.textContent = runId;
                        runSelector.insertBefore(newOption, runSelector.firstChild);
                    }
                    runSelector.value = runId;
                }
                state.currentRunId = runId;
            },
            onStateChange: (_runState, _runId) => {
                // Refresh status when run state changes
                void loadRunStatus();
            },
            onRunComplete: (runId) => {
                // Reload run history to show completed run
                void initRunHistory().then(() => {
                    setRunHistorySelectedRunId(runId);
                });
                // Show boundary review for the completed flow if applicable
                if (state.currentFlowKey) {
                    void showBoundaryReviewPanel(state.currentFlowKey, runId);
                }
            },
            onRunFailed: (_runId, _error) => {
                // Refresh status to show failure
                void loadRunStatus();
            },
            onRunStopped: (runId) => {
                // Refresh status to show stopped state
                // Stopped runs remain selectable for review (no reset)
                void loadRunStatus();
                // Update run history to reflect stopped state
                void initRunHistory().then(() => {
                    setRunHistorySelectedRunId(runId);
                });
            },
            onSelectRun: async (runId) => {
                // Update the main run selector to match
                const runSelector = document.getElementById("run-selector");
                if (runSelector) {
                    runSelector.value = runId;
                }
                state.currentRunId = runId;
                updateCompareSelector();
                await loadRunStatus();
                setRunHistorySelectedRunId(runId);
            },
            onRunEvent: (event, runId) => {
                // Only process events for the currently viewed run
                if (runId !== state.currentRunId)
                    return;
                switch (event.type) {
                    case "step_start":
                        // Update selected step highlight when a new step starts
                        if (event.flowKey && event.stepId && state.currentFlowKey === event.flowKey) {
                            selectStep(event.flowKey, event.stepId, { fitGraph: false, skipUrlUpdate: true });
                        }
                        break;
                    case "step_end":
                    case "facts_updated":
                        // Refresh InventoryCounts when step completes or facts are updated
                        if (runId) {
                            updateInventoryCounts(runId);
                        }
                        break;
                }
            }
        });
        initRunControl();
        // Initialize run history in background (non-blocking)
        // This prevents run history loading from blocking the main UI ready state
        initRunHistory()
            .then(() => {
            // Sync run history selection with current run
            if (state.currentRunId) {
                setRunHistorySelectedRunId(state.currentRunId);
            }
        })
            .catch((err) => {
            console.error("Failed to initialize run history", err);
        });
        // Initialize legend toggle with sessionStorage persistence
        // Legend defaults to COLLAPSED on first load for cleaner first impression.
        // User preference persists within session via sessionStorage.
        const LEGEND_STORAGE_KEY = "flowstudio.legend.collapsed";
        function getLegendCollapsed() {
            if (typeof window === "undefined")
                return true;
            try {
                const raw = window.sessionStorage.getItem(LEGEND_STORAGE_KEY);
                // If key is missing (null), default to collapsed for cleaner first impression
                if (raw === null)
                    return true;
                return raw === "true";
            }
            catch {
                // sessionStorage blocked or unavailable - default to collapsed
                return true;
            }
        }
        function setLegendCollapsed(collapsed) {
            if (typeof window === "undefined")
                return;
            try {
                window.sessionStorage.setItem(LEGEND_STORAGE_KEY, collapsed ? "true" : "false");
            }
            catch {
                // Ignore - UX still works, just loses persistence
            }
        }
        const legendToggle = document.getElementById("legend-toggle");
        const legend = document.getElementById("legend");
        if (legendToggle && legend) {
            // Restore collapsed state from sessionStorage
            const isCollapsed = getLegendCollapsed();
            if (isCollapsed) {
                legend.classList.add("collapsed");
                legendToggle.setAttribute("aria-expanded", "false");
            }
            else {
                legend.classList.remove("collapsed");
                legendToggle.setAttribute("aria-expanded", "true");
            }
            legendToggle.addEventListener("click", () => {
                legend.classList.toggle("collapsed");
                const nowCollapsed = legend.classList.contains("collapsed");
                setLegendCollapsed(nowCollapsed);
                // Keep aria-expanded in sync with legend state
                legendToggle.setAttribute("aria-expanded", nowCollapsed ? "false" : "true");
            });
        }
        // Apply deep link params after all data is loaded
        try {
            await applyDeepLinkParams();
        }
        catch (err) {
            console.error("Failed to apply deep link params", err);
        }
        // Initialize inventory counts component (operator mode feature)
        initInventoryCounts();
        // Signal that UI is fully initialized and ready for interaction
        if (debugPerf) {
            // Performance timing logged in development mode
        }
        markUiReady();
        // Export SDK for agents and automation
        window.__flowStudio = {
            getState: () => ({
                currentFlowKey: state.currentFlowKey,
                currentRunId: state.currentRunId,
                currentMode: state.currentMode,
                currentViewMode: state.currentViewMode,
                selectedNodeId: state.selectedNodeId,
                selectedNodeType: state.selectedNodeType
            }),
            getGraphState: getCurrentGraphState,
            setActiveFlow: (flowKey) => setActiveFlow(flowKey, true),
            selectStep: (flowKey, stepId) => selectStep(flowKey, stepId),
            selectAgent: (agentKey, flowKey) => selectAgent(agentKey, flowKey),
            clearSelection: clearSelection,
            qsByUiid,
            qsAllByUiidPrefix,
            // Layout spec methods (v0.5.0-flowstudio)
            getLayoutScreens: () => layoutScreens,
            getLayoutScreenById: (id) => getLayoutScreenByIdImpl(id),
            getAllKnownUIIDs: () => getAllKnownUIIDsImpl(),
            // Teaching mode (v0.6.0-flowstudio)
            getTeachingMode,
            setTeachingMode,
            // Context budget settings (v0.7.0-flowstudio)
            getContextBudgets,
            setContextBudgets,
            openContextBudgetModal
        };
    }
    catch (err) {
        // Fatal initialization error - mark UI as failed
        console.error("Flow Studio initialization failed", err);
        markUiError();
    }
});
// governance_ui.js
// swarm/tools/flow_studio_ui/src/governance_ui.ts
// Governance UI for Flow Studio
//
// This module handles:
// - Loading governance and validation status
// - Governance badge and overlay rendering
// - Validation issue counts and flow list badges
// - Graph node governance overlays
// - Governance details panel
import { state } from "./state.js";
import { Api } from "./api.js";
import { escapeHtml } from "./utils.js";
// ============================================================================
// Status Normalization
// ============================================================================
/**
 * Normalize legacy selftest status (GREEN/YELLOW/RED/UNKNOWN) to the 4-state model.
 * This provides backward compatibility with API responses while using the new vocabulary.
 *
 * Mapping:
 * - GREEN -> ok
 * - YELLOW -> warning
 * - RED -> error
 * - UNKNOWN -> unknown
 * - Already normalized values pass through unchanged
 */
function normalizeSelftestStatus(status) {
    const legacyMap = {
        GREEN: "ok",
        YELLOW: "warning",
        RED: "error",
        UNKNOWN: "unknown",
    };
    // Check if it's a legacy value
    if (status in legacyMap) {
        return legacyMap[status];
    }
    // Check if it's already a normalized value
    const normalizedValues = ["ok", "warning", "error", "unknown"];
    if (normalizedValues.includes(status)) {
        return status;
    }
    // Default to unknown for any unexpected value
    return "unknown";
}
/** Icon mapping for the 4-state model */
const selftestStatusIconMap = {
    ok: "\u2705", // Checkmark
    warning: "\u26a0\ufe0f", // Warning sign
    error: "\u274c", // X mark
    unknown: "\u2022", // Bullet (dot)
};
/** Text mapping for the 4-state model */
const selftestStatusTextMap = {
    ok: "Healthy",
    warning: "Degraded",
    error: "Issues",
    unknown: "Unknown",
};
/** Background color mapping for the 4-state model */
const selftestStatusBgMap = {
    ok: "#dcfce7", // Green
    warning: "#fef3c7", // Yellow
    error: "#fee2e2", // Red
    unknown: "#f3f4f6", // Gray
};
// ============================================================================
// Governance Status Loading
// ============================================================================
/**
 * Load governance status from API and update UI elements.
 */
export async function loadGovernanceStatus() {
    const iconEl = document.getElementById("governance-icon");
    const textEl = document.getElementById("governance-text");
    const badgeEl = document.getElementById("governance-badge");
    try {
        const data = await Api.getGovernanceStatus();
        state.governanceStatus = data;
        // Determine overall status using the 4-state model
        const kernel = data.governance?.kernel?.status || "unknown";
        const rawSelftest = data.governance?.selftest?.status || "unknown";
        const selftestStatus = normalizeSelftestStatus(rawSelftest);
        // Derive combined status: kernel healthy + selftest status
        let combinedStatus;
        if (kernel === "HEALTHY") {
            combinedStatus = selftestStatus;
        }
        else if (kernel === "unknown") {
            combinedStatus = "unknown";
        }
        else {
            // kernel is BROKEN or any other non-healthy state
            combinedStatus = "error";
        }
        const icon = selftestStatusIconMap[combinedStatus];
        const text = selftestStatusTextMap[combinedStatus];
        const bgColor = selftestStatusBgMap[combinedStatus];
        if (iconEl)
            iconEl.textContent = icon;
        if (textEl)
            textEl.textContent = text;
        if (badgeEl)
            badgeEl.style.background = bgColor;
        // Also load validation data for overlays
        try {
            const valData = await Api.getValidationData();
            state.validationData = valData;
            updateValidationIssuesCount();
            updateFlowListGovernance();
        }
        catch (valErr) {
            console.error("Failed to load validation data", valErr);
            state.validationData = null;
        }
    }
    catch (err) {
        console.error("Failed to load governance status", err);
        if (iconEl)
            iconEl.textContent = selftestStatusIconMap.unknown;
        if (textEl)
            textEl.textContent = selftestStatusTextMap.unknown;
        if (badgeEl)
            badgeEl.style.background = selftestStatusBgMap.unknown;
    }
}
// ============================================================================
// Validation Issues Count
// ============================================================================
/**
 * Update the issues count badge in the header.
 */
export function updateValidationIssuesCount() {
    const countEl = document.getElementById("governance-issues-count");
    if (!countEl)
        return;
    const totalIssues = (state.validationData?.summary?.agents_with_issues?.length || 0) +
        (state.validationData?.summary?.flows_with_issues?.length || 0) +
        (state.validationData?.summary?.steps_with_issues?.length || 0);
    if (totalIssues > 0) {
        countEl.textContent = String(totalIssues);
        countEl.style.display = "inline";
    }
    else {
        countEl.style.display = "none";
    }
}
// ============================================================================
// Flow List Governance Badges
// ============================================================================
/**
 * Update flow list items with governance warning badges.
 */
export function updateFlowListGovernance() {
    if (!state.validationData)
        return;
    const flowsWithIssues = state.validationData.summary?.flows_with_issues || [];
    document.querySelectorAll(".flow-item").forEach(item => {
        const flowKey = item.dataset.key;
        const existingBadge = item.querySelector(".flow-governance-badge");
        if (existingBadge)
            existingBadge.remove();
        if (flowKey && flowsWithIssues.includes(flowKey)) {
            const badge = document.createElement("span");
            badge.className = "flow-governance-badge has-issues";
            badge.innerHTML = "\u26a0\ufe0f";
            badge.title = "This flow has governance issues";
            item.appendChild(badge);
        }
    });
}
// ============================================================================
// Graph Governance Overlay
// ============================================================================
/**
 * Toggle governance overlay on graph nodes.
 */
export function toggleGovernanceOverlay(enabled) {
    state.governanceOverlayEnabled = enabled;
    const toggle = document.getElementById("governance-toggle");
    if (toggle)
        toggle.classList.toggle("active", enabled);
    updateGraphGovernanceOverlay();
    // Also apply FR status badges when overlay enabled
    if (enabled) {
        applyFRStatusToNodes();
    }
}
/**
 * Update graph nodes with governance issue highlighting.
 */
export function updateGraphGovernanceOverlay() {
    if (!state.cy || !state.validationData)
        return;
    const agentsWithIssues = state.validationData.summary?.agents_with_issues || [];
    const stepsWithIssues = state.validationData.summary?.steps_with_issues || [];
    state.cy.nodes().forEach(node => {
        const nodeData = node.data();
        let hasIssue = false;
        if (nodeData.type === "agent" && nodeData.agent_key && agentsWithIssues.includes(nodeData.agent_key)) {
            hasIssue = true;
        }
        if (nodeData.type === "step") {
            const stepKey = nodeData.flow + ":" + nodeData.step_id;
            if (stepsWithIssues.includes(stepKey))
                hasIssue = true;
        }
        // Use style method with type assertion
        const styleNode = node;
        if (state.governanceOverlayEnabled && hasIssue) {
            styleNode.style({
                "border-width": 3,
                "border-color": "#f59e0b",
                "border-style": "solid"
            });
        }
        else {
            styleNode.style({
                "border-width": nodeData.type === "step" ? 2 : 1,
                "border-color": nodeData.type === "step" ? "#0d9488" : "#d1d5db",
                "border-style": "solid"
            });
        }
    });
}
/**
 * Apply FR status classes to graph nodes for visual feedback.
 */
export function applyFRStatusToNodes() {
    if (!state.cy || !state.validationData || !state.governanceOverlayEnabled)
        return;
    const agentsWithIssues = state.validationData.summary?.agents_with_issues || [];
    const failedAgents = [];
    const warnAgents = [];
    // Determine which agents have fail vs warn status
    agentsWithIssues.forEach(agentKey => {
        const agentData = state.validationData?.agents?.[agentKey];
        if (agentData && agentData.checks) {
            const hasFailures = Object.values(agentData.checks).some(c => c.status === 'fail');
            if (hasFailures) {
                failedAgents.push(agentKey);
            }
            else {
                warnAgents.push(agentKey);
            }
        }
    });
    // Apply FR status classes
    state.cy.nodes('[type = "agent"]').forEach(node => {
        const agentKey = node.data('agent_key');
        const classNode = node;
        classNode.removeClass('fr-status-fail fr-status-warn fr-status-pass');
        if (failedAgents.includes(agentKey)) {
            classNode.addClass('fr-status-fail');
        }
        else if (warnAgents.includes(agentKey)) {
            classNode.addClass('fr-status-warn');
        }
    });
}
// ============================================================================
// Node Governance Info
// ============================================================================
/**
 * Get governance info for a specific node.
 */
export function getNodeGovernanceInfo(nodeData) {
    if (!state.validationData)
        return null;
    if (nodeData.type === "agent" && nodeData.agent_key) {
        const agentData = state.validationData.agents?.[nodeData.agent_key];
        if (agentData && agentData.has_issues)
            return agentData;
    }
    else if (nodeData.type === "step" && nodeData.step_id && nodeData.flow) {
        const stepKey = nodeData.flow + ":" + nodeData.step_id;
        const stepData = state.validationData.steps?.[stepKey];
        if (stepData && stepData.has_issues)
            return stepData;
    }
    return null;
}
/**
 * Get FR status badges HTML for a node.
 */
export function getNodeFRBadges(nodeData) {
    if (!state.validationData)
        return null;
    if (nodeData.type === "agent" && nodeData.agent_key) {
        const agentData = state.validationData.agents?.[nodeData.agent_key];
        if (agentData && agentData.checks) {
            return formatFRBadges(agentData.checks);
        }
    }
    return null;
}
/**
 * Format FR checks as HTML badges.
 */
export function formatFRBadges(checks) {
    if (!checks)
        return '<div class="fr-none">No FR data</div>';
    const badges = Object.entries(checks)
        .map(([fr, check]) => {
        const status = check.status || 'unknown';
        const message = check.message || fr;
        const title = message ? ` title="${escapeHtml(message)}"` : '';
        return `<span class="fr-badge fr-${status}"${title}>${fr}</span>`;
    })
        .join('');
    return `<div class="fr-badges">${badges}</div>`;
}
// ============================================================================
// Governance Section Rendering
// ============================================================================
/**
 * Render governance section in details panel.
 */
export function renderGovernanceSection(container, govInfo) {
    if (!govInfo || !govInfo.checks)
        return;
    const section = document.createElement("div");
    section.className = "governance-section" + (govInfo.has_issues ? "" : " healthy");
    const h3 = document.createElement("h3");
    h3.innerHTML = govInfo.has_issues ? "\u26a0\ufe0f Governance" : "\u2705 Governance";
    section.appendChild(h3);
    Object.entries(govInfo.checks || {}).forEach(([checkId, check]) => {
        const checkDiv = document.createElement("div");
        checkDiv.className = "governance-check";
        const nameSpan = document.createElement("span");
        nameSpan.className = "governance-check-name";
        nameSpan.textContent = checkId;
        const statusSpan = document.createElement("span");
        statusSpan.className = "governance-check-status " + check.status;
        const statusIcon = check.status === "pass" ? "\u2705" : check.status === "fail" ? "\u274c" : "\u26a0\ufe0f";
        statusSpan.innerHTML = statusIcon + " " + check.status.toUpperCase();
        checkDiv.appendChild(nameSpan);
        checkDiv.appendChild(statusSpan);
        section.appendChild(checkDiv);
        if (check.message && check.status !== "pass") {
            const msgDiv = document.createElement("div");
            msgDiv.className = "governance-fix";
            msgDiv.textContent = check.message;
            section.appendChild(msgDiv);
        }
        if (check.fix && check.status === "fail") {
            const fixDiv = document.createElement("div");
            fixDiv.className = "governance-fix";
            fixDiv.textContent = "Fix: " + check.fix;
            section.appendChild(fixDiv);
        }
    });
    container.appendChild(section);
}
/**
 * Generate resolution hints based on governance status.
 */
export function generateResolutionHints(governanceStatus) {
    const hints = [];
    const failedSteps = governanceStatus?.governance?.selftest?.failed_steps || [];
    const degradedSteps = governanceStatus?.governance?.selftest?.degraded_steps || [];
    const patterns = {
        "core-checks": {
            type: "failure",
            root_cause: "Python lint or compile errors in swarm/ directory",
            command: "ruff check swarm/ && python -m compileall -q swarm/",
            docs: "docs/SELFTEST_SYSTEM.md"
        },
        "skills-governance": {
            type: "failure",
            root_cause: "Invalid or missing skill YAML frontmatter",
            command: "uv run swarm/tools/validate_swarm.py --check-skills",
            docs: "CLAUDE.md \u00a7 Skills"
        },
        "agents-governance": {
            type: "failure",
            root_cause: "Agent bijection, color, or frontmatter validation failed",
            command: "uv run swarm/tools/validate_swarm.py --check-agents",
            docs: "CLAUDE.md \u00a7 Agent Ops"
        },
        "bdd": {
            type: "advisory",
            root_cause: "BDD feature files missing or malformed",
            command: "find features/ -name '*.feature' | head",
            docs: "docs/SELFTEST_SYSTEM.md"
        },
        "ac-status": {
            type: "advisory",
            root_cause: "Acceptance criteria tracking incomplete",
            command: "uv run swarm/tools/selftest.py --step ac-status",
            docs: "docs/SELFTEST_SYSTEM.md"
        },
        "policy-tests": {
            type: "failure",
            root_cause: "OPA policy validation failed",
            command: "make policy-tests",
            docs: "swarm/policies/README.md"
        },
        "flowstudio-smoke": {
            type: "workaround",
            root_cause: "Flow Studio smoke tests failed (may be missing deps)",
            command: "uv run pytest tests/test_flow_studio_fastapi_smoke.py -v",
            docs: "swarm/tools/flow_studio.py"
        }
    };
    failedSteps.forEach(step => {
        const pattern = patterns[step];
        if (pattern) {
            hints.push({
                type: "failure",
                step: step,
                root_cause: pattern.root_cause,
                command: pattern.command,
                docs: pattern.docs
            });
        }
        else {
            hints.push({
                type: "failure",
                step: step,
                root_cause: "Check selftest output for details",
                command: `uv run swarm/tools/selftest.py --step ${step}`,
                docs: "docs/SELFTEST_SYSTEM.md"
            });
        }
    });
    degradedSteps.forEach(step => {
        const pattern = patterns[step];
        if (pattern) {
            hints.push({
                type: "advisory",
                step: step,
                root_cause: pattern.root_cause + " (non-blocking in degraded mode)",
                command: pattern.command,
                docs: pattern.docs
            });
        }
    });
    return hints;
}
/**
 * Render resolution hints in the details panel.
 */
export function renderResolutionHints(container, governanceStatus) {
    const hints = generateResolutionHints(governanceStatus);
    if (hints.length === 0) {
        return;
    }
    const section = document.createElement("div");
    section.style.marginTop = "16px";
    const header = document.createElement("div");
    header.className = "kv-label";
    header.textContent = "Resolution Hints";
    section.appendChild(header);
    hints.forEach(hint => {
        const card = document.createElement("div");
        const bgColors = {
            failure: "#fee",
            advisory: "#fff3cd",
            workaround: "#e0f2fe"
        };
        card.className = "fs-text-sm";
        card.style.background = bgColors[hint.type] || "#f9fafb";
        card.style.border = "1px solid #e5e7eb";
        card.style.borderRadius = "4px";
        card.style.padding = "8px";
        card.style.marginTop = "8px";
        const typeLabel = document.createElement("div");
        typeLabel.style.fontWeight = "600";
        typeLabel.style.marginBottom = "4px";
        const allowedHintTypes = ["failure", "advisory", "workaround"];
        const safeType = allowedHintTypes.includes(hint.type) ? hint.type : "unknown";
        typeLabel.textContent = `${safeType.toUpperCase()}: ${hint.step || ''}`;
        card.appendChild(typeLabel);
        const rootCause = document.createElement("div");
        rootCause.style.marginBottom = "4px";
        rootCause.innerHTML = `<strong>Root Cause:</strong> ${escapeHtml(hint.root_cause || '')}`;
        card.appendChild(rootCause);
        const commandDiv = document.createElement("div");
        commandDiv.style.display = "flex";
        commandDiv.style.alignItems = "center";
        commandDiv.style.gap = "8px";
        commandDiv.style.marginBottom = "4px";
        commandDiv.innerHTML = `<strong>Command:</strong> <span class="mono">${escapeHtml(hint.command || '')}</span>`;
        const copyBtn = document.createElement("button");
        copyBtn.textContent = "Copy";
        copyBtn.className = "fs-text-xs";
        copyBtn.style.padding = "2px 6px";
        copyBtn.style.cursor = "pointer";
        copyBtn.style.border = "1px solid #d1d5db";
        copyBtn.style.background = "#fff";
        copyBtn.style.borderRadius = "3px";
        copyBtn.onclick = () => {
            navigator.clipboard.writeText(hint.command).then(() => {
                copyBtn.textContent = "Copied!";
                setTimeout(() => copyBtn.textContent = "Copy", 2000);
            }).catch((err) => {
                console.error("Failed to copy command:", err);
                copyBtn.textContent = "Failed";
                setTimeout(() => copyBtn.textContent = "Copy", 2000);
            });
        };
        commandDiv.appendChild(copyBtn);
        card.appendChild(commandDiv);
        const docsDiv = document.createElement("div");
        docsDiv.className = "muted";
        docsDiv.innerHTML = `<strong>Docs:</strong> <span class="mono">${escapeHtml(hint.docs || '')}</span>`;
        card.appendChild(docsDiv);
        section.appendChild(card);
    });
    container.appendChild(section);
}
// ============================================================================
// Selftest Plan Rendering (for governance details)
// ============================================================================
/**
 * Render selftest plan table HTML.
 */
export async function renderSelftestPlan() {
    try {
        const plan = await Api.getSelftestPlan();
        const tierColors = {
            kernel: "#dc2626",
            governance: "#d97706",
            optional: "#6b7280"
        };
        let stepsHtml = '<table class="artifact-table fs-text-sm">';
        stepsHtml += '<thead><tr><th>Step</th><th>Tier</th><th>Severity</th><th>Category</th><th>Dependencies</th></tr></thead><tbody>';
        plan.steps.forEach(step => {
            const tierColor = tierColors[step.tier] || "#6b7280";
            const failedSteps = (state.governanceStatus?.governance?.selftest?.failed_steps || []);
            const degradedSteps = (state.governanceStatus?.governance?.selftest?.degraded_steps || []);
            const isFailed = failedSteps.includes(step.id);
            const isDegraded = degradedSteps.includes(step.id);
            const statusIcon = isFailed ? "\u274c" : isDegraded ? "\u26a0\ufe0f" : "\u2705";
            const deps = step.depends_on.length ? step.depends_on.join(", ") : "\u2014";
            stepsHtml += `<tr style="${isFailed ? 'background: #fee;' : isDegraded ? 'background: #fff3cd;' : ''}">
        <td>${statusIcon} <span class="mono">${escapeHtml(step.id)}</span></td>
        <td><span style="color: ${tierColor}; font-weight: 600;">${escapeHtml(step.tier)}</span></td>
        <td>${escapeHtml(step.severity)}</td>
        <td>${escapeHtml(step.category)}</td>
        <td class="muted">${escapeHtml(deps)}</td>
      </tr>`;
        });
        stepsHtml += '</tbody></table>';
        const summary = plan.summary;
        const commands = `
      <div style="margin-top: 12px;">
        <div class="kv-label">Quick Commands</div>
        <button class="fs-text-sm" onclick="navigator.clipboard.writeText('make selftest')" style="margin: 4px; padding: 4px 8px; cursor: pointer; border: 1px solid #d1d5db; background: #f3f4f6; border-radius: 3px;">Copy: make selftest</button>
        <button class="fs-text-sm" onclick="navigator.clipboard.writeText('make kernel-smoke')" style="margin: 4px; padding: 4px 8px; cursor: pointer; border: 1px solid #d1d5db; background: #f3f4f6; border-radius: 3px;">Copy: make kernel-smoke</button>
        <button class="fs-text-sm" onclick="navigator.clipboard.writeText('make selftest-doctor')" style="margin: 4px; padding: 4px 8px; cursor: pointer; border: 1px solid #d1d5db; background: #f3f4f6; border-radius: 3px;">Copy: make selftest-doctor</button>
      </div>
    `;
        return `
      <div class="kv-label">Selftest Plan (${summary.total} steps)</div>
      <div class="fs-text-sm" style="margin-bottom: 8px;">
        <span style="color: ${tierColors.kernel}; font-weight: 600;">Kernel: ${summary.by_tier.kernel}</span> |
        <span style="color: ${tierColors.governance}; font-weight: 600;">Governance: ${summary.by_tier.governance}</span> |
        <span style="color: ${tierColors.optional};">Optional: ${summary.by_tier.optional}</span>
      </div>
      ${stepsHtml}
      ${commands}
      <div class="muted fs-text-xs" style="margin-top: 8px;">
        \ud83d\udcd6 Docs: <span class="mono">docs/SELFTEST_SYSTEM.md</span>
      </div>
    `;
    }
    catch (error) {
        console.error("Failed to load selftest plan:", error);
        return `<div class="muted">Failed to load selftest plan: ${escapeHtml(error.message)}</div>`;
    }
}
/**
 * Show full governance details in the details panel.
 */
export function showGovernanceDetails() {
    const detailsEl = document.getElementById("details");
    if (!detailsEl)
        return;
    detailsEl.innerHTML = "";
    const h2 = document.createElement("h2");
    h2.textContent = "Governance Status";
    if (!state.governanceStatus) {
        const msg = document.createElement("div");
        msg.className = "muted";
        msg.textContent = "Governance status not available. Run 'make selftest' to generate status.";
        detailsEl.appendChild(h2);
        detailsEl.appendChild(msg);
        return;
    }
    const gov = state.governanceStatus.governance || { kernel: { status: "unknown" }, selftest: { status: "unknown", mode: "unknown", kernel_ok: false, governance_ok: false, optional_ok: false, failed_steps: [], degraded_steps: [] } };
    const kernel = gov.kernel || { status: "unknown" };
    const selftest = gov.selftest || { status: "unknown", mode: "unknown", kernel_ok: false, governance_ok: false, optional_ok: false, failed_steps: [], degraded_steps: [] };
    const allowedKernelStatuses = ["HEALTHY", "BROKEN", "unknown"];
    const rawKernelStatus = kernel.status || "unknown";
    const kernelStatus = allowedKernelStatuses.includes(rawKernelStatus) ? rawKernelStatus : "unknown";
    const kernelIcon = kernelStatus === "HEALTHY" ? "\u2705" : "\u274c";
    // Normalize selftest status to the 4-state model (handles both legacy and new formats)
    const rawSelftestStatus = selftest.status || "unknown";
    const normalizedStatus = normalizeSelftestStatus(rawSelftestStatus);
    const selftestIcon = selftestStatusIconMap[normalizedStatus];
    const selftestDisplayText = selftestStatusTextMap[normalizedStatus];
    const allowedModes = ["strict", "degraded", "kernel-only", "unknown"];
    const rawMode = selftest.mode || "unknown";
    const safeMode = allowedModes.includes(rawMode) ? rawMode : "unknown";
    const content = document.createElement("div");
    content.innerHTML = `
    <div class="kv-label">Kernel</div>
    <div style="font-weight: 600;">${kernelIcon} ${escapeHtml(kernelStatus)}</div>
    ${kernel.error ? `<div class="muted fs-text-sm">${escapeHtml(kernel.error)}</div>` : ""}

    <div class="kv-label">Selftest</div>
    <div style="font-weight: 600;">${selftestIcon} ${escapeHtml(selftestDisplayText)}</div>
    <div class="fs-text-sm fs-text-muted">
      Mode: ${escapeHtml(safeMode)}<br/>
      Kernel OK: ${selftest.kernel_ok ? "\u2705" : "\u274c"}<br/>
      Governance OK: ${selftest.governance_ok ? "\u2705" : "\u274c"}<br/>
      Optional OK: ${selftest.optional_ok ? "\u2705" : "\u274c"}
    </div>

    ${selftest.failed_steps?.length ? `
      <div class="kv-label" style="margin-top: 12px;">Failed Steps (Critical)</div>
      <div class="fs-text-sm">
        ${selftest.failed_steps.map(s => `<span class="mono" style="color: #dc2626;">${escapeHtml(s)}</span>`).join(", ")}
      </div>
    ` : ""}
    ${selftest.degraded_steps?.length ? `
      <div class="kv-label">Degraded Steps (Warning/Info)</div>
      <div class="fs-text-sm">
        ${selftest.degraded_steps.map(s => `<span class="mono" style="color: #d97706;">${escapeHtml(s)}</span>`).join(", ")}
      </div>
    ` : ""}

    <div class="kv-label" style="margin-top: 12px;">Stats</div>
    <table class="artifact-table">
      <tr><td>Critical</td><td class="status-complete">${selftest.critical_passed || 0} passed</td><td class="status-missing">${selftest.critical_failed || 0} failed</td></tr>
      <tr><td>Warning</td><td class="status-complete">${selftest.warning_passed || 0} passed</td><td class="status-partial">${selftest.warning_failed || 0} failed</td></tr>
      <tr><td>Info</td><td class="status-complete">${selftest.info_passed || 0} passed</td><td class="status-na">${selftest.info_failed || 0} failed</td></tr>
    </table>

    <div class="muted" style="margin-top: 16px;">
      <strong>To refresh:</strong>
      <pre class="mono">make selftest</pre>
      Last checked: ${escapeHtml(state.governanceStatus.timestamp || "unknown")}
    </div>
  `;
    detailsEl.appendChild(h2);
    detailsEl.appendChild(content);
    renderResolutionHints(detailsEl, state.governanceStatus);
}
// graph.js
// swarm/tools/flow_studio_ui/src/graph.ts
// Cytoscape graph management for Flow Studio
//
// This module handles:
// - Cytoscape instance creation and configuration
// - Graph rendering (nodes, edges, layout)
// - Node tap event handling via callbacks
import { state } from "./state.js";
// ============================================================================
// CSS Token Helpers
// ============================================================================
/**
 * Get the graph edge color from CSS token.
 * Falls back to default if DOM not available or token not set.
 */
function getGraphEdgeColor() {
    try {
        const root = document.documentElement;
        const value = getComputedStyle(root)
            .getPropertyValue("--fs-color-graph-edge")
            .trim();
        return value || "#818cf8";
    }
    catch {
        return "#818cf8";
    }
}
// ============================================================================
// Cytoscape Style Configuration
// ============================================================================
/**
 * Build graph styles with resolved CSS tokens.
 * Called at runtime when DOM is available.
 */
function getGraphStyles() {
    const edgeColor = getGraphEdgeColor();
    return [
        {
            selector: 'node[type = "step"]',
            style: {
                "background-color": "#0f766e",
                "label": "data(label)",
                "text-valign": "center",
                "text-halign": "center",
                "color": "#ffffff",
                "font-size": 10,
                "shape": "round-rectangle",
                "padding": "6px",
                "width": "label",
                "height": "label",
                "border-width": 2,
                "border-color": "#134e4a"
            }
        },
        {
            selector: 'node[type = "agent"]',
            style: {
                "background-color": "data(color)",
                "label": "data(label)",
                "text-valign": "center",
                "text-halign": "center",
                "color": "#111827",
                "font-size": 10,
                "shape": "round-rectangle",
                "padding": "5px",
                "width": "label",
                "height": "label",
                "border-width": 2,
                "border-color": "#374151",
                "text-opacity": 1
            }
        },
        {
            selector: "edge",
            style: {
                "width": 2,
                "line-color": edgeColor,
                "target-arrow-color": edgeColor,
                "target-arrow-shape": "triangle",
                "curve-style": "bezier"
            }
        },
        {
            selector: 'edge[type = "step-sequence"]',
            style: {
                "line-style": "solid"
            }
        },
        {
            selector: 'edge[type = "step-agent"]',
            style: {
                "line-style": "dotted"
            }
        },
        {
            selector: 'node[type = "artifact"]',
            style: {
                "background-color": "#9ca3af",
                "label": "data(label)",
                "text-valign": "center",
                "text-halign": "center",
                "color": "#111827",
                "font-size": 9,
                "shape": "round-rectangle",
                "padding": "4px",
                "width": "label",
                "height": "label",
                "border-width": 2,
                "border-color": "#6b7280",
                "text-opacity": 1
            }
        },
        {
            selector: 'node[type = "artifact"][status = "present"]',
            style: {
                "background-color": "#22c55e"
            }
        },
        {
            selector: 'node[type = "artifact"][status = "missing"]',
            style: {
                "background-color": "#ef4444"
            }
        },
        {
            selector: 'node[type = "artifact"][is_decision]',
            style: {
                "border-width": 3,
                "border-color": "#3b82f6"
            }
        },
        {
            selector: 'edge[type = "step-artifact"]',
            style: {
                "line-style": "dotted"
            }
        }
    ];
}
const DEFAULT_LAYOUT = {
    name: "breadthfirst",
    directed: true,
    padding: 16
};
// ============================================================================
// Module State
// ============================================================================
let nodeClickHandler = null;
// ============================================================================
// Public API
// ============================================================================
/**
 * Initialize the Cytoscape graph instance.
 * Safe to call multiple times - returns existing instance if already initialized.
 */
export function initGraph(options = {}) {
    if (options.onNodeClick) {
        nodeClickHandler = options.onNodeClick;
    }
    if (state.cy) {
        return state.cy;
    }
    state.cy = cytoscape({
        container: document.getElementById("graph"),
        elements: { nodes: [], edges: [] },
        layout: DEFAULT_LAYOUT,
        style: getGraphStyles()
    });
    // Set up node tap handler
    state.cy.on("tap", (ev) => {
        if (!nodeClickHandler)
            return;
        // Check if target has a data method (it's a node)
        const target = ev.target;
        if (target && typeof target.data === "function") {
            const data = target.data();
            nodeClickHandler(data);
        }
    });
    return state.cy;
}
/**
 * Render a graph with the given nodes and edges.
 * Initializes Cytoscape if not already done.
 */
export function renderGraphCore(graph, options = {}) {
    const cy = initGraph(options);
    const elements = [];
    (graph.nodes || []).forEach(n => elements.push(n));
    (graph.edges || []).forEach(e => elements.push(e));
    cy.elements().forEach(() => {
        // Remove is handled by remove method
    });
    cy.remove(cy.elements());
    cy.add(elements);
    cy.layout(DEFAULT_LAYOUT).run();
    return cy;
}
/**
 * Get the current Cytoscape instance.
 */
export function getCy() {
    return state.cy;
}
/**
 * Update the node click handler.
 * Useful when you need to change behavior after initialization.
 */
export function setNodeClickHandler(handler) {
    nodeClickHandler = handler;
}
/**
 * Fit the graph view to a specific node with animation.
 */
export function focusNode(nodeId, options = {}) {
    const { padding = 50 } = options;
    if (!state.cy)
        return;
    const node = state.cy.getElementById(nodeId);
    if (node) {
        state.cy.fit(padding);
        node.select();
    }
}
/**
 * Get step nodes sorted by their order.
 */
export function getStepNodesSorted() {
    if (!state.cy)
        return [];
    return state.cy.nodes('[type = "step"]').sort((a, b) => {
        const orderA = a.data("order");
        const orderB = b.data("order");
        return orderA - orderB;
    });
}
// graph_outline.js
// swarm/tools/flow_studio_ui/src/graph_outline.ts
// Semantic graph companion for accessibility and LLM agents
//
// This module provides:
// - getCurrentGraphState(): Export graph state as JSON (for snapshots/testing)
// - renderFlowOutline(): DOM companion tree mirroring the graph structure
//
// The DOM outline provides ARIA tree semantics for screen readers and
// a text representation for LLM agents that can't "see" the Cytoscape canvas.
import { state, FLOW_KEYS } from "./state.js";
// ============================================================================
// Graph State Export
// ============================================================================
/**
 * Get the current graph state as a JSON-serializable object.
 * Useful for snapshots, tests, and LLM agent context.
 */
export function getCurrentGraphState() {
    if (!state.currentFlowKey || !state.cy)
        return null;
    // Sort nodes by ID for deterministic output
    const nodes = state.cy.nodes()
        .map((node) => ({
        id: node.id(),
        type: node.data("type"),
        label: node.data("label"),
        flow: node.data("flow"),
        step_id: node.data("step_id") || null,
        order: node.data("order") || null,
        color: node.data("color") || null,
        status: node.data("status") || null
    }))
        .sort((a, b) => a.id.localeCompare(b.id));
    // Sort edges by ID for deterministic output
    const edges = state.cy.edges()
        .map((edge) => ({
        id: edge.id(),
        type: edge.data("type"),
        source: edge.data("source"),
        target: edge.data("target")
    }))
        .sort((a, b) => a.id.localeCompare(b.id));
    return {
        version: "flow_graph.v1",
        flow_key: state.currentFlowKey,
        run_id: state.currentRunId || null,
        view_mode: state.currentViewMode,
        timestamp: new Date().toISOString(),
        nodes,
        edges
    };
}
// ============================================================================
// DOM Outline Rendering
// ============================================================================
/**
 * Render a semantic DOM tree mirroring the graph structure.
 * This provides:
 * - ARIA tree semantics for screen readers
 * - Text representation for LLM agents
 * - Stable selectors for testing (data-uiid)
 *
 * The outline is rendered into #flow-outline (visually hidden but accessible).
 */
export function renderFlowOutline() {
    const outline = document.getElementById("flow-outline");
    if (!outline)
        return;
    const graphState = getCurrentGraphState();
    if (!graphState) {
        outline.innerHTML = "";
        outline.setAttribute("aria-busy", "false");
        return;
    }
    outline.setAttribute("aria-busy", "true");
    outline.innerHTML = "";
    // Group nodes by type
    const steps = graphState.nodes
        .filter(n => n.type === "step")
        .sort((a, b) => (a.order || 0) - (b.order || 0));
    const agents = graphState.nodes.filter(n => n.type === "agent");
    const artifacts = graphState.nodes.filter(n => n.type === "artifact");
    // Create flow info
    const flowInfo = document.createElement("div");
    flowInfo.setAttribute("role", "treeitem");
    flowInfo.setAttribute("aria-level", "1");
    flowInfo.dataset.uiid = `flow_studio.canvas.outline.flow:${graphState.flow_key}`;
    flowInfo.textContent = `Flow: ${graphState.flow_key} (${steps.length} steps, ${agents.length} agents)`;
    outline.appendChild(flowInfo);
    // Create steps group
    if (steps.length > 0) {
        const stepsGroup = document.createElement("div");
        stepsGroup.setAttribute("role", "group");
        stepsGroup.setAttribute("aria-label", "Steps");
        stepsGroup.dataset.uiid = "flow_studio.canvas.outline.steps";
        steps.forEach((step, index) => {
            const stepItem = document.createElement("div");
            stepItem.setAttribute("role", "treeitem");
            stepItem.setAttribute("aria-level", "2");
            stepItem.dataset.uiid = `flow_studio.canvas.outline.step:${step.id}`;
            stepItem.textContent = `${index + 1}. ${step.label || step.step_id || step.id}`;
            // Find agents connected to this step
            const connectedAgentIds = graphState.edges
                .filter(e => e.source === step.id && e.type === "step-agent")
                .map(e => e.target);
            const connectedAgents = agents.filter(a => connectedAgentIds.includes(a.id));
            if (connectedAgents.length > 0) {
                const agentsList = document.createElement("div");
                agentsList.setAttribute("role", "group");
                agentsList.setAttribute("aria-label", `Agents for ${step.label}`);
                connectedAgents.forEach(agent => {
                    const agentItem = document.createElement("div");
                    agentItem.setAttribute("role", "treeitem");
                    agentItem.setAttribute("aria-level", "3");
                    agentItem.dataset.uiid = `flow_studio.canvas.outline.agent:${agent.id}`;
                    agentItem.textContent = `‚Üí ${agent.label || agent.id}`;
                    agentsList.appendChild(agentItem);
                });
                stepItem.appendChild(agentsList);
            }
            // Find artifacts connected to this step (if in artifacts view)
            const connectedArtifactIds = graphState.edges
                .filter(e => e.source === step.id && e.type === "step-artifact")
                .map(e => e.target);
            const connectedArtifacts = artifacts.filter(a => connectedArtifactIds.includes(a.id));
            if (connectedArtifacts.length > 0) {
                const artifactsList = document.createElement("div");
                artifactsList.setAttribute("role", "group");
                artifactsList.setAttribute("aria-label", `Artifacts for ${step.label}`);
                connectedArtifacts.forEach(artifact => {
                    const artifactItem = document.createElement("div");
                    artifactItem.setAttribute("role", "treeitem");
                    artifactItem.setAttribute("aria-level", "3");
                    artifactItem.dataset.uiid = `flow_studio.canvas.outline.artifact:${artifact.id}`;
                    const statusIndicator = artifact.status === "present" ? "‚úì"
                        : artifact.status === "missing" ? "‚úó"
                            : "‚óã";
                    artifactItem.textContent = `${statusIndicator} ${artifact.label || artifact.id}`;
                    artifactsList.appendChild(artifactItem);
                });
                stepItem.appendChild(artifactsList);
            }
            stepsGroup.appendChild(stepItem);
        });
        outline.appendChild(stepsGroup);
    }
    outline.setAttribute("aria-busy", "false");
}
// ============================================================================
// Debug Export (development only)
// ============================================================================
// Expose for browser console debugging (development only)
if (typeof window !== "undefined") {
    window.__flowStudioGraph = {
        getCurrentGraphState,
        renderFlowOutline
    };
}
// main.js
// swarm/tools/flow_studio_ui/src/main.ts
// ESM entry point for Flow Studio
//
// Imports the bootstrap shell which initializes all modules.
import "./flow-studio-app.js";
// runs_flows.js
// swarm/tools/flow_studio_ui/src/runs_flows.ts
// Run + flow orchestration for Flow Studio
//
// This module handles:
// - Run loading and selection (loadRuns, loadRunStatus)
// - Flow loading and selection (loadFlows, setActiveFlow)
// - SDLC bar updates (updateSDLCBar)
// - Flow list status (updateFlowListStatus)
// - Graph status overlays (updateGraphStatus)
// - Run comparison (setCompareRun, loadComparison)
import { state, STATUS_ICONS, FLOW_STATUS_META } from "./state.js";
import { FLOW_KEYS, FLOW_TITLES } from "./flow_constants.js";
import { Api } from "./api.js";
import { renderGraphCore } from "./graph.js";
import { renderFlowOutline } from "./graph_outline.js";
import { getTeachingMode } from "./teaching_mode.js";
import { renderNoRuns, renderNoFlows, renderRunsLoadError, } from "./ui_fragments.js";
// Cached wisdom summary for current run
let _cachedWisdomSummary = null;
let _wisdomLoadPromise = null;
// ============================================================================
// Canvas empty state management
// ============================================================================
/**
 * Show or hide the canvas empty state based on whether we have data.
 * Called when runs/flows are loaded or cleared.
 */
export function updateCanvasEmptyState(hasRuns) {
    const emptyState = document.getElementById("canvas-empty-state");
    if (!emptyState)
        return;
    emptyState.style.display = hasRuns ? "none" : "flex";
}
// ============================================================================
// Module configuration - callbacks set by consumer
// ============================================================================
let _onFlowDetails = null;
let _onNodeClick = null;
let _onURLUpdate = null;
let _updateFlowListGovernance = null;
/**
 * Configure callbacks for the runs/flows module.
 * Call this before using other functions to wire up UI interactions.
 */
export function configure(callbacks = {}) {
    if (callbacks.onFlowDetails)
        _onFlowDetails = callbacks.onFlowDetails;
    if (callbacks.onNodeClick)
        _onNodeClick = callbacks.onNodeClick;
    if (callbacks.onURLUpdate)
        _onURLUpdate = callbacks.onURLUpdate;
    if (callbacks.updateFlowListGovernance)
        _updateFlowListGovernance = callbacks.updateFlowListGovernance;
}
// ============================================================================
// Flow Health Status
// ============================================================================
/**
 * Map flow status data to a simplified health status for sidebar display.
 * This provides a consistent mental model: ok, warning, error, unknown.
 *
 * @param flowData - The flow status data from the run summary, or undefined if no data
 * @returns FlowHealthStatus - The simplified health status
 */
export function getFlowHealthStatus(flowData) {
    // No data means unknown
    if (!flowData) {
        return "unknown";
    }
    const status = flowData.status;
    // Map StepStatus to FlowHealthStatus
    switch (status) {
        case "done":
        case "complete":
            return "ok";
        case "partial":
        case "in_progress":
            return "warning";
        case "missing":
            return "error";
        case "not_started":
        case "n/a":
        default:
            return "unknown";
    }
}
// ============================================================================
// Run Management
// ============================================================================
/**
 * Helper to get display name for a run.
 */
function getRunDisplayName(run) {
    return run.title || run.run_id;
}
/**
 * Load runs into the run selector and initialize state.currentRunId.
 * Also caches runs for compare selector and loads initial run status.
 */
export async function loadRuns() {
    try {
        const data = await Api.getRuns();
        const runs = data.runs || [];
        const selector = document.getElementById("run-selector");
        if (!selector)
            return runs;
        selector.innerHTML = "";
        if (!runs.length) {
            selector.innerHTML = '<option value="">No runs available</option>';
            // Show empty state hint in sidebar
            const listEl = document.getElementById("flow-list");
            if (listEl) {
                listEl.innerHTML = renderNoRuns();
            }
            // Show canvas empty state
            updateCanvasEmptyState(false);
            return runs;
        }
        // Hide canvas empty state since we have runs
        updateCanvasEmptyState(true);
        // Group by type
        const examples = runs.filter(r => r.run_type === "example");
        const active = runs.filter(r => r.run_type === "active");
        if (examples.length) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = "Examples";
            examples.forEach(run => {
                const opt = document.createElement("option");
                opt.value = run.run_id;
                opt.textContent = getRunDisplayName(run);
                opt.title = run.description || "";
                optgroup.appendChild(opt);
            });
            selector.appendChild(optgroup);
        }
        if (active.length) {
            const optgroup = document.createElement("optgroup");
            optgroup.label = "Active Runs";
            active.forEach(run => {
                const opt = document.createElement("option");
                opt.value = run.run_id;
                opt.textContent = getRunDisplayName(run);
                opt.title = run.description || "";
                optgroup.appendChild(opt);
            });
            selector.appendChild(optgroup);
        }
        // Default to first example or first run
        state.currentRunId = examples.length ? examples[0].run_id : runs[0].run_id;
        selector.value = state.currentRunId;
        // Cache runs for compare selector
        state.availableRuns = runs;
        updateCompareSelector();
        // Load run status
        await loadRunStatus();
        return runs;
    }
    catch (err) {
        console.error("Failed to load runs", err);
        const selector = document.getElementById("run-selector");
        if (selector) {
            selector.innerHTML = '<option value="">Error loading runs</option>';
        }
        // Show error state in sidebar
        const listEl = document.getElementById("flow-list");
        if (listEl) {
            listEl.innerHTML = renderRunsLoadError();
        }
        // Show canvas empty state on error
        updateCanvasEmptyState(false);
        return [];
    }
}
/**
 * Load summary for current run and update SDLC + flow list + graph status.
 */
export async function loadRunStatus() {
    if (!state.currentRunId)
        return;
    try {
        const data = await Api.getRunSummary(state.currentRunId);
        state.runStatus = data || {};
        updateSDLCBar();
        updateFlowListStatus();
        if (state.currentFlowKey && state.cy) {
            updateGraphStatus();
            // Refresh outline since status labels may have changed
            renderFlowOutline();
        }
    }
    catch (err) {
        console.error("Failed to load run status", err);
        state.runStatus = {};
    }
}
/**
 * Update the compare run selector dropdown.
 */
export function updateCompareSelector() {
    const compareSelector = document.getElementById("compare-selector");
    if (!compareSelector)
        return;
    compareSelector.innerHTML = '<option value="">None</option>';
    const examples = state.availableRuns.filter(r => r.run_type === "example" && r.run_id !== state.currentRunId);
    const active = state.availableRuns.filter(r => r.run_type === "active" && r.run_id !== state.currentRunId);
    if (examples.length) {
        const optgroup = document.createElement("optgroup");
        optgroup.label = "Examples";
        examples.forEach(run => {
            const opt = document.createElement("option");
            opt.value = run.run_id;
            opt.textContent = getRunDisplayName(run);
            opt.title = run.description || "";
            optgroup.appendChild(opt);
        });
        compareSelector.appendChild(optgroup);
    }
    if (active.length) {
        const optgroup = document.createElement("optgroup");
        optgroup.label = "Active Runs";
        active.forEach(run => {
            const opt = document.createElement("option");
            opt.value = run.run_id;
            opt.textContent = getRunDisplayName(run);
            opt.title = run.description || "";
            optgroup.appendChild(opt);
        });
        compareSelector.appendChild(optgroup);
    }
    // Clear invalid compare run
    if (state.compareRunId && !state.availableRuns.find(r => r.run_id === state.compareRunId && r.run_id !== state.currentRunId)) {
        state.compareRunId = null;
        state.comparisonData = null;
    }
    else if (state.compareRunId) {
        compareSelector.value = state.compareRunId;
    }
}
/**
 * Load comparison data between current and compare runs.
 */
export async function loadComparison() {
    if (!state.compareRunId || !state.currentFlowKey || !state.currentRunId) {
        state.comparisonData = null;
        return;
    }
    try {
        state.comparisonData = await Api.compareRuns({
            runA: state.currentRunId,
            runB: state.compareRunId,
            flow: state.currentFlowKey
        });
        updateSDLCBar();
    }
    catch (err) {
        console.error("Failed to load comparison", err);
        state.comparisonData = null;
    }
}
/**
 * Set comparison run and load comparison data.
 */
export async function setCompareRun(runId) {
    state.compareRunId = runId || null;
    state.comparisonData = null;
    if (state.compareRunId && state.currentFlowKey) {
        await loadComparison();
    }
    else {
        updateSDLCBar();
    }
}
/**
 * Render comparison table HTML from state.comparisonData.
 */
export function renderComparisonTable() {
    if (!state.comparisonData)
        return "";
    const summary = state.comparisonData.summary || { improved: 0, regressed: 0, unchanged: 0 };
    const steps = state.comparisonData.steps || [];
    const statusIcons = { complete: "\u2705", partial: "\u26a0\ufe0f", missing: "\u274c", "n/a": "\u2014" };
    const changeIndicators = {
        improved: { arrow: "\u2191", cls: "arrow-improved" },
        regressed: { arrow: "\u2193", cls: "arrow-regressed" },
        unchanged: { arrow: "\u2192", cls: "arrow-unchanged" }
    };
    const rows = steps.map(s => {
        const iconA = statusIcons[s.run_a.status] || "\u2014";
        const iconB = statusIcons[s.run_b.status] || "\u2014";
        const ch = changeIndicators[s.change] || changeIndicators.unchanged;
        return `<tr><td>${s.step_id}</td><td>${iconA} ${s.run_a.status}</td><td>${iconB} ${s.run_b.status}</td><td class="${ch.cls}">${ch.arrow} ${s.change}</td></tr>`;
    }).join("");
    return `
    <div class="compare-summary">
      <span class="compare-summary-item change-improved">\u2191 ${summary.improved || 0} improved</span>
      <span class="compare-summary-item change-regressed">\u2193 ${summary.regressed || 0} regressed</span>
      <span class="compare-summary-item change-unchanged">\u2192 ${summary.unchanged || 0} unchanged</span>
    </div>
    <table class="comparison-table">
      <thead><tr><th>Step</th><th>Run A (${state.comparisonData.run_a})</th><th>Run B (${state.comparisonData.run_b})</th><th>Change</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}
// ============================================================================
// SDLC Bar
// ============================================================================
/**
 * Load wisdom summary for the current run (with caching).
 * Returns null if no wisdom data is available.
 */
async function loadWisdomSummary() {
    if (!state.currentRunId) {
        _cachedWisdomSummary = null;
        return null;
    }
    // Return cached if available
    if (_cachedWisdomSummary && _cachedWisdomSummary.run_id === state.currentRunId) {
        return _cachedWisdomSummary;
    }
    // Avoid duplicate requests
    if (_wisdomLoadPromise) {
        return _wisdomLoadPromise;
    }
    _wisdomLoadPromise = (async () => {
        try {
            const wisdom = await Api.getRunWisdom(state.currentRunId);
            _cachedWisdomSummary = wisdom;
            return wisdom;
        }
        catch {
            // 404 or other error - no wisdom available
            _cachedWisdomSummary = null;
            return null;
        }
        finally {
            _wisdomLoadPromise = null;
        }
    })();
    return _wisdomLoadPromise;
}
/**
 * Determine wisdom indicator status from wisdom summary.
 */
function getWisdomIndicatorStatus(wisdom) {
    if (!wisdom) {
        return "unknown";
    }
    // Check for regressions
    if (wisdom.summary.regressions_found > 0) {
        return "error";
    }
    // Check for any failed flows or issues
    const hasFailedFlows = Object.values(wisdom.flows).some(f => f.status === "failed");
    if (hasFailedFlows || wisdom.summary.issues_created > 0) {
        return "warning";
    }
    return "ok";
}
/**
 * Get CSS class for wisdom indicator dot.
 */
function getWisdomIndicatorClass(status) {
    const classes = {
        ok: "wisdom-indicator--ok",
        warning: "wisdom-indicator--warning",
        error: "wisdom-indicator--error",
        unknown: "wisdom-indicator--unknown",
    };
    return classes[status] || classes.unknown;
}
/**
 * Get tooltip text for wisdom indicator.
 */
function getWisdomIndicatorTooltip(status, wisdom) {
    switch (status) {
        case "ok":
            return `Wisdom: ${wisdom?.summary.learnings_count || 0} learnings, no regressions`;
        case "warning":
            return `Wisdom: ${wisdom?.summary.issues_created || 0} issues created`;
        case "error":
            return `Wisdom: ${wisdom?.summary.regressions_found || 0} regressions found`;
        case "unknown":
        default:
            return "Wisdom: No data available";
    }
}
/**
 * Clear cached wisdom data (called when run changes).
 */
export function clearWisdomCache() {
    _cachedWisdomSummary = null;
    _wisdomLoadPromise = null;
}
/**
 * Update SDLC bar with run + comparison status.
 */
export function updateSDLCBar() {
    const container = document.getElementById("sdlc-flows");
    if (!container)
        return;
    container.innerHTML = "";
    FLOW_KEYS.forEach((key, idx) => {
        if (idx > 0) {
            const arrow = document.createElement("span");
            arrow.className = "sdlc-arrow";
            arrow.textContent = "\u2192";
            container.appendChild(arrow);
        }
        const flowData = state.runStatus.flows?.[key];
        const status = (flowData?.status || "not_started");
        const icon = STATUS_ICONS[status] || "\u2014";
        const el = document.createElement("span");
        el.className = "sdlc-flow" + (key === state.currentFlowKey ? " active" : "");
        el.dataset.key = key;
        el.innerHTML = `<span class="icon">${icon}</span> ${FLOW_TITLES[key]}`;
        el.addEventListener("click", () => setActiveFlow(key));
        container.appendChild(el);
    });
    // Add wisdom indicator after the SDLC bar flows
    renderWisdomIndicator(container);
}
/**
 * Render wisdom indicator dot in SDLC bar.
 * Shows status of wisdom data availability and health.
 */
async function renderWisdomIndicator(container) {
    // Create placeholder element
    const indicatorWrapper = document.createElement("span");
    indicatorWrapper.className = "wisdom-indicator-wrapper";
    indicatorWrapper.setAttribute("data-uiid", "flow_studio.sdlc_bar.wisdom_indicator");
    container.appendChild(indicatorWrapper);
    // Load wisdom data asynchronously
    const wisdom = await loadWisdomSummary();
    const status = getWisdomIndicatorStatus(wisdom);
    // Skip rendering if no data and run has no completed wisdom flow
    const wisdomFlowData = state.runStatus.flows?.wisdom;
    if (status === "unknown" && (!wisdomFlowData || wisdomFlowData.status === "not_started")) {
        indicatorWrapper.style.display = "none";
        return;
    }
    const indicatorClass = getWisdomIndicatorClass(status);
    const tooltip = getWisdomIndicatorTooltip(status, wisdom);
    indicatorWrapper.innerHTML = `
    <span class="wisdom-indicator ${indicatorClass}" title="${tooltip}" aria-label="${tooltip}">
      <span class="wisdom-indicator__dot"></span>
    </span>
  `;
    indicatorWrapper.style.display = "inline-flex";
}
// ============================================================================
// Flow List
// ============================================================================
/**
 * Update list items in the sidebar with status icons and tooltips.
 * Uses FlowHealthStatus for a consistent user-facing status model.
 */
export function updateFlowListStatus() {
    const items = document.querySelectorAll(".flow-item");
    items.forEach(item => {
        const key = item.dataset.key;
        if (!key)
            return;
        const flowData = state.runStatus.flows?.[key];
        const healthStatus = getFlowHealthStatus(flowData);
        const meta = FLOW_STATUS_META[healthStatus];
        let iconEl = item.querySelector(".flow-status-icon");
        if (!iconEl) {
            iconEl = document.createElement("span");
            iconEl.className = "flow-status-icon";
            iconEl.setAttribute("aria-hidden", "true");
            item.insertBefore(iconEl, item.firstChild);
        }
        iconEl.textContent = meta.icon;
        iconEl.title = meta.tooltip;
    });
}
/**
 * Load flows and populate the flow list sidebar.
 */
export async function loadFlows() {
    const data = await Api.getFlows();
    const flows = data.flows || [];
    const listEl = document.getElementById("flow-list");
    if (!listEl)
        return flows;
    listEl.innerHTML = "";
    if (!flows.length) {
        listEl.innerHTML = renderNoFlows();
        return flows;
    }
    flows.forEach(flow => {
        const item = document.createElement("div");
        item.className = "flow-item";
        item.dataset.key = flow.key;
        // Initialize with "unknown" status (bullet dot + tooltip)
        const unknownMeta = FLOW_STATUS_META.unknown;
        const iconEl = document.createElement("span");
        iconEl.className = "flow-status-icon";
        iconEl.setAttribute("aria-hidden", "true");
        iconEl.textContent = unknownMeta.icon;
        iconEl.title = unknownMeta.tooltip;
        const content = document.createElement("div");
        content.className = "flow-item-content";
        const title = document.createElement("div");
        title.className = "flow-title";
        title.textContent = flow.title || flow.key;
        const sub = document.createElement("div");
        sub.className = "flow-sub";
        sub.textContent = `${flow.step_count} step(s)`;
        content.appendChild(title);
        content.appendChild(sub);
        item.appendChild(iconEl);
        item.appendChild(content);
        item.addEventListener("click", () => {
            setActiveFlow(flow.key);
        });
        listEl.appendChild(item);
    });
    // Update status icons if we have run data
    if (state.runStatus.flows) {
        updateFlowListStatus();
    }
    // Update governance badges if configured
    if (_updateFlowListGovernance) {
        _updateFlowListGovernance();
    }
    // Select the first flow by default
    if (flows.length) {
        await setActiveFlow(flows[0].key);
    }
    return flows;
}
/**
 * Mark active flow in sidebar and SDLC bar.
 */
export function markActiveFlow(flowKey) {
    // Update sidebar flow list
    document.querySelectorAll(".flow-item").forEach(el => {
        el.classList.toggle("active", el.dataset.key === flowKey);
    });
    // Update SDLC bar
    document.querySelectorAll(".sdlc-flow").forEach(el => {
        el.classList.toggle("active", el.dataset.key === flowKey);
    });
}
// ============================================================================
// Graph Status
// ============================================================================
/**
 * Update Cytoscape nodes with run status (step badges).
 */
export function updateGraphStatus() {
    if (!state.cy || !state.currentFlowKey || !state.runStatus.flows)
        return;
    const flowData = state.runStatus.flows[state.currentFlowKey];
    if (!flowData || !flowData.steps)
        return;
    // Update step nodes with status badges
    state.cy.nodes('[type = "step"]').forEach(node => {
        const stepId = node.data("step_id");
        if (!stepId)
            return;
        const stepData = flowData.steps[stepId];
        if (!stepData)
            return;
        const status = (stepData.status || "n/a");
        const icon = STATUS_ICONS[status] || "";
        const label = node.data("label");
        // Update label to include status icon
        if (!label.startsWith(icon)) {
            node.data("label", `${icon} ${label.replace(/^[\u2705\u26a0\ufe0f\u274c\u2014] /, "")}`);
        }
    });
}
// ============================================================================
// Teaching Mode Highlights
// ============================================================================
/**
 * Update Cytoscape nodes with teaching highlights.
 * When Teaching Mode is enabled, steps with teaching_highlight: true get
 * a visual emphasis (border color/style).
 *
 * @param detail - The flow detail containing step info with teaching_highlight
 */
export function updateGraphTeachingHighlights(detail) {
    if (!state.cy || !getTeachingMode())
        return;
    const stepsWithHighlight = new Set();
    (detail.steps || []).forEach((step) => {
        if (step.teaching_highlight) {
            stepsWithHighlight.add(step.id);
        }
    });
    // Apply teaching highlight style to marked steps
    state.cy.nodes('[type = "step"]').forEach(node => {
        const stepId = node.data("step_id");
        if (!stepId)
            return;
        if (stepsWithHighlight.has(stepId)) {
            // Add teaching highlight class - styled via Cytoscape
            node.addClass("teaching-highlight");
        }
        else {
            node.removeClass("teaching-highlight");
        }
    });
}
/**
 * Clear all teaching highlights from the graph.
 * Called when teaching mode is disabled.
 */
export function clearGraphTeachingHighlights() {
    if (!state.cy)
        return;
    state.cy.nodes('[type = "step"]').forEach(node => {
        node.removeClass("teaching-highlight");
    });
}
// ============================================================================
// Flow Selection and Graph Loading
// ============================================================================
/**
 * Load flow graph based on current view mode.
 */
async function loadFlowGraph(flowKey) {
    let graph;
    if (state.currentViewMode === "artifacts") {
        graph = await Api.getFlowGraphArtifacts(flowKey, state.currentRunId || undefined);
    }
    else {
        graph = await Api.getFlowGraphAgents(flowKey);
    }
    const detail = await Api.getFlowDetail(flowKey);
    // Render graph with node click handler
    renderGraphCore(graph, { onNodeClick: _onNodeClick || undefined });
    // Call flow details callback
    if (_onFlowDetails) {
        _onFlowDetails(detail);
    }
    // Update graph with run status after rendering
    if (state.runStatus.flows) {
        updateGraphStatus();
    }
    // Update teaching highlights if Teaching Mode is on
    updateGraphTeachingHighlights(detail);
    // Update semantic outline after graph render (for accessibility/LLM agents)
    renderFlowOutline();
}
/**
 * Set the active flow, load its graph + detail, and refresh status overlays.
 */
export async function setActiveFlow(flowKey, force = false) {
    if (state.currentFlowKey === flowKey && !force)
        return;
    state.currentFlowKey = flowKey;
    markActiveFlow(flowKey);
    // Update URL for shareable links
    if (_onURLUpdate) {
        _onURLUpdate();
    }
    // Load graph using view-mode-aware function
    await loadFlowGraph(flowKey);
}
// ============================================================================
// Refresh Helpers
// ============================================================================
/**
 * Refresh the current flow's graph (e.g., after view mode change).
 */
export async function refreshCurrentFlow() {
    if (state.currentFlowKey) {
        await loadFlowGraph(state.currentFlowKey);
    }
}
/**
 * Refresh all run-related state (run status, SDLC bar, flow list, graph).
 */
export async function refreshRunState() {
    await loadRunStatus();
    if (state.currentFlowKey) {
        await loadFlowGraph(state.currentFlowKey);
    }
}
// search.js
// swarm/tools/flow_studio_ui/src/search.ts
// Search functionality for Flow Studio
//
// This module handles:
// - Search input handling and debouncing
// - Search results rendering
// - Search result selection and navigation
import { state } from "./state.js";
import { Api } from "./api.js";
// ============================================================================
// Module configuration - callbacks set by consumer
// ============================================================================
let _setActiveFlow = null;
let _getCy = null;
/**
 * Configure callbacks for the search module.
 * Call this before using other functions to wire up navigation.
 */
export function configure(callbacks = {}) {
    if (callbacks.setActiveFlow)
        _setActiveFlow = callbacks.setActiveFlow;
    if (callbacks.getCy)
        _getCy = callbacks.getCy;
}
/**
 * Get the Cytoscape instance.
 */
function getCy() {
    if (_getCy && typeof _getCy === "function")
        return _getCy();
    return state.cy;
}
// ============================================================================
// Search Functions
// ============================================================================
/**
 * Perform search query against the API.
 */
export async function performSearch(query) {
    if (!query || query.length < 1) {
        closeSearchDropdown();
        return;
    }
    try {
        const data = await Api.search(query);
        state.searchResults = data.results || [];
        renderSearchResults(state.searchResults);
    }
    catch (err) {
        console.error("Search failed", err);
        closeSearchDropdown();
    }
}
/**
 * Render search results in the dropdown.
 */
export function renderSearchResults(results) {
    const dropdown = document.getElementById("search-dropdown");
    if (!dropdown)
        return;
    if (!results.length) {
        dropdown.innerHTML = '<div class="search-no-results">No results found</div>';
        dropdown.classList.add("open");
        return;
    }
    dropdown.innerHTML = results.map((r, idx) => {
        const typeClass = r.type;
        let label = r.label;
        if (r.type === "step") {
            label = r.flow + " / " + r.label;
        }
        else if (r.type === "artifact") {
            label = r.flow + " / " + (r.file || r.label);
        }
        return '<div class="search-result' + (idx === state.searchSelectedIndex ? ' selected' : '') + '" data-index="' + idx + '">' +
            '<span class="search-result-type ' + typeClass + '">' + r.type + '</span>' +
            '<span class="search-result-label">' + label + '</span>' +
            '</div>';
    }).join("");
    dropdown.classList.add("open");
    // Add click handlers
    dropdown.querySelectorAll(".search-result").forEach((el, idx) => {
        el.addEventListener("click", () => selectSearchResult(idx));
    });
}
/**
 * Close the search dropdown and reset state.
 */
export function closeSearchDropdown() {
    const dropdown = document.getElementById("search-dropdown");
    if (dropdown) {
        dropdown.classList.remove("open");
    }
    state.searchSelectedIndex = -1;
    state.searchResults = [];
}
/**
 * Select a search result by index and navigate to it.
 */
export async function selectSearchResult(index) {
    const result = state.searchResults[index];
    if (!result)
        return;
    closeSearchDropdown();
    const searchInput = document.getElementById("search-input");
    if (searchInput)
        searchInput.value = "";
    const cy = getCy();
    if (result.type === "flow") {
        if (_setActiveFlow)
            await _setActiveFlow(result.id);
    }
    else if (result.type === "step") {
        if (_setActiveFlow && result.flow) {
            await _setActiveFlow(result.flow);
            // Highlight the step node after graph renders
            setTimeout(() => {
                const currentCy = getCy();
                if (currentCy) {
                    const nodeId = "step:" + result.flow + ":" + result.id;
                    const node = currentCy.getElementById(nodeId);
                    if (node) {
                        currentCy.fit(50);
                        node.select();
                    }
                }
            }, 300);
        }
    }
    else if (result.type === "agent") {
        const targetFlow = result.flows && result.flows[0];
        if (targetFlow && _setActiveFlow) {
            await _setActiveFlow(targetFlow);
            setTimeout(() => {
                const currentCy = getCy();
                if (currentCy) {
                    const nodeId = "agent:" + (result.key || result.id);
                    const node = currentCy.getElementById(nodeId);
                    if (node) {
                        currentCy.fit(50);
                        node.select();
                    }
                }
            }, 300);
        }
    }
    else if (result.type === "artifact") {
        if (_setActiveFlow && result.flow)
            await _setActiveFlow(result.flow);
    }
}
/**
 * Initialize search input handlers.
 */
export function initSearchHandlers() {
    const searchInput = document.getElementById("search-input");
    const dropdown = document.getElementById("search-dropdown");
    if (!searchInput)
        return;
    searchInput.addEventListener("input", (e) => {
        if (state.searchDebounceTimer) {
            clearTimeout(state.searchDebounceTimer);
        }
        const target = e.target;
        const query = target.value.trim();
        state.searchDebounceTimer = setTimeout(() => performSearch(query), 200);
    });
    searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            closeSearchDropdown();
            searchInput.blur();
        }
        else if (e.key === "ArrowDown") {
            e.preventDefault();
            if (state.searchResults.length > 0) {
                state.searchSelectedIndex = Math.min(state.searchSelectedIndex + 1, state.searchResults.length - 1);
                renderSearchResults(state.searchResults);
            }
        }
        else if (e.key === "ArrowUp") {
            e.preventDefault();
            if (state.searchResults.length > 0) {
                state.searchSelectedIndex = Math.max(state.searchSelectedIndex - 1, 0);
                renderSearchResults(state.searchResults);
            }
        }
        else if (e.key === "Enter") {
            e.preventDefault();
            if (state.searchSelectedIndex >= 0) {
                selectSearchResult(state.searchSelectedIndex);
            }
            else if (state.searchResults.length > 0) {
                selectSearchResult(0);
            }
        }
    });
    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
        const target = e.target;
        if (!searchInput.contains(target) && dropdown && !dropdown.contains(target)) {
            closeSearchDropdown();
        }
    });
}
/**
 * Focus the search input.
 */
export function focusSearch() {
    const searchInput = document.getElementById("search-input");
    if (searchInput)
        searchInput.focus();
}
// selection.js
// swarm/tools/flow_studio_ui/src/selection.ts
// Unified selection management for Flow Studio
//
// This module provides a single entry point for all selection operations:
// - Graph node clicks
// - Search result selection
// - Keyboard navigation
// - Tour step navigation
// - URL deep links
//
// All paths go through selectNode() to ensure consistent behavior.
import { state, setSelectedNode, clearSelectedNode } from "./state.js";
let _callbacks = {};
/**
 * Configure callbacks for the selection module.
 */
export function configure(callbacks) {
    _callbacks = { ..._callbacks, ...callbacks };
}
// ============================================================================
// Unified Selection
// ============================================================================
/**
 * Select a node by ID. This is the single entry point for all selection.
 *
 * Handles:
 * - Updating state.selectedNodeId
 * - Selecting the Cytoscape node (if graph is ready)
 * - Showing the appropriate details panel
 * - Updating the URL for deep linking
 * - Updating the outline tree selection
 *
 * @param nodeId - Full node ID (e.g., "step:build:1", "agent:code-implementer")
 * @param options - Configuration for selection behavior
 */
export async function selectNode(nodeId, options = {}) {
    const { flowKey, forceFlowSwitch = false, skipUrlUpdate = false, fitGraph = true, nodeData } = options;
    // Handle null selection (clear)
    if (!nodeId) {
        clearSelectedNode();
        if (_callbacks.showEmptyState) {
            _callbacks.showEmptyState();
        }
        if (_callbacks.updateURL && !skipUrlUpdate) {
            _callbacks.updateURL();
        }
        return;
    }
    // Switch flow if needed
    if (flowKey && _callbacks.setActiveFlow) {
        if (flowKey !== state.currentFlowKey || forceFlowSwitch) {
            await _callbacks.setActiveFlow(flowKey, forceFlowSwitch);
            // Wait for graph to render
            await waitForGraph(300);
        }
    }
    // Get node data
    let data = nodeData;
    if (!data && state.cy) {
        const node = state.cy.getElementById(nodeId);
        if (node && typeof node.data === "function") {
            data = node.data();
        }
    }
    if (!data) {
        console.warn(`selectNode: Could not find node data for ${nodeId}`);
        return;
    }
    // Update state
    setSelectedNode(nodeId, data.type);
    // Select in Cytoscape graph
    if (state.cy) {
        const node = state.cy.getElementById(nodeId);
        if (node) {
            if (fitGraph) {
                state.cy.fit(50);
            }
            node.select();
        }
    }
    // Show details panel
    showNodeDetails(data);
    // Update URL
    if (_callbacks.updateURL && !skipUrlUpdate) {
        _callbacks.updateURL();
    }
    // Update outline selection
    if (_callbacks.updateOutlineSelection) {
        _callbacks.updateOutlineSelection(nodeId);
    }
}
/**
 * Select a step by flow key and step ID.
 * Convenience method for common use case.
 */
export async function selectStep(flowKey, stepId, options = {}) {
    const nodeId = `step:${flowKey}:${stepId}`;
    await selectNode(nodeId, {
        flowKey,
        ...options
    });
}
/**
 * Select an agent by key.
 * Optionally specify a flow to show the agent in.
 */
export async function selectAgent(agentKey, flowKey, options = {}) {
    const nodeId = `agent:${agentKey}`;
    await selectNode(nodeId, {
        flowKey,
        ...options
    });
}
/**
 * Clear the current selection.
 */
export function clearSelection() {
    clearSelectedNode();
    if (state.cy) {
        state.cy.elements().forEach(ele => {
            if (typeof ele.unselect === "function") {
                ele.unselect();
            }
        });
    }
    if (_callbacks.showEmptyState) {
        _callbacks.showEmptyState();
    }
    if (_callbacks.updateURL) {
        _callbacks.updateURL();
    }
}
// ============================================================================
// Helpers
// ============================================================================
/**
 * Show the appropriate details panel for a node.
 */
function showNodeDetails(data) {
    if (data.type === "step" && _callbacks.showStepDetails) {
        _callbacks.showStepDetails(data);
        // Notify about step selection for inventory counts delta display
        if (_callbacks.onStepSelected && data.flow && data.step_id) {
            _callbacks.onStepSelected(data.flow, data.step_id);
        }
    }
    else if (data.type === "agent" && _callbacks.showAgentDetails) {
        _callbacks.showAgentDetails(data);
        // Clear step selection when switching to agent
        if (_callbacks.onStepSelected) {
            _callbacks.onStepSelected(null, null);
        }
    }
    else if (data.type === "artifact" && _callbacks.showArtifactDetails) {
        _callbacks.showArtifactDetails(data);
        // Clear step selection when switching to artifact
        if (_callbacks.onStepSelected) {
            _callbacks.onStepSelected(null, null);
        }
    }
}
/**
 * Wait for the graph to be ready after a flow switch.
 */
function waitForGraph(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
/**
 * Parse a step query param into flow key and step ID.
 * Format: "flow:stepId" or just "stepId" (uses current flow)
 */
export function parseStepParam(stepParam) {
    if (stepParam.includes(":")) {
        const [flowKey, stepId] = stepParam.split(":", 2);
        return { flowKey: flowKey, stepId };
    }
    return { stepId: stepParam };
}
/**
 * Get the current selection info for URL serialization.
 */
export function getSelectionForUrl() {
    if (!state.selectedNodeId || !state.selectedNodeType) {
        return {};
    }
    if (state.selectedNodeType === "step") {
        // Extract step ID from "step:flow:stepId"
        const parts = state.selectedNodeId.split(":");
        if (parts.length >= 3) {
            return { step: parts.slice(2).join(":") };
        }
    }
    else if (state.selectedNodeType === "agent") {
        // Extract agent key from "agent:key"
        const parts = state.selectedNodeId.split(":");
        if (parts.length >= 2) {
            return { agent: parts.slice(1).join(":") };
        }
    }
    return {};
}
// selftest_ui.js
// swarm/tools/flow_studio_ui/src/selftest_ui.ts
// Selftest modal UI for Flow Studio
//
// This module handles:
// - Selftest plan caching and loading
// - Selftest modal rendering and interactions
// - Individual step detail modals
// - Copy-to-clipboard helpers
import { state } from "./state.js";
import { Api } from "./api.js";
import { escapeHtml, copyToClipboard, createModalFocusManager } from "./utils.js";
// ============================================================================
// Selftest Plan Caching
// ============================================================================
/**
 * Fetch and cache selftest plan.
 */
export async function getSelftestPlan() {
    if (state.selftestPlanCache)
        return state.selftestPlanCache;
    try {
        const plan = await Api.getSelftestPlan();
        state.selftestPlanCache = plan;
        return plan;
    }
    catch (err) {
        console.error("Failed to load selftest plan", err);
        return null;
    }
}
// ============================================================================
// Modal Visibility
// ============================================================================
// Focus manager for the selftest modal
let selftestFocusManager = null;
/**
 * Toggle selftest modal visibility with focus management.
 */
export function toggleSelftestModal(show) {
    const modal = document.getElementById("selftest-modal");
    if (!modal)
        return;
    // Lazy-init focus manager
    if (!selftestFocusManager) {
        selftestFocusManager = createModalFocusManager(modal, ".selftest-step-content");
    }
    if (show) {
        modal.classList.add("open");
        selftestFocusManager.open(document.activeElement);
    }
    else {
        modal.classList.remove("open");
        selftestFocusManager.close();
    }
}
/**
 * Initialize selftest modal close on backdrop click and keyboard handling.
 */
export function initSelftestModal() {
    const modal = document.getElementById("selftest-modal");
    if (!modal)
        return;
    modal.addEventListener("click", (e) => {
        if (e.target === modal) {
            toggleSelftestModal(false);
        }
    });
    modal.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            e.preventDefault();
            toggleSelftestModal(false);
        }
    });
}
// ============================================================================
// Copy Helpers
// ============================================================================
/**
 * Show copy success feedback with toast.
 */
export function showCopyFeedback(message) {
    const feedback = document.createElement("div");
    feedback.style.cssText = `
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: #10b981;
    color: white;
    padding: 12px 16px;
    border-radius: 6px;
    font-size: 14px;
    z-index: 3000;
    opacity: 0;
    animation: fadeInOut 2s ease-in-out;
  `;
    feedback.textContent = message;
    document.body.appendChild(feedback);
    setTimeout(() => feedback.remove(), 2000);
}
/**
 * Show copy fallback box (for clipboard API unavailable).
 */
export function showCopyFallback(text, message) {
    const box = document.createElement("div");
    box.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
    z-index: 3001;
    max-width: 500px;
    text-align: center;
  `;
    box.innerHTML = `
    <p style="margin: 0 0 12px 0; color: #374151; font-size: 14px;">${escapeHtml(message)}</p>
    <div style="background: #f3f4f6; padding: 12px; border-radius: 4px; margin-bottom: 12px; text-align: left; overflow-x: auto;">
      <code class="fs-text-body" style="font-family: monospace; color: #111827;">${escapeHtml(text)}</code>
    </div>
    <p class="fs-text-body fs-text-muted" style="margin: 0 0 8px 0;">Use Ctrl+C to copy</p>
    <button class="fs-text-body" onclick="this.parentElement.parentElement.remove()" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">Close</button>
  `;
    document.body.appendChild(box);
}
/**
 * Copy command and show instructions.
 */
export function copyAndRun(cmd) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(cmd).then(() => {
            showCopyFeedback(`Copied! Run in terminal: ${cmd}`);
        }).catch(() => {
            showCopyFallback(cmd, "Copy this command and run it in your terminal:");
        });
    }
    else {
        showCopyFallback(cmd, "Copy this command and run it in your terminal:");
    }
}
// ============================================================================
// Selftest Step Modal
// ============================================================================
/**
 * Show selftest step details in modal.
 */
export async function showSelftestStepModal(stepId) {
    const plan = await getSelftestPlan();
    if (!plan) {
        renderSelftestPlanError("Selftest plan not available", "Run this command to generate the plan:\n\nuv run swarm/tools/selftest.py --plan --json");
        toggleSelftestModal(true);
        return;
    }
    const step = plan.steps.find(s => s.id === stepId);
    if (!step) {
        renderSelftestPlanError("Step not found", `Step "${stepId}" is not available in the selftest plan.`);
        toggleSelftestModal(true);
        return;
    }
    renderSelftestStepModal(step);
    toggleSelftestModal(true);
}
/**
 * Render error state in selftest modal.
 */
export function renderSelftestPlanError(title, message) {
    const body = document.getElementById("selftest-modal-body");
    if (!body)
        return;
    body.innerHTML = `
    <div style="padding: 24px; text-align: center;">
      <div style="font-size: 32px; margin-bottom: 12px;">\u26a0\ufe0f</div>
      <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #dc2626;">${escapeHtml(title)}</h3>
      <p class="fs-text-muted" style="margin: 0 0 16px 0; font-size: 13px; line-height: 1.6;">${escapeHtml(message)}</p>
      <div style="background: #fef2f2; padding: 12px; border-left: 3px solid #dc2626; border-radius: 4px; margin: 12px 0; text-align: left;">
        <code class="fs-mono-sm" style="display: block; padding: 8px; white-space: pre-wrap; word-break: break-all; color: #7f1d1d;">uv run swarm/tools/selftest.py --plan --json</code>
      </div>
    </div>
  `;
}
/**
 * Render the selftest step explanation modal.
 */
export function renderSelftestStepModal(step) {
    const body = document.getElementById("selftest-modal-body");
    if (!body)
        return;
    const tierClass = (step.tier || "optional").toLowerCase();
    const tierLabel = (step.tier || "optional").toUpperCase();
    // Tier tooltip descriptions
    const tierTooltips = {
        kernel: "Core repository health - blocking if failed",
        governance: "Swarm contracts - can be degraded but should be reviewed",
        optional: "Code quality checks - informational only"
    };
    const tierTooltip = tierTooltips[tierClass] || tierTooltips.optional;
    let depsHtml = "";
    if (step.depends_on && step.depends_on.length > 0) {
        depsHtml = `
      <div class="selftest-dependencies">
        <div class="selftest-dependencies-title">\u23f3 Depends on:</div>
        <div class="selftest-dependencies-list">
          ${step.depends_on.map(dep => `<div class="selftest-dep-badge">${escapeHtml(dep)}</div>`).join("")}
        </div>
      </div>
    `;
    }
    let acHtml = "";
    if (step.ac_ids && step.ac_ids.length > 0) {
        const tierColorClassMap = {
            kernel: "critical",
            governance: "warning",
            optional: "pass"
        };
        const tierColorClass = tierColorClassMap[tierClass] || "pass";
        acHtml = `
      <div class="selftest-ac-container">
        <span class="selftest-ac-label">\ud83d\udccb Acceptance Criteria</span>
        <div class="selftest-ac-badges">
          ${step.ac_ids.map(ac => `<div class="selftest-ac-badge ${tierColorClass}" title="${escapeHtml(ac)} (Tier: ${step.tier || 'OPTIONAL'})">${escapeHtml(ac)}</div>`).join("")}
        </div>
      </div>
    `;
    }
    const commands = [
        `uv run swarm/tools/selftest.py --step ${step.id}`,
        `uv run swarm/tools/selftest.py --plan | grep -A 5 "${step.id}"`
    ];
    const commandsHtml = `
    <div class="selftest-commands">
      <div class="selftest-commands-title">\ud83d\udcbb Run this step:</div>
      ${commands.map(cmd => `
        <div class="selftest-command">
          <span class="fs-text-xs" style="flex: 1;">${escapeHtml(cmd)}</span>
          <button class="selftest-command-copy-btn" onclick="window.copyToClipboard && window.copyToClipboard('${escapeHtml(cmd).replace(/'/g, "\\'")}')" title="Copy">\ud83d\udccb</button>
        </div>
      `).join("")}
    </div>
  `;
    const failedSteps = state.governanceStatus?.governance?.selftest?.failed_steps || [];
    const degradedSteps = state.governanceStatus?.governance?.selftest?.degraded_steps || [];
    const isFailed = failedSteps.includes(step.id);
    const isDegraded = degradedSteps.includes(step.id);
    let statusBadge = '';
    if (isFailed) {
        statusBadge = '<div class="fs-text-xs" style="padding: 3px 8px; background: #fee2e2; color: #991b1b; border-radius: 3px; font-weight: 600;" title="This step failed. Issues must be resolved before merging.">\u274c FAILED</div>';
    }
    else if (isDegraded) {
        statusBadge = '<div class="fs-text-xs" style="padding: 3px 8px; background: #fef3c7; color: #92400e; border-radius: 3px; font-weight: 600;" title="This step has non-blocking issues. Work can proceed but review recommended.">\u26a0\ufe0f DEGRADED</div>';
    }
    else {
        statusBadge = '<div class="fs-text-xs" style="padding: 3px 8px; background: #dcfce7; color: #14532d; border-radius: 3px; font-weight: 600;" title="This step passed all checks.">\u2705 PASS</div>';
    }
    body.innerHTML = `
    <div class="selftest-step-header" style="flex-wrap: wrap;">
      <div class="selftest-step-id">${escapeHtml(step.id)}</div>
      <div class="selftest-step-tier-badge ${tierClass}" title="${tierTooltip}">${tierLabel}</div>
      ${statusBadge}
    </div>

    <h3 class="selftest-step-title">${escapeHtml(step.description || step.id)}</h3>

    <div class="selftest-step-metadata">
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Tier</div>
        <div class="selftest-metadata-value">${tierLabel}</div>
      </div>
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Category</div>
        <div class="selftest-metadata-value">${escapeHtml(step.category || "\u2014")}</div>
      </div>
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Severity</div>
        <div class="selftest-metadata-value">${escapeHtml(step.severity || "\u2014")}</div>
      </div>
    </div>

    ${acHtml}
    ${depsHtml}
    ${commandsHtml}

    <div class="fs-text-body fs-text-muted" style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #e5e7eb;">
      <strong>Learn more:</strong> See <code style="background: #f3f4f6; padding: 2px 4px; border-radius: 3px;">docs/SELFTEST_SYSTEM.md</code> for detailed information.
    </div>
  `;
}
// ============================================================================
// Selftest Tab Rendering
// ============================================================================
/**
 * Render selftest plan in a tab container.
 */
export async function renderSelftestTab(container) {
    const plan = await getSelftestPlan();
    if (!plan) {
        container.innerHTML = '<div class="muted" style="padding: 8px;">Failed to load selftest plan. Try running: <code>make selftest --plan</code></div>';
        return;
    }
    const summary = plan.summary || { total: 0, by_tier: { kernel: 0, governance: 0, optional: 0 } };
    const html = `
    <div class="kv-label">Selftest Summary</div>
    <div class="fs-text-body" style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
      <div>
        <div class="muted fs-text-sm" style="margin-bottom: 2px;">Total Steps</div>
        <div style="font-size: 14px; font-weight: 600;">${summary.total || 0}</div>
      </div>
      <div>
        <div class="muted fs-text-sm" style="margin-bottom: 2px;">Kernel Steps</div>
        <div style="font-size: 14px; font-weight: 600;">${summary.by_tier?.kernel || 0}</div>
      </div>
    </div>

    <div class="kv-label">View Selftest Plan</div>
    <button class="fs-text-body" onclick="window.showSelftestPlanModal && window.showSelftestPlanModal()" style="padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; margin-bottom: 12px;">
      \ud83d\udccb View Full Plan
    </button>

    <div class="kv-label">Quick Commands</div>
    <div style="display: flex; flex-direction: column; gap: 6px;">
      <button class="fs-mono-sm" onclick="window.copyAndRun && window.copyAndRun('uv run swarm/tools/selftest.py --plan')" style="padding: 6px 10px; text-align: left; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 4px; cursor: pointer;">
        Show plan
      </button>
      <button class="fs-mono-sm" onclick="window.copyAndRun && window.copyAndRun('uv run swarm/tools/selftest.py')" style="padding: 6px 10px; text-align: left; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 4px; cursor: pointer;">
        Run selftest
      </button>
    </div>
  `;
    container.innerHTML = html;
}
// ============================================================================
// Full Selftest Plan Modal
// ============================================================================
/**
 * Show full selftest plan in modal.
 */
export async function showSelftestPlanModal() {
    const plan = await getSelftestPlan();
    if (!plan) {
        alert("Failed to load selftest plan");
        return;
    }
    const body = document.getElementById("selftest-modal-body");
    if (!body)
        return;
    const tierColors = { kernel: '#dc2626', governance: '#f59e0b', optional: '#3b82f6' };
    // Tier tooltip descriptions for the plan list
    const tierTooltips = {
        kernel: "Core repository health - blocking if failed",
        governance: "Swarm contracts - can be degraded but should be reviewed",
        optional: "Code quality checks - informational only"
    };
    const html = `
    <h3 style="margin: 0 0 16px 0; font-size: 16px; font-weight: 600;">Selftest Plan</h3>
    <div class="fs-text-sm fs-text-muted" style="margin-bottom: 12px;">
      Total: <strong>${plan.summary?.total || 0}</strong> |
      Kernel: <strong>${plan.summary?.by_tier?.kernel || 0}</strong> |
      Governance: <strong>${plan.summary?.by_tier?.governance || 0}</strong> |
      Optional: <strong>${plan.summary?.by_tier?.optional || 0}</strong>
    </div>

    <div class="fs-text-sm" style="margin: 12px 0; padding: 12px; background: #f9fafb; border-radius: 6px;">
      <div style="font-weight: 600; margin-bottom: 8px;">How to read selftest results</div>
      <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px;">
        <span title="This step passed all checks.">PASS</span><span>All checks passed</span>
        <span title="This step has non-blocking issues. Work can proceed but review recommended.">DEGRADED</span><span>Non-blocking issues - proceed with caution</span>
        <span title="This step failed. Issues must be resolved before merging.">FAIL</span><span>Blocking failures - must be resolved</span>
      </div>
      <div class="fs-text-muted" style="margin-top: 8px;">
        Tiers: <strong title="Core repository health - blocking if failed">KERNEL</strong> (blocking) &rarr; <strong title="Swarm contracts - can be degraded but should be reviewed">GOVERNANCE</strong> (important) &rarr; <strong title="Code quality checks - informational only">OPTIONAL</strong> (informational)
      </div>
    </div>

    <div class="selftest-plan-list">
      ${(plan.steps || []).map(step => {
        const tierClass = (step.tier || 'optional').toLowerCase();
        const tierLabel = (step.tier || 'OPTIONAL').toUpperCase();
        const tierColor = tierColors[tierClass] || '#6b7280';
        const tierTooltip = tierTooltips[tierClass] || tierTooltips.optional;
        const failedSteps = state.governanceStatus?.governance?.selftest?.failed_steps || [];
        const degradedSteps = state.governanceStatus?.governance?.selftest?.degraded_steps || [];
        const isFailed = failedSteps.includes(step.id);
        const isDegraded = degradedSteps.includes(step.id);
        const statusIcon = isFailed ? '\u274c' : isDegraded ? '\u26a0\ufe0f' : '\u2705';
        const statusText = isFailed ? 'FAIL' : isDegraded ? 'DEGRADED' : 'PASS';
        const statusTooltip = isFailed
            ? 'This step failed. Issues must be resolved before merging.'
            : isDegraded
                ? 'This step has non-blocking issues. Work can proceed but review recommended.'
                : 'This step passed all checks.';
        return `
          <div class="selftest-plan-item ${tierClass}" onclick="window.showSelftestStepModal && window.showSelftestStepModal('${escapeHtml(step.id)}')" style="${isFailed ? 'background: #fee;' : isDegraded ? 'background: #fff3cd;' : ''}">
            <div class="selftest-plan-item-row">
              <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                <span style="font-size: 14px;" title="${statusTooltip}">${statusIcon}</span>
                <div style="flex: 1;">
                  <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 2px;">
                    <span class="selftest-plan-item-id">${escapeHtml(step.id)}</span>
                    <span class="selftest-step-tier-badge ${tierClass}" style="font-size: 8px; padding: 2px 4px;" title="${tierTooltip}">${tierLabel}</span>
                    <span style="font-size: 9px; color: #6b7280;" title="${statusTooltip}">${statusText}</span>
                  </div>
                  <div class="selftest-plan-item-desc fs-text-sm" style="color: #374151;">${escapeHtml(step.description || '')}</div>
                </div>
              </div>
              <div class="selftest-plan-item-icon">\u2192</div>
            </div>
          </div>
        `;
    }).join("")}
    </div>
  `;
    body.innerHTML = html;
    toggleSelftestModal(true);
}
// ============================================================================
// Window Exports (for onclick handlers in HTML)
// ============================================================================
if (typeof window !== "undefined") {
    window.copyAndRun = copyAndRun;
    window.showSelftestPlanModal = showSelftestPlanModal;
    window.showSelftestStepModal = showSelftestStepModal;
    window.toggleSelftestModal = toggleSelftestModal;
}
// shortcuts.js
// swarm/tools/flow_studio_ui/src/shortcuts.ts
// Keyboard shortcuts for Flow Studio
//
// This module handles:
// - Global keyboard shortcuts (1-6 for flows, / for search, ? for help)
// - Arrow key navigation between steps
// - Shortcuts help modal
import { state, FLOW_KEYS } from "./state.js";
import { closeSearchDropdown, focusSearch } from "./search.js";
import { createModalFocusManager } from "./utils.js";
// ============================================================================
// Module configuration - callbacks set by consumer
// ============================================================================
let _setActiveFlow = null;
let _showStepDetails = null;
let _toggleSelftestModal = null;
/**
 * Configure callbacks for the shortcuts module.
 */
export function configure(callbacks = {}) {
    if (callbacks.setActiveFlow)
        _setActiveFlow = callbacks.setActiveFlow;
    if (callbacks.showStepDetails)
        _showStepDetails = callbacks.showStepDetails;
    if (callbacks.toggleSelftestModal)
        _toggleSelftestModal = callbacks.toggleSelftestModal;
}
// ============================================================================
// Shortcuts Modal
// ============================================================================
// Focus manager for the shortcuts modal
let shortcutsFocusManager = null;
/**
 * Toggle the keyboard shortcuts help modal with focus management.
 */
export function toggleShortcutsModal(show) {
    const modal = document.getElementById("shortcuts-modal");
    if (!modal)
        return;
    // Lazy-init focus manager
    if (!shortcutsFocusManager) {
        shortcutsFocusManager = createModalFocusManager(modal, ".shortcuts-content");
    }
    if (show) {
        modal.classList.add("open");
        shortcutsFocusManager.open(document.activeElement);
    }
    else {
        modal.classList.remove("open");
        shortcutsFocusManager.close();
    }
}
/**
 * Initialize shortcuts modal close on backdrop click and ESC key.
 */
export function initShortcutsModal() {
    const modal = document.getElementById("shortcuts-modal");
    if (!modal)
        return;
    // Close on backdrop click
    modal.addEventListener("click", (e) => {
        if (e.target === modal) {
            toggleShortcutsModal(false);
        }
    });
    // Close on ESC key within the modal
    modal.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            e.preventDefault();
            e.stopPropagation();
            toggleShortcutsModal(false);
        }
    });
}
// ============================================================================
// Keyboard Shortcuts Handler
// ============================================================================
/**
 * Initialize global keyboard shortcuts.
 */
export function initKeyboardShortcuts() {
    document.addEventListener("keydown", (e) => {
        // Don't trigger shortcuts when typing in input
        const activeEl = document.activeElement;
        if (activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA")) {
            return;
        }
        // / - Focus search
        if (e.key === "/") {
            e.preventDefault();
            focusSearch();
        }
        // ? - Show shortcuts modal
        else if (e.key === "?" || (e.shiftKey && e.key === "/")) {
            e.preventDefault();
            toggleShortcutsModal(true);
        }
        // Escape - Close modals/dropdowns
        else if (e.key === "Escape") {
            closeSearchDropdown();
            toggleShortcutsModal(false);
            if (_toggleSelftestModal)
                _toggleSelftestModal(false);
        }
        // 1-6 - Jump to flows
        else if (e.key >= "1" && e.key <= "6") {
            const flowIndex = parseInt(e.key) - 1;
            if (FLOW_KEYS[flowIndex] && _setActiveFlow) {
                _setActiveFlow(FLOW_KEYS[flowIndex]);
                state.currentStepIndex = -1;
            }
        }
        // Arrow keys - navigate steps
        else if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
            if (!state.currentFlowKey || !state.cy)
                return;
            const stepNodes = state.cy.nodes('[type = "step"]').sort((a, b) => {
                const orderA = a.data("order");
                const orderB = b.data("order");
                return orderA - orderB;
            });
            if (stepNodes.length === 0)
                return;
            if (e.key === "ArrowRight") {
                state.currentStepIndex = Math.min(state.currentStepIndex + 1, stepNodes.length - 1);
            }
            else {
                state.currentStepIndex = Math.max(state.currentStepIndex - 1, 0);
            }
            const targetNode = stepNodes[state.currentStepIndex];
            if (targetNode) {
                state.cy.fit(50);
                targetNode.select();
                if (_showStepDetails) {
                    _showStepDetails(targetNode.data());
                }
            }
        }
    });
}
// state.js
// swarm/tools/flow_studio_ui/src/state.ts
// Centralized state management for Flow Studio
/**
 * Application state object. All mutable state lives here.
 */
export const state = {
    // Cytoscape graph instance
    cy: null,
    // Current selection state
    currentFlowKey: null,
    currentRunId: null,
    compareRunId: null,
    // Node selection (unified selection model)
    selectedNodeId: null,
    selectedNodeType: null,
    // Cached data from API
    runStatus: {}, // /api/runs/:id/summary
    comparisonData: null, // /api/runs/compare
    availableRuns: [], // /api/runs list
    // Governance state
    governanceStatus: null,
    validationData: null,
    governanceOverlayEnabled: false,
    // UI mode state
    currentMode: "author", // "author" | "operator"
    currentViewMode: "agents", // "agents" | "artifacts"
    // Search state
    searchDebounceTimer: null,
    searchSelectedIndex: -1,
    searchResults: [],
    // Navigation state
    currentStepIndex: -1,
    // Selftest state
    selftestPlan: null,
    selftestPlanCache: null
};
/**
 * Status icons used throughout the app
 */
export const STATUS_ICONS = {
    done: "\u2705", // Green checkmark
    in_progress: "\u23f3", // Hourglass
    not_started: "\u2014", // Em dash
    complete: "\u2705",
    partial: "\u26a0\ufe0f", // Warning
    missing: "\u274c", // Red X
    "n/a": "\u2014"
};
/**
 * Flow health status metadata for sidebar display.
 * Maps FlowHealthStatus to icon and tooltip text.
 */
export const FLOW_STATUS_META = {
    ok: {
        icon: "\u2705", // Green checkmark
        tooltip: "All required checks passed for this flow.",
    },
    warning: {
        icon: "\u26a0\ufe0f", // Warning sign
        tooltip: "Some non-blocking checks failed or artifacts are missing.",
    },
    error: {
        icon: "\u274c", // Red X
        tooltip: "Blocking failures or required artifacts are missing.",
    },
    unknown: {
        icon: "\u2022", // Bullet dot
        tooltip: "No run data for this flow.",
    },
};
/**
 * Flow key order - re-exported from generated constants
 */
export { FLOW_KEYS } from "./flow_constants.js";
// ============================================================================
// State setters (optional helpers for common operations)
// ============================================================================
/**
 * Set the current UI mode
 */
export function setMode(mode) {
    state.currentMode = mode;
}
/**
 * Set the current view mode
 */
export function setViewMode(view) {
    state.currentViewMode = view;
}
/**
 * Set the current run ID
 */
export function setCurrentRun(runId) {
    state.currentRunId = runId;
}
/**
 * Set the current flow key
 */
export function setCurrentFlow(flowKey) {
    state.currentFlowKey = flowKey;
}
/**
 * Set the comparison run ID
 */
export function setCompareRun(runId) {
    state.compareRunId = runId;
}
/**
 * Toggle the governance overlay
 */
export function setGovernanceOverlay(enabled) {
    state.governanceOverlayEnabled = enabled;
}
/**
 * Set the selected node
 */
export function setSelectedNode(nodeId, nodeType) {
    state.selectedNodeId = nodeId;
    state.selectedNodeType = nodeType;
}
/**
 * Clear the selected node
 */
export function clearSelectedNode() {
    state.selectedNodeId = null;
    state.selectedNodeType = null;
}
// tours.js
// swarm/tools/flow_studio_ui/src/tours.ts
// Tour system for Flow Studio
//
// This module handles:
// - Loading and displaying available tours
// - Tour navigation (prev/next/exit)
// - Flow and step highlighting during tours
import { state } from "./state.js";
import { Api } from "./api.js";
// ============================================================================
// Tour State
// ============================================================================
let currentTour = null;
let currentTourStep = 0;
let availableTours = [];
// ============================================================================
// Module configuration - callbacks set by consumer
// ============================================================================
let _setActiveFlow = null;
/**
 * Configure callbacks for the tours module.
 */
export function configure(callbacks = {}) {
    if (callbacks.setActiveFlow)
        _setActiveFlow = callbacks.setActiveFlow;
}
// ============================================================================
// Tour Loading
// ============================================================================
/**
 * Load available tours from API.
 */
export async function loadTours() {
    try {
        const data = await Api.getTours();
        availableTours = data.tours || [];
        renderTourMenu();
    }
    catch (err) {
        console.error("Failed to load tours", err);
        availableTours = [];
    }
}
/**
 * Render the tour dropdown menu.
 */
export function renderTourMenu() {
    const menu = document.getElementById("tour-menu");
    if (!menu)
        return;
    menu.innerHTML = `
    <div class="tour-menu-item" data-tour="">
      <div class="tour-menu-title">No tour</div>
      <div class="tour-menu-desc">Exit current tour</div>
    </div>
  `;
    availableTours.forEach(tour => {
        const item = document.createElement("div");
        item.className = "tour-menu-item";
        item.dataset.tour = tour.id;
        item.innerHTML = `
      <div class="tour-menu-title">${tour.title}</div>
      <div class="tour-menu-desc">${tour.description || ""}</div>
    `;
        menu.appendChild(item);
    });
    // Add click handlers
    menu.querySelectorAll(".tour-menu-item").forEach(item => {
        item.addEventListener("click", () => {
            const tourId = item.dataset.tour;
            if (tourId) {
                startTour(tourId);
            }
            else {
                exitTour();
            }
            closeMenu();
        });
    });
}
// ============================================================================
// Tour Navigation
// ============================================================================
/**
 * Start a tour by ID.
 */
export async function startTour(tourId) {
    try {
        const data = await Api.getTourById(tourId);
        currentTour = data;
        currentTourStep = 0;
        showTourStep();
        updateTourButton(true);
    }
    catch (err) {
        console.error("Failed to start tour", err);
    }
}
/**
 * Exit the current tour.
 */
export function exitTour() {
    currentTour = null;
    currentTourStep = 0;
    hideTourCard();
    clearTourHighlight();
    updateTourButton(false);
}
/**
 * Show the current tour step.
 */
export function showTourStep() {
    if (!currentTour || !currentTour.steps || currentTourStep >= currentTour.steps.length) {
        exitTour();
        return;
    }
    const step = currentTour.steps[currentTourStep];
    const total = currentTour.steps.length;
    // Update card content
    const stepNumber = document.getElementById("tour-step-number");
    const cardTitle = document.getElementById("tour-card-title");
    const cardText = document.getElementById("tour-card-text");
    if (stepNumber)
        stepNumber.textContent = `Step ${currentTourStep + 1} of ${total}`;
    if (cardTitle)
        cardTitle.textContent = step.title;
    if (cardText)
        cardText.textContent = step.text;
    // Update navigation buttons
    const prevBtn = document.getElementById("tour-prev-btn");
    const nextBtn = document.getElementById("tour-next-btn");
    if (prevBtn)
        prevBtn.disabled = currentTourStep === 0;
    if (nextBtn)
        nextBtn.textContent = currentTourStep === total - 1 ? "Finish" : "Next \u2192";
    // Show tour card
    const tourCard = document.getElementById("tour-card");
    if (tourCard)
        tourCard.style.display = "block";
    // Execute the tour action (select flow or step)
    executeTourAction(step);
}
/**
 * Execute tour action (navigate to flow/step).
 */
async function executeTourAction(step) {
    const target = step.target;
    if (target.type === "flow") {
        // Select the flow
        if (_setActiveFlow)
            await _setActiveFlow(target.flow);
        highlightFlow(target.flow);
    }
    else if (target.type === "step") {
        // First select the flow, then highlight the step
        if (_setActiveFlow)
            await _setActiveFlow(target.flow);
        if (target.step) {
            highlightStep(target.flow, target.step);
        }
    }
}
/**
 * Go to next tour step.
 */
export function nextTourStep() {
    if (currentTour && currentTourStep < currentTour.steps.length - 1) {
        currentTourStep++;
        showTourStep();
    }
    else {
        exitTour();
    }
}
/**
 * Go to previous tour step.
 */
export function prevTourStep() {
    if (currentTourStep > 0) {
        currentTourStep--;
        showTourStep();
    }
}
// ============================================================================
// Highlighting
// ============================================================================
/**
 * Highlight a flow in the sidebar and SDLC bar.
 */
export function highlightFlow(flowKey) {
    clearTourHighlight();
    // Highlight in sidebar
    const flowItem = document.querySelector(`.flow-item[data-key="${flowKey}"]`);
    if (flowItem) {
        flowItem.classList.add("tour-highlight");
    }
    // Highlight in SDLC bar
    const sdlcItem = document.querySelector(`.sdlc-flow[data-key="${flowKey}"]`);
    if (sdlcItem) {
        sdlcItem.classList.add("tour-highlight");
    }
}
/**
 * Highlight a step in the graph.
 */
export function highlightStep(flowKey, stepId) {
    clearTourHighlight();
    if (state.cy) {
        // Dim all nodes first
        state.cy.nodes().forEach(node => {
            // Use class manipulation through the element
            node.addClass("tour-dimmed");
        });
        // Highlight the target step
        const nodeId = `step:${flowKey}:${stepId}`;
        const node = state.cy.getElementById(nodeId);
        if (node) {
            node.removeClass("tour-dimmed");
            node.addClass("tour-highlight");
            // Also highlight connected agents
            const connectedEdges = node.connectedEdges();
            connectedEdges.connectedNodes().forEach((n) => {
                n.removeClass("tour-dimmed");
            });
            // Center on the node
            state.cy.center();
        }
    }
}
/**
 * Clear all tour highlights.
 */
export function clearTourHighlight() {
    // Clear sidebar highlights
    document.querySelectorAll(".tour-highlight").forEach(el => {
        el.classList.remove("tour-highlight");
    });
    // Clear graph highlights
    if (state.cy) {
        state.cy.nodes().forEach(node => {
            node.removeClass("tour-highlight");
            node.removeClass("tour-dimmed");
        });
    }
}
// ============================================================================
// UI Updates
// ============================================================================
/**
 * Hide the tour card.
 */
export function hideTourCard() {
    const card = document.getElementById("tour-card");
    if (card) {
        card.style.display = "none";
    }
}
/**
 * Update tour button appearance.
 */
export function updateTourButton(active) {
    const btn = document.getElementById("tour-btn");
    if (btn) {
        btn.classList.toggle("active", active);
        const label = btn.querySelector("span:first-child");
        if (label) {
            label.textContent = active && currentTour ? currentTour.title : "Tour";
        }
    }
}
/**
 * Toggle tour dropdown menu visibility.
 */
export function toggleTourMenu() {
    const menu = document.getElementById("tour-menu");
    const btn = document.getElementById("tour-btn");
    if (menu) {
        const isOpen = menu.classList.toggle("open");
        // Keep aria-expanded in sync with menu state
        if (btn) {
            btn.setAttribute("aria-expanded", isOpen ? "true" : "false");
        }
    }
}
/**
 * Close tour dropdown menu.
 */
export function closeMenu() {
    const menu = document.getElementById("tour-menu");
    const btn = document.getElementById("tour-btn");
    if (menu) {
        menu.classList.remove("open");
        // Keep aria-expanded in sync with menu state
        if (btn) {
            btn.setAttribute("aria-expanded", "false");
        }
    }
}
// ============================================================================
// Event Handlers
// ============================================================================
/**
 * Initialize tour event handlers.
 */
export function initTourHandlers() {
    // Dropdown toggle
    const tourBtn = document.getElementById("tour-btn");
    if (tourBtn) {
        tourBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            toggleTourMenu();
        });
    }
    // Close menu when clicking outside
    document.addEventListener("click", (e) => {
        const dropdown = document.getElementById("tour-dropdown");
        const target = e.target;
        if (dropdown && !dropdown.contains(target)) {
            closeMenu();
        }
    });
    // Tour navigation buttons
    const prevBtn = document.getElementById("tour-prev-btn");
    const nextBtn = document.getElementById("tour-next-btn");
    const exitBtn = document.getElementById("tour-exit-btn");
    if (prevBtn) {
        prevBtn.addEventListener("click", prevTourStep);
    }
    if (nextBtn) {
        nextBtn.addEventListener("click", nextTourStep);
    }
    if (exitBtn) {
        exitBtn.addEventListener("click", exitTour);
    }
}
/**
 * Get the current tour ID if one is active.
 */
export function getCurrentTourId() {
    return currentTour?.id || null;
}
// ui_fragments.js
// swarm/tools/flow_studio_ui/src/ui_fragments.ts
// Reusable HTML fragments for Flow Studio UI
//
// This module provides helper functions for common UI patterns:
// - Empty states (no data available)
// - Error states (loading failures)
// - Key-value displays
// - Mode-specific hints (author vs operator)
import { escapeHtml } from "./utils.js";
// ============================================================================
// Empty States
// ============================================================================
/**
 * Render an empty state for "no runs" in the sidebar.
 */
export function renderNoRuns() {
    return `
    <div class="fs-empty" style="padding: 16px 12px;">
      <div class="fs-empty-icon">\u{1F4C2}</div>
      <p class="fs-empty-title">No runs yet</p>
      <p class="fs-empty-description">Generate example data to explore Flow Studio.</p>
      <code class="mono fs-empty-command">make demo-run</code>
    </div>
  `;
}
/**
 * Render an empty state for "no flows configured" in the sidebar.
 */
export function renderNoFlows() {
    return `
    <div class="fs-empty" style="padding: 16px 12px;">
      <div class="fs-empty-icon">\u{1F527}</div>
      <p class="fs-empty-title">No flows configured</p>
      <p class="fs-empty-description">Add flow configs to <code class="mono fs-text-xs">swarm/config/flows/</code></p>
    </div>
  `;
}
/**
 * Render the "select a node" empty state for the details panel.
 * Includes onboarding content explaining flows, steps, and agents.
 */
export function renderSelectNodeHint() {
    return `
    <div class="fs-empty" style="height: 100%; padding: 20px 16px; align-items: flex-start;">
      <div class="fs-empty-icon">\u{1F446}</div>
      <p class="fs-empty-title">Select a node</p>
      <p class="fs-empty-description">Click a step or agent in the graph.</p>

      <div style="width: 100%; margin-top: 12px;">

        <div style="margin-bottom: 12px;">
          <div class="kv-label" style="margin-top: 0;">What is a flow?</div>
          <div class="fs-text-body" style="line-height: 1.5; color: #374151;">
            A pipeline from Signal ‚Üí Plan ‚Üí Build ‚Üí Gate ‚Üí Deploy ‚Üí Wisdom.<br/>
            Each flow writes artifacts under
            <code class="mono fs-text-xs">swarm/runs/&lt;run&gt;/</code>
          </div>
        </div>

        <div style="margin-bottom: 12px;">
          <div class="kv-label">What is a step?</div>
          <div class="fs-text-body" style="line-height: 1.5; color: #374151;">
            A stage in the flow executed by one or more agents.<br/>
            Each step reads inputs and writes artifacts.
          </div>
        </div>

        <div style="margin-bottom: 12px;">
          <div class="kv-label">What is an agent?</div>
          <div class="fs-text-body" style="line-height: 1.5; color: #374151;">
            A role with instructions defined in YAML config.<br/>
            Config:
            <code class="mono fs-text-xs">swarm/config/agents/*.yaml</code>
          </div>
        </div>

        <div class="author-only" style="margin-top: 16px; padding: 10px; background: #f0f9ff; border-radius: 6px; border-left: 3px solid #3b82f6;">
          <div class="fs-text-sm" style="font-weight: 600; color: #1e40af; margin-bottom: 6px;">
            First edit
          </div>
          <div class="fs-text-sm" style="color: #374151; line-height: 1.6;">
            1. Select the <strong>build</strong> flow<br/>
            2. Click the <strong>load_context</strong> step<br/>
            3. Follow the <strong>Edit agent</strong> hint
          </div>
          <div class="fs-text-xs fs-text-muted" style="margin-top: 6px;">
            Full guide: <code class="mono" style="font-size: 9px;">docs/FLOW_STUDIO_FIRST_EDIT.md</code>
          </div>
        </div>

        <div class="operator-only" style="margin-top: 16px; padding: 10px; background: #f9fafb; border-radius: 6px;">
          <div class="fs-text-sm fs-text-muted" style="line-height: 1.6;">
            Select a step to see artifact status and run details.
          </div>
        </div>

        <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #e5e7eb;">
          <div class="fs-text-xs fs-text-subtle">
            <kbd class="fs-kbd">1-6</kbd> flows
            <kbd class="fs-kbd">/</kbd> search
            <kbd class="fs-kbd">?</kbd> help
          </div>
        </div>

      </div>
    </div>
  `;
}
// ============================================================================
// Error States
// ============================================================================
/**
 * Render an error state for failed run loading.
 */
export function renderRunsLoadError() {
    return `
    <div class="fs-error" style="margin: 8px;">
      <div class="fs-error-icon">\u26A0\uFE0F</div>
      <p class="fs-error-title">Failed to load runs</p>
      <p class="fs-error-description">Check that the Flow Studio server is running.</p>
      <button class="fs-error-action" onclick="location.reload()">Retry</button>
    </div>
  `;
}
/**
 * Render a generic error state with custom title and message.
 */
export function renderErrorState(title, message, actionLabel, actionOnClick) {
    const actionHtml = actionLabel && actionOnClick
        ? `<button class="fs-error-action" onclick="${escapeHtml(actionOnClick)}">${escapeHtml(actionLabel)}</button>`
        : "";
    return `
    <div class="fs-error" style="margin: 8px;">
      <div class="fs-error-icon">\u26A0\uFE0F</div>
      <p class="fs-error-title">${escapeHtml(title)}</p>
      <p class="fs-error-description">${escapeHtml(message)}</p>
      ${actionHtml}
    </div>
  `;
}
// ============================================================================
// Key-Value Display
// ============================================================================
/**
 * Render a single key-value pair.
 */
export function renderKV(label, value, mono = false) {
    const valueClass = mono ? 'class="mono"' : '';
    return `
    <div class="kv-label">${escapeHtml(label)}</div>
    <div ${valueClass}>${escapeHtml(value)}</div>
  `;
}
/**
 * Render a key-value pair with raw HTML value (use with caution).
 */
export function renderKVHtml(label, valueHtml) {
    return `
    <div class="kv-label">${escapeHtml(label)}</div>
    <div>${valueHtml}</div>
  `;
}
// ============================================================================
// Hint Sections
// ============================================================================
/**
 * Render the getting started hint for flow details (author mode).
 */
export function renderGettingStartedHint(flowKey) {
    return `
    <div class="welcome-section" style="margin-bottom: 12px;">
      <div class="fs-text-sm fs-text-muted" style="margin-bottom: 8px;">
        Click a node for details. Press <kbd class="shortcut-key">?</kbd> for shortcuts.
      </div>
      <div class="fs-text-sm fs-text-subtle">
        Artifacts: <code class="mono fs-text-xs">swarm/runs/&lt;run&gt;/${escapeHtml(flowKey || "<flow>")}/</code>
      </div>
    </div>
    <div class="welcome-section">
      <div class="fs-text-sm fs-text-muted" style="margin-bottom: 4px;">Edit flow:</div>
      <pre class="mono fs-text-xs" style="margin: 0;">$EDITOR swarm/config/flows/${escapeHtml(flowKey || "<key>")}.yaml</pre>
    </div>
  `;
}
/**
 * Render the operator mode hint when no timeline is available.
 */
export function renderOperatorFlowHint() {
    return `
    <div class="muted fs-text-sm" style="margin-top: 8px;">
      Select a step for status and artifacts.
    </div>
  `;
}
/**
 * Render a loading placeholder.
 */
export function renderLoading(message = "Loading...") {
    return `<div class="muted">${escapeHtml(message)}</div>`;
}
// ============================================================================
// Tour Menu Items
// ============================================================================
/**
 * Render the "no tour" menu item.
 */
export function renderNoTourMenuItem() {
    return `
    <div class="tour-menu-item" data-tour="">
      <div class="tour-menu-title">No tour</div>
      <div class="tour-menu-desc">Exit current tour</div>
    </div>
  `;
}
/**
 * Render a tour menu item.
 */
export function renderTourMenuItem(tourId, title, description) {
    return `
    <div class="tour-menu-title">${escapeHtml(title)}</div>
    <div class="tour-menu-desc">${escapeHtml(description)}</div>
  `;
}
// ============================================================================
// Agent Usage Item
// ============================================================================
/**
 * Render an agent usage link item.
 */
export function renderAgentUsageItem(flowTitle, stepTitle) {
    return `<span style="color: #3b82f6;">\u2192</span> <strong>${escapeHtml(flowTitle)}</strong> &gt; ${escapeHtml(stepTitle)}`;
}
// ============================================================================
// Step/Agent/Artifact Details Helpers
// ============================================================================
/**
 * Render the step location info (author mode).
 */
export function renderStepLocationInfo(flowKey) {
    return `
    <div class="kv-label">Spec</div>
    <div class="fs-text-sm">
      <span class="mono">swarm/flows/flow-${escapeHtml(flowKey)}.md</span>
    </div>
    <div style="margin-top: 8px;">
      <div class="fs-text-sm fs-text-muted" style="margin-bottom: 4px;">Edit step:</div>
      <pre class="mono fs-text-xs" style="margin: 0;">$EDITOR swarm/config/flows/${escapeHtml(flowKey)}.yaml</pre>
    </div>
  `;
}
/**
 * Render the agent location info (author mode).
 */
export function renderAgentLocationInfo(agentKey) {
    return `
    <div class="kv-label">Files</div>
    <div class="fs-text-sm" style="line-height: 1.8;">
      <span class="mono">swarm/config/agents/${escapeHtml(agentKey)}.yaml</span> <span class="muted">(edit)</span><br/>
      <span class="mono">.claude/agents/${escapeHtml(agentKey)}.md</span> <span class="muted">(generated)</span>
    </div>
    <div style="margin-top: 8px;">
      <div class="fs-text-sm fs-text-muted" style="margin-bottom: 4px;">Edit agent:</div>
      <pre class="mono fs-text-xs" style="margin: 0;">$EDITOR swarm/config/agents/${escapeHtml(agentKey)}.yaml</pre>
    </div>
  `;
}
/**
 * Render agent category hint (operator mode).
 */
export function renderAgentCategoryHint(category, model) {
    return `
    <div class="muted" style="margin-top: 8px;">
      This agent belongs to the <strong>${escapeHtml(category || "unknown")}</strong> role family
      and uses the <strong>${escapeHtml(model || "inherit")}</strong> model.
    </div>
  `;
}
/**
 * Render artifact producer hint (operator mode).
 */
export function renderArtifactProducerHint(stepId, flowKey) {
    return `
    <div class="muted" style="margin-top: 8px;">
      This artifact is produced by the <strong>${escapeHtml(stepId)}</strong> step
      in the <strong>${escapeHtml(flowKey)}</strong> flow.
    </div>
  `;
}
// ============================================================================
// Tabs
// ============================================================================
/**
 * Render tab navigation.
 */
export function renderTabs(tabs) {
    return tabs.map(tab => `<span class="tab${tab.active ? " active" : ""}" data-tab="${escapeHtml(tab.id)}">${escapeHtml(tab.label)}</span>`).join("");
}
// utils.js
// swarm/tools/flow_studio_ui/src/utils.ts
// Utility functions for Flow Studio
// ============================================================================
// Time and Duration Formatting
// ============================================================================
/**
 * Format duration in seconds to human-readable form
 */
export function formatDuration(seconds) {
    if (seconds == null)
        return "‚Äî";
    if (seconds < 60)
        return `${Math.round(seconds)}s`;
    if (seconds < 3600)
        return `${Math.floor(seconds / 60)}m ${Math.round(seconds % 60)}s`;
    const hours = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    return `${hours}h ${mins}m`;
}
/**
 * Format ISO timestamp to time only (HH:MM)
 */
export function formatTime(isoString) {
    if (!isoString)
        return "‚Äî";
    const d = new Date(isoString);
    return d.toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
    });
}
/**
 * Format ISO timestamp to date + time
 */
export function formatDateTime(isoString) {
    if (!isoString)
        return "‚Äî";
    const d = new Date(isoString);
    return (d.toLocaleDateString("en-US", { month: "short", day: "numeric" }) +
        " " +
        d.toLocaleTimeString("en-US", { hour: "2-digit", minute: "2-digit", hour12: false }));
}
// ============================================================================
// HTML Utilities
// ============================================================================
/**
 * Escape HTML special characters to prevent XSS
 */
export function escapeHtml(text) {
    if (!text)
        return "";
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
// ============================================================================
// Clipboard Utilities
// ============================================================================
/**
 * Copy text to clipboard
 */
export function copyToClipboard(text) {
    return navigator.clipboard.writeText(text).catch(err => {
        console.error("Copy failed", err);
    });
}
/**
 * Create a copy button element
 */
export function createCopyButton(text, label = "Copy") {
    const btn = document.createElement("button");
    btn.className = "copy-btn";
    btn.textContent = label;
    btn.title = "Copy to clipboard";
    btn.addEventListener("click", () => {
        void copyToClipboard(text);
        btn.textContent = "Copied!";
        btn.classList.add("copied");
        setTimeout(() => {
            btn.textContent = label;
            btn.classList.remove("copied");
        }, 1500);
    });
    return btn;
}
/**
 * Create a path display with copy button
 */
export function createPathWithCopy(path) {
    const container = document.createElement("div");
    container.className = "path-with-copy";
    const pathSpan = document.createElement("span");
    pathSpan.className = "mono";
    pathSpan.textContent = path;
    container.appendChild(pathSpan);
    container.appendChild(createCopyButton(path, "Copy"));
    return container;
}
/**
 * Create quick commands section with copy buttons
 */
export function createQuickCommands(commands) {
    const container = document.createElement("div");
    container.className = "quick-commands";
    const label = document.createElement("div");
    label.className = "kv-label";
    label.textContent = "Quick commands";
    container.appendChild(label);
    commands.forEach(cmd => {
        const line = document.createElement("div");
        line.className = "command-line";
        const cmdText = document.createElement("span");
        cmdText.className = "command-text";
        cmdText.textContent = "$ " + cmd;
        line.appendChild(cmdText);
        line.appendChild(createCopyButton(cmd, "Copy"));
        container.appendChild(line);
    });
    return container;
}
// ============================================================================
// Focus Trap Utilities
// ============================================================================
/**
 * Selector for focusable elements
 */
const FOCUSABLE_SELECTOR = [
    "a[href]",
    "button:not([disabled])",
    "input:not([disabled])",
    "textarea:not([disabled])",
    "select:not([disabled])",
    "[tabindex]:not([tabindex='-1'])",
    "[contenteditable]"
].join(", ");
/**
 * Get all focusable elements within a container
 */
export function getFocusableElements(container) {
    return Array.from(container.querySelectorAll(FOCUSABLE_SELECTOR))
        .filter(el => el.offsetParent !== null); // Filter out hidden elements
}
/**
 * Create a focus trap within a container.
 *
 * - Traps Tab/Shift+Tab to cycle within the container
 * - Moves focus into the container on creation
 * - Returns cleanup function to remove the trap
 *
 * @param container - The element to trap focus within
 * @param initialFocusEl - Element to focus initially (defaults to first focusable)
 */
export function createFocusTrap(container, initialFocusEl) {
    const focusableElements = getFocusableElements(container);
    // Focus initial element or first focusable
    if (initialFocusEl && focusableElements.includes(initialFocusEl)) {
        initialFocusEl.focus();
    }
    else if (focusableElements.length > 0) {
        focusableElements[0].focus();
    }
    else {
        // If no focusable elements, make container focusable temporarily
        container.setAttribute("tabindex", "-1");
        container.focus();
    }
    function handleKeyDown(e) {
        if (e.key !== "Tab")
            return;
        const elements = getFocusableElements(container);
        if (elements.length === 0)
            return;
        const firstEl = elements[0];
        const lastEl = elements[elements.length - 1];
        if (e.shiftKey) {
            // Shift+Tab: if on first element, go to last
            if (document.activeElement === firstEl) {
                e.preventDefault();
                lastEl.focus();
            }
        }
        else {
            // Tab: if on last element, go to first
            if (document.activeElement === lastEl) {
                e.preventDefault();
                firstEl.focus();
            }
        }
    }
    container.addEventListener("keydown", handleKeyDown);
    return {
        cleanup: () => {
            container.removeEventListener("keydown", handleKeyDown);
        }
    };
}
export function createModalFocusManager(modal, contentSelector) {
    let invoker = null;
    let focusTrap = null;
    let isModalOpen = false;
    function open(inv) {
        if (isModalOpen)
            return;
        invoker = inv ?? document.activeElement;
        isModalOpen = true;
        const content = modal.querySelector(contentSelector);
        if (content) {
            // Small delay to ensure modal is visible before focusing
            setTimeout(() => {
                focusTrap = createFocusTrap(content);
            }, 50);
        }
    }
    function close() {
        if (!isModalOpen)
            return;
        isModalOpen = false;
        // Cleanup focus trap
        if (focusTrap) {
            focusTrap.cleanup();
            focusTrap = null;
        }
        // Restore focus to invoker
        if (invoker && "focus" in invoker && typeof invoker.focus === "function") {
            invoker.focus();
        }
        invoker = null;
    }
    return {
        open,
        close,
        isOpen: () => isModalOpen
    };
}
// flow_constants.js
// AUTO-GENERATED from swarm/config/flows.yaml
// Do not edit manually. Run: make gen-flow-constants
/** Canonical flow ordering in SDLC sequence */
export const FLOW_KEYS = ["signal", "plan", "build", "gate", "deploy", "wisdom", "stepwise-demo"];
/** Flow key to numeric index (1-6) */
export const FLOW_INDEX = {
    signal: 1,
    plan: 2,
    build: 3,
    gate: 4,
    deploy: 5,
    wisdom: 6,
    "stepwise-demo": 7,
};
/** Flow key to display title */
export const FLOW_TITLES = {
    signal: "Signal",
    plan: "Plan",
    build: "Build",
    gate: "Gate",
    deploy: "Deploy",
    wisdom: "Wisdom",
    "stepwise-demo": "Stepwise",
};
/** Flow key to description */
export const FLOW_DESCRIPTIONS = {
    signal: "Raw input to problem statement, requirements, BDD scenarios, early risk assessment",
    plan: "Requirements to ADR, contracts, observability spec, test/work plans, design validation",
    build: "Implement via adversarial microloops, build code and tests, self-verify, produce receipts",
    gate: "Pre-merge gate, audit receipts, check contracts/security/policy, recommend merge or bounce",
    deploy: "Move approved artifact to production, execute deployment, verify health, create audit trail",
    wisdom: "Analyze artifacts, detect regressions, extract learnings, close feedback loops",
    "stepwise-demo": "A 10-step demo flow for testing stepwise execution backends",
};
// teaching_mode.js
// swarm/tools/flow_studio_ui/src/teaching_mode.ts
// Teaching Mode state management for Flow Studio
//
// Teaching Mode is a pedagogical overlay that:
// - Highlights exemplar runs for learning
// - Defaults Run History to "Examples" filter
// - Enables additional educational features
//
// State is persisted to localStorage for session persistence.
// ============================================================================
// Constants
// ============================================================================
const STORAGE_KEY = "flowStudio.teachingMode";
// ============================================================================
// Internal State
// ============================================================================
let _isEnabled = false;
let _initialized = false;
// ============================================================================
// localStorage Helpers
// ============================================================================
/**
 * Read teaching mode state from localStorage.
 * Returns false if localStorage is unavailable or key is missing.
 */
function readFromStorage() {
    if (typeof window === "undefined")
        return false;
    try {
        const raw = window.localStorage.getItem(STORAGE_KEY);
        if (raw === null)
            return false;
        return raw === "true";
    }
    catch {
        // localStorage blocked or unavailable
        return false;
    }
}
/**
 * Write teaching mode state to localStorage.
 * Silently fails if localStorage is unavailable.
 */
function writeToStorage(enabled) {
    if (typeof window === "undefined")
        return;
    try {
        window.localStorage.setItem(STORAGE_KEY, enabled ? "true" : "false");
    }
    catch {
        // Ignore - UX still works, just loses persistence
    }
}
// ============================================================================
// State Management
// ============================================================================
/**
 * Initialize teaching mode from localStorage.
 * Call this once during app startup.
 */
export function initTeachingMode() {
    if (_initialized)
        return;
    _isEnabled = readFromStorage();
    _initialized = true;
    // Apply initial state to DOM
    applyTeachingModeClass();
}
/**
 * Get the current teaching mode state.
 * @returns true if Teaching Mode is enabled
 */
export function getTeachingMode() {
    return _isEnabled;
}
/**
 * Set the teaching mode state.
 * Persists to localStorage and updates the DOM.
 * Notifies all registered callbacks of the change.
 *
 * @param enabled - Whether Teaching Mode should be enabled
 */
export function setTeachingMode(enabled) {
    const wasEnabled = _isEnabled;
    _isEnabled = enabled;
    writeToStorage(enabled);
    applyTeachingModeClass();
    updateToggleButtonState();
    // Notify callbacks only if state actually changed
    if (wasEnabled !== enabled) {
        notifyCallbacks();
    }
}
/**
 * Toggle the teaching mode state.
 * Convenience method that inverts the current state.
 *
 * @returns The new state after toggling
 */
export function toggleTeachingMode() {
    setTeachingMode(!_isEnabled);
    return _isEnabled;
}
// ============================================================================
// DOM Updates
// ============================================================================
/**
 * Apply teaching-mode class to body based on current state.
 */
function applyTeachingModeClass() {
    if (typeof document === "undefined")
        return;
    if (_isEnabled) {
        document.body.classList.add("teaching-mode");
    }
    else {
        document.body.classList.remove("teaching-mode");
    }
}
/**
 * Update the toggle button's active state.
 */
function updateToggleButtonState() {
    if (typeof document === "undefined")
        return;
    const toggleBtn = document.querySelector('[data-uiid="flow_studio.header.teaching_mode.toggle"]');
    if (toggleBtn) {
        toggleBtn.classList.toggle("active", _isEnabled);
        toggleBtn.setAttribute("aria-pressed", _isEnabled ? "true" : "false");
        toggleBtn.title = _isEnabled
            ? "Teaching Mode is ON - click to disable"
            : "Enable Teaching Mode for learning-focused features";
    }
}
/** Registered callbacks */
const _callbacks = [];
/**
 * Register a callback to be notified when Teaching Mode changes.
 * Useful for components that need to update when teaching mode is toggled.
 *
 * @param callback - Function called with the new state when teaching mode changes
 */
export function onTeachingModeChange(callback) {
    _callbacks.push(callback);
}
/**
 * Notify all registered callbacks of a state change.
 */
function notifyCallbacks() {
    _callbacks.forEach(cb => {
        try {
            cb(_isEnabled);
        }
        catch (err) {
            console.error("Teaching mode callback error:", err);
        }
    });
}
// ============================================================================
// Integration Helpers
// ============================================================================
/**
 * Get the default Run History filter based on Teaching Mode.
 * When Teaching Mode is enabled, defaults to "example" filter.
 *
 * @returns "example" if Teaching Mode is on, "all" otherwise
 */
export function getDefaultRunHistoryFilter() {
    return _isEnabled ? "example" : "all";
}
/**
 * Initialize the toggle button event handler.
 * Call this after the DOM is ready.
 */
export function initToggleButtonHandler() {
    const toggleBtn = document.querySelector('[data-uiid="flow_studio.header.teaching_mode.toggle"]');
    if (toggleBtn) {
        toggleBtn.addEventListener("click", () => {
            toggleTeachingMode();
        });
        // Set initial button state
        updateToggleButtonState();
    }
}
// layout_spec.js
// swarm/tools/flow_studio_ui/src/layout_spec.ts
// Layout specification for Flow Studio screens
//
// This module defines the authoritative layout registry for Flow Studio.
// It enables:
// - MCP tools to enumerate screens/regions/UIIDs
// - run_layout_review.py to capture per-screen artifacts
// - Tests to verify layout contract compliance
//
// VERSION: 0.5.0-flowstudio (adds layout spec to SDK)
// ============================================================================
// Authoritative Screen Registry
// ============================================================================
/**
 * Authoritative registry of screens.
 * This is what MCP + layout-review will enumerate.
 */
export const screens = [
    {
        id: "flows.default",
        route: "/",
        title: "Flows - Default",
        description: "Main Flow Studio screen with run selector, flow list, graph canvas, and inspector.",
        regions: [
            {
                id: "header",
                purpose: "Global navigation, search, governance indicators, mode toggle.",
                uiids: [
                    "flow_studio.header",
                    "flow_studio.header.search",
                    "flow_studio.header.search.input",
                    "flow_studio.header.search.results",
                    "flow_studio.header.controls",
                    "flow_studio.header.tour",
                    "flow_studio.header.tour.trigger",
                    "flow_studio.header.tour.menu",
                    "flow_studio.header.mode",
                    "flow_studio.header.mode.author",
                    "flow_studio.header.mode.operator",
                    "flow_studio.header.governance",
                    "flow_studio.header.governance.overlay",
                    "flow_studio.header.reload",
                    "flow_studio.header.reload.btn",
                    "flow_studio.header.help",
                ],
            },
            {
                id: "sdlc_bar",
                purpose: "SDLC progress bar showing flow completion status.",
                uiids: ["flow_studio.sdlc_bar"],
            },
            {
                id: "sidebar",
                purpose: "Run selector, flow list, and view toggles between agents and artifacts.",
                uiids: [
                    "flow_studio.sidebar",
                    "flow_studio.sidebar.run_selector",
                    "flow_studio.sidebar.run_selector.select",
                    "flow_studio.sidebar.compare_selector",
                    "flow_studio.sidebar.flow_list",
                    "flow_studio.sidebar.view_toggle",
                ],
            },
            {
                id: "canvas",
                purpose: "Graph visualization of the current flow and SDLC legend.",
                uiids: [
                    "flow_studio.canvas",
                    "flow_studio.canvas.graph",
                    "flow_studio.canvas.legend",
                    "flow_studio.canvas.legend.toggle",
                    "flow_studio.canvas.outline",
                ],
            },
            {
                id: "inspector",
                purpose: "Details panel for selected step/agent/artifact, timing, and timeline.",
                uiids: [
                    "flow_studio.inspector",
                    "flow_studio.inspector.details",
                ],
            },
        ],
    },
    {
        id: "flows.selftest",
        route: "/?modal=selftest",
        title: "Flows - Selftest Modal",
        description: "Selftest plan / results modal and controls.",
        regions: [
            {
                id: "modal",
                purpose: "Selftest plan, run controls, copy helpers.",
                uiids: ["flow_studio.modal.selftest"],
            },
        ],
    },
    {
        id: "flows.shortcuts",
        route: "/?modal=shortcuts",
        title: "Flows - Shortcuts Modal",
        description: "Keyboard shortcuts reference modal.",
        regions: [
            {
                id: "modal",
                purpose: "Keyboard shortcuts grid.",
                uiids: ["flow_studio.modal.shortcuts"],
            },
        ],
    },
    {
        id: "flows.validation",
        route: "/?tab=validation",
        title: "Flows - Validation View",
        description: "Governance validation results and FR status badges.",
        regions: [
            {
                id: "header",
                purpose: "Governance badge and overlay toggle.",
                uiids: [
                    "flow_studio.header.governance",
                    "flow_studio.header.governance.overlay",
                ],
            },
            {
                id: "inspector",
                purpose: "Validation details for selected agent or flow.",
                uiids: [
                    "flow_studio.inspector",
                    "flow_studio.inspector.details",
                ],
            },
        ],
    },
    {
        id: "flows.tour",
        route: "/?tour=<tour_id>",
        title: "Flows - Tour Mode",
        description: "Guided tour overlay with step-by-step navigation.",
        regions: [
            {
                id: "header",
                purpose: "Tour menu and controls.",
                uiids: [
                    "flow_studio.header.tour",
                    "flow_studio.header.tour.trigger",
                    "flow_studio.header.tour.menu",
                ],
            },
            {
                id: "canvas",
                purpose: "Tour card overlay on graph nodes.",
                uiids: [
                    "flow_studio.canvas",
                    "flow_studio.canvas.graph",
                ],
            },
        ],
    },
];
// ============================================================================
// Convenience Accessors
// ============================================================================
/**
 * Index of screens by ID for quick lookup.
 */
export const screenById = Object.fromEntries(screens.map((s) => [s.id, s]));
/**
 * Get all known screen IDs.
 */
export function getScreenIds() {
    return screens.map((s) => s.id);
}
/**
 * Get a screen spec by ID, or null if not found.
 */
export function getScreenById(id) {
    return screenById[id] ?? null;
}
/**
 * Get all UIIDs across all screens and regions.
 * Useful for coverage checks.
 */
export function getAllKnownUIIDs() {
    const uiids = new Set();
    for (const screen of screens) {
        for (const region of screen.regions) {
            for (const uiid of region.uiids) {
                uiids.add(uiid);
            }
        }
    }
    return Array.from(uiids);
}
/**
 * Validate that all UIIDs in the layout spec are actually defined
 * in the FlowStudioUIID type. Returns UIIDs that are in spec but
 * not in the type (should be empty if spec is in sync).
 */
export function validateLayoutUIIDs() {
    // This is a compile-time check via the type system.
    // If a UIID in screens isn't in FlowStudioUIID, TypeScript will error.
    // Runtime validation would require importing the actual type definition.
    return { valid: true, issues: [] };
}
// ============================================================================
// JSON Export (for Python/API consumption)
// ============================================================================
/**
 * Export the layout spec as a JSON-serializable object.
 * Used by /api/layout_screens endpoint.
 */
export function toJSON() {
    return {
        version: "0.5.0-flowstudio",
        screens: screens,
    };
}
// run_history.js
// swarm/tools/flow_studio_ui/src/run_history.ts
// Run History panel module for Flow Studio
//
// This module handles:
// - Loading and displaying run history
// - Run filtering (all, example, active)
// - Run selection from history
// - Run detail modal/panel display
import { Api } from "./api.js";
import { state, STATUS_ICONS } from "./state.js";
import { escapeHtml, formatDateTime } from "./utils.js";
import { getDefaultRunHistoryFilter } from "./teaching_mode.js";
let _callbacks = {};
/**
 * Configure callbacks for the run history module.
 * Call this before using other functions to wire up UI interactions.
 */
export function configure(callbacks = {}) {
    _callbacks = { ..._callbacks, ...callbacks };
}
const _state = {
    runs: [],
    filteredRuns: [],
    currentFilter: "all",
    selectedRunId: null,
    isLoading: false,
    error: null,
    // Pagination defaults
    total: 0,
    limit: 100,
    offset: 0,
    hasMore: false,
};
// ============================================================================
// Run History Loading
// ============================================================================
/**
 * Load run history from API and update internal state.
 * Fetches runs from the API and populates the run history panel.
 */
export async function loadRunHistory() {
    _state.isLoading = true;
    _state.error = null;
    try {
        const data = await Api.getRuns();
        _state.runs = data.runs || [];
        // Store pagination info from API response
        _state.total = data.total ?? _state.runs.length;
        _state.limit = data.limit ?? 100;
        _state.offset = data.offset ?? 0;
        _state.hasMore = data.has_more ?? false;
        applyFilter(_state.currentFilter);
        _state.isLoading = false;
    }
    catch (err) {
        console.error("Failed to load run history", err);
        _state.runs = [];
        _state.filteredRuns = [];
        _state.error = "Failed to load runs";
        _state.isLoading = false;
    }
}
// ============================================================================
// Filtering and Ordering
// ============================================================================
/**
 * Curated runs that should appear first in the list.
 * These are the "golden" demo runs that are most useful for demos/teaching.
 */
const CURATED_RUNS_ORDER = [
    "stepwise-stub",
    "stepwise-sdlc-stub",
    "stepwise-sdlc-claude",
    "demo-health-check",
    "health-check",
    "health-check-risky-deploy",
];
/**
 * Sort runs with curated runs first, then by created_at descending.
 */
function sortRuns(runs) {
    return [...runs].sort((a, b) => {
        const idxA = CURATED_RUNS_ORDER.indexOf(a.run_id);
        const idxB = CURATED_RUNS_ORDER.indexOf(b.run_id);
        // Both are curated: sort by curated order
        if (idxA !== -1 && idxB !== -1) {
            return idxA - idxB;
        }
        // Only A is curated: A comes first
        if (idxA !== -1)
            return -1;
        // Only B is curated: B comes first
        if (idxB !== -1)
            return 1;
        // Neither curated: sort examples before active, then by created_at descending
        if (a.run_type === "example" && b.run_type !== "example")
            return -1;
        if (a.run_type !== "example" && b.run_type === "example")
            return 1;
        // Same type: sort by created_at descending (newest first)
        const dateA = a.created_at ?? "";
        const dateB = b.created_at ?? "";
        return dateB.localeCompare(dateA);
    });
}
/**
 * Apply filter to runs and update filtered list.
 */
function applyFilter(type) {
    _state.currentFilter = type;
    let filtered;
    switch (type) {
        case "example":
            filtered = _state.runs.filter(r => r.run_type === "example");
            break;
        case "active":
            filtered = _state.runs.filter(r => r.run_type === "active");
            break;
        case "all":
        default:
            filtered = [..._state.runs];
            break;
    }
    // Apply curated-first sorting
    _state.filteredRuns = sortRuns(filtered);
}
/**
 * Filter the displayed runs by type.
 *
 * @param type - Filter type: "all", "example", or "active"
 */
export function filterRuns(type) {
    applyFilter(type);
    // Update filter button UI
    const filterContainer = document.getElementById("run-history-filter");
    if (filterContainer) {
        filterContainer.querySelectorAll(".filter-btn").forEach(btn => {
            const filter = btn.dataset.filter;
            btn.classList.toggle("active", filter === type);
        });
    }
    // Re-render if we have a container (for panel mode)
    const container = document.querySelector('[data-uiid="flow_studio.sidebar.run_history"]');
    if (container instanceof HTMLElement) {
        renderRunHistoryPanel(container);
    }
    // Re-render list items (for integrated mode)
    renderRunListItems();
}
// ============================================================================
// Run Selection
// ============================================================================
/**
 * Handle run selection from history.
 * Updates internal state and calls the onRunSelect callback.
 *
 * @param runId - The ID of the run to select
 */
export async function selectHistoryRun(runId) {
    _state.selectedRunId = runId;
    // Update UI to reflect selection
    updateSelectionUI(runId);
    // Notify consumer
    if (_callbacks.onRunSelect) {
        await _callbacks.onRunSelect(runId);
    }
}
/**
 * Update the UI to reflect the currently selected run.
 */
function updateSelectionUI(runId) {
    // Remove active class from all items
    document.querySelectorAll(".run-history-item").forEach(el => {
        el.classList.remove("active");
    });
    // Add active class to selected item
    const selectedItem = document.querySelector(`[data-uiid="flow_studio.sidebar.run_history.item:${runId}"]`);
    if (selectedItem) {
        selectedItem.classList.add("active");
    }
}
// ============================================================================
// Run Detail
// ============================================================================
/**
 * Open the run detail modal/panel for a specific run.
 *
 * @param runId - The ID of the run to show details for
 */
export async function openRunDetail(runId) {
    if (_callbacks.onRunDetailOpen) {
        await _callbacks.onRunDetailOpen(runId);
    }
}
// ============================================================================
// HTML Rendering Helpers
// ============================================================================
/**
 * Get display name for a run.
 */
function getRunDisplayName(run) {
    return run.title || run.run_id;
}
/**
 * Get human-readable backend label.
 */
function getBackendLabel(backendId) {
    const labels = {
        "claude-harness": "Claude",
        "claude-agent-sdk": "Claude SDK",
        "claude-step-orchestrator": "Claude Stepwise",
        "gemini-cli": "Gemini",
        "gemini-step-orchestrator": "Gemini Stepwise",
        "custom-cli": "Custom",
    };
    return labels[backendId] || backendId;
}
/**
 * Get run type badge HTML.
 */
function getRunTypeBadge(run) {
    const badges = [];
    // Add type badge (example or active)
    const isExample = run.run_type === "example";
    const typeBadgeClass = isExample ? "run-history-item-badge example" : "run-history-item-badge active";
    const typeLabel = isExample ? "Example" : "Active";
    badges.push(`<span class="${typeBadgeClass}" data-uiid="flow_studio.sidebar.run_history.item.badge.${run.run_type}:${escapeHtml(run.run_id)}">${typeLabel}</span>`);
    // Add backend badge if present
    if (run.backend) {
        const backendLabel = getBackendLabel(run.backend);
        badges.push(`<span class="run-history-item-badge backend" data-uiid="flow_studio.sidebar.run_history.item.badge.backend:${escapeHtml(run.run_id)}">${escapeHtml(backendLabel)}</span>`);
    }
    // Add exemplar badge if marked
    if (run.is_exemplar) {
        badges.push(`<span class="run-history-item-badge exemplar" data-uiid="flow_studio.sidebar.run_history.item.badge.exemplar:${escapeHtml(run.run_id)}">Exemplar</span>`);
    }
    return badges.join(" ");
}
/**
 * Get run status indicator based on run summary.
 * This checks the global state for run status data.
 */
function getRunStatusIndicator(runId) {
    // Check if we have status data for this run
    if (state.currentRunId === runId && state.runStatus.flows) {
        // Determine overall status from flows
        const flowStatuses = Object.values(state.runStatus.flows);
        const hasError = flowStatuses.some(f => f.status === "missing");
        const hasWarning = flowStatuses.some(f => f.status === "partial" || f.status === "in_progress");
        const allComplete = flowStatuses.every(f => f.status === "done" || f.status === "complete");
        if (hasError) {
            return `<span class="run-status-indicator error" title="Has errors">${STATUS_ICONS.missing}</span>`;
        }
        else if (hasWarning) {
            return `<span class="run-status-indicator warning" title="In progress">${STATUS_ICONS.partial}</span>`;
        }
        else if (allComplete) {
            return `<span class="run-status-indicator ok" title="Complete">${STATUS_ICONS.done}</span>`;
        }
    }
    // Default: unknown status (bullet)
    return `<span class="run-status-indicator unknown" title="Status unknown">\u2022</span>`;
}
/**
 * Render a single run history item.
 *
 * @param run - The run to render
 * @returns HTML string for the run history item
 */
function renderRunHistoryItem(run) {
    const displayName = escapeHtml(getRunDisplayName(run));
    const typeBadge = getRunTypeBadge(run);
    const statusIndicator = getRunStatusIndicator(run.run_id);
    const timestamp = run.created_at ? formatDateTime(run.created_at) : "";
    const description = run.description ? escapeHtml(run.description) : "";
    const isActive = _state.selectedRunId === run.run_id ? " active" : "";
    return `
    <div
      class="run-history-item${isActive}"
      data-uiid="flow_studio.sidebar.run_history.item:${escapeHtml(run.run_id)}"
      data-run-id="${escapeHtml(run.run_id)}"
      role="option"
      aria-selected="${_state.selectedRunId === run.run_id}"
      tabindex="0"
    >
      <div class="run-history-item-header">
        ${statusIndicator}
        <span class="run-history-item-title">${displayName}</span>
        ${typeBadge}
      </div>
      ${timestamp ? `<div class="run-history-item-meta fs-text-xs muted">${timestamp}</div>` : ""}
      ${description ? `<div class="run-history-item-desc fs-text-xs muted">${description}</div>` : ""}
    </div>
  `;
}
/**
 * Render the full run history list.
 *
 * @param runs - Array of runs to render
 * @returns HTML string for the run history list
 */
function renderRunHistoryList(runs) {
    if (runs.length === 0) {
        return renderRunHistoryEmpty();
    }
    const items = runs.map(run => renderRunHistoryItem(run)).join("");
    return `
    <div class="run-history-list" role="listbox" aria-label="Run history">
      ${items}
    </div>
  `;
}
/**
 * Render empty state for run history.
 *
 * @returns HTML string for empty state
 */
function renderRunHistoryEmpty() {
    const filterText = _state.currentFilter === "all"
        ? "No runs available"
        : `No ${_state.currentFilter} runs`;
    return `
    <div class="fs-empty run-history-empty">
      <div class="fs-empty-icon">\u{1F4C2}</div>
      <p class="fs-empty-title">${filterText}</p>
      <p class="fs-empty-description">
        ${_state.currentFilter === "all"
        ? "Generate example data to explore Flow Studio."
        : `Try changing the filter or run <code class="mono fs-text-xs">make demo-run</code>`}
      </p>
      ${_state.currentFilter === "all" ? '<code class="mono fs-empty-command">make demo-run</code>' : ""}
    </div>
  `;
}
/**
 * Render loading state.
 */
function renderRunHistoryLoading() {
    return `
    <div class="run-history-loading muted">
      Loading runs...
    </div>
  `;
}
/**
 * Render error state.
 */
function renderRunHistoryError(error) {
    return `
    <div class="fs-error run-history-error">
      <div class="fs-error-icon">\u26A0\uFE0F</div>
      <p class="fs-error-title">Error loading runs</p>
      <p class="fs-error-description">${escapeHtml(error)}</p>
      <button class="fs-error-action" data-action="retry-load">Retry</button>
    </div>
  `;
}
/**
 * Render filter tabs.
 */
function renderFilterTabs() {
    const filters = ["all", "example", "active"];
    const labels = {
        all: "All",
        example: "Examples",
        active: "Active",
    };
    const tabs = filters.map(filter => {
        const isActive = _state.currentFilter === filter ? " active" : "";
        return `<span class="tab${isActive}" data-filter="${filter}">${labels[filter]}</span>`;
    }).join("");
    return `<div class="run-history-filters tabs">${tabs}</div>`;
}
/**
 * Render pagination info when there are more runs available.
 */
function renderPaginationInfo() {
    // Only show if we have runs and there might be more
    if (_state.runs.length === 0)
        return "";
    const shown = _state.runs.length;
    const total = _state.total;
    // If we're showing all runs, just show the count
    if (!_state.hasMore && shown === total) {
        return `<div class="run-pagination-info muted fs-text-xs">${total} runs</div>`;
    }
    // Show pagination info when there are more
    return `
    <div class="run-pagination-info muted fs-text-xs">
      Showing ${shown} of ${total} runs
      ${_state.hasMore ? `<span class="pagination-hint">(use CLI: <code>make runs-list-v</code>)</span>` : ""}
    </div>
  `;
}
// ============================================================================
// Panel Rendering
// ============================================================================
/**
 * Render the run history panel into a container element.
 *
 * @param container - The HTML element to render into
 */
export function renderRunHistoryPanel(container) {
    let content;
    if (_state.isLoading) {
        content = renderRunHistoryLoading();
    }
    else if (_state.error) {
        content = renderRunHistoryError(_state.error);
    }
    else {
        content = renderRunHistoryList(_state.filteredRuns);
    }
    container.innerHTML = `
    <div class="run-history-panel" data-uiid="flow_studio.sidebar.run_history">
      <div class="run-history-header">
        <h3 class="run-history-title">Run History</h3>
        ${renderFilterTabs()}
      </div>
      <div class="run-history-content">
        ${content}
      </div>
      ${renderPaginationInfo()}
    </div>
  `;
    // Attach event listeners
    attachEventListeners(container);
}
/**
 * Attach event listeners to the rendered panel.
 */
function attachEventListeners(container) {
    // Filter tab clicks
    container.querySelectorAll("[data-filter]").forEach(tab => {
        tab.addEventListener("click", () => {
            const filter = tab.dataset.filter;
            filterRuns(filter);
        });
    });
    // Run item clicks
    container.querySelectorAll(".run-history-item").forEach(item => {
        item.addEventListener("click", () => {
            const runId = item.dataset.runId;
            if (runId) {
                void selectHistoryRun(runId);
            }
        });
        // Keyboard support
        item.addEventListener("keydown", (e) => {
            if (e instanceof KeyboardEvent && (e.key === "Enter" || e.key === " ")) {
                e.preventDefault();
                const runId = item.dataset.runId;
                if (runId) {
                    void selectHistoryRun(runId);
                }
            }
        });
    });
    // Retry button click
    const retryBtn = container.querySelector('[data-action="retry-load"]');
    if (retryBtn) {
        retryBtn.addEventListener("click", () => {
            void loadRunHistory().then(() => {
                renderRunHistoryPanel(container);
            });
        });
    }
}
// ============================================================================
// Public Accessors
// ============================================================================
/**
 * Get the currently selected run ID.
 */
export function getSelectedRunId() {
    return _state.selectedRunId;
}
/**
 * Get the current filter type.
 */
export function getCurrentFilter() {
    return _state.currentFilter;
}
/**
 * Get the current runs (filtered).
 */
export function getFilteredRuns() {
    return [..._state.filteredRuns];
}
/**
 * Get all loaded runs.
 */
export function getAllRuns() {
    return [..._state.runs];
}
/**
 * Set the selected run ID without triggering callback.
 * Useful for syncing with external state changes.
 */
export function setSelectedRunId(runId) {
    _state.selectedRunId = runId;
    if (runId) {
        updateSelectionUI(runId);
    }
}
// ============================================================================
// Initialization
// ============================================================================
/**
 * Render run list items into the existing #run-history-list container.
 * This works with the pre-existing HTML structure in index.html.
 */
function renderRunListItems() {
    const listContainer = document.getElementById("run-history-list");
    if (!listContainer)
        return;
    if (_state.isLoading) {
        listContainer.innerHTML = renderRunHistoryLoading();
        return;
    }
    if (_state.error) {
        listContainer.innerHTML = renderRunHistoryError(_state.error);
        // Attach retry handler
        const retryBtn = listContainer.querySelector('[data-action="retry-load"]');
        if (retryBtn) {
            retryBtn.addEventListener("click", () => {
                void initRunHistory();
            });
        }
        return;
    }
    if (_state.filteredRuns.length === 0) {
        listContainer.innerHTML = renderRunHistoryEmpty();
        return;
    }
    // Render run items
    listContainer.innerHTML = _state.filteredRuns.map(run => renderRunHistoryItem(run)).join("");
    // Attach click handlers to run items
    listContainer.querySelectorAll(".run-history-item").forEach(item => {
        item.addEventListener("click", () => {
            const runId = item.dataset.runId;
            if (runId) {
                void selectHistoryRun(runId);
            }
        });
        // Keyboard support
        item.addEventListener("keydown", (e) => {
            if (e instanceof KeyboardEvent && (e.key === "Enter" || e.key === " ")) {
                e.preventDefault();
                const runId = item.dataset.runId;
                if (runId) {
                    void selectHistoryRun(runId);
                }
            }
        });
    });
}
/**
 * Initialize run history handlers on the existing HTML structure.
 * This wires up the filter buttons and collapse toggle that already exist in index.html.
 */
function initRunHistoryHandlers() {
    // Wire up filter buttons
    const filterContainer = document.getElementById("run-history-filter");
    if (filterContainer) {
        filterContainer.querySelectorAll(".filter-btn").forEach(btn => {
            btn.addEventListener("click", () => {
                const filter = btn.dataset.filter;
                if (!filter)
                    return;
                // Update active state on buttons
                filterContainer.querySelectorAll(".filter-btn").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");
                // Apply filter and re-render
                applyFilter(filter);
                renderRunListItems();
            });
        });
    }
    // Wire up collapse toggle
    const toggleBtn = document.getElementById("run-history-toggle");
    const listContainer = document.getElementById("run-history-list");
    if (toggleBtn && listContainer) {
        toggleBtn.addEventListener("click", () => {
            const isExpanded = toggleBtn.getAttribute("aria-expanded") === "true";
            toggleBtn.setAttribute("aria-expanded", isExpanded ? "false" : "true");
            toggleBtn.textContent = isExpanded ? "\u25B6" : "\u25BC"; // Right arrow when collapsed, down arrow when expanded
            listContainer.classList.toggle("collapsed", isExpanded);
        });
    }
}
/**
 * Initialize the run history panel.
 * Loads runs from the API and populates the existing HTML structure.
 *
 * Call this once during app initialization to:
 * - Load initial run data
 * - Wire up filter buttons
 * - Wire up collapse toggle
 * - Render the run list
 *
 * When Teaching Mode is enabled, defaults to "example" filter.
 */
export async function initRunHistory() {
    // Initialize handlers (only need to do this once, but it's idempotent)
    initRunHistoryHandlers();
    // Set initial filter based on Teaching Mode
    const defaultFilter = getDefaultRunHistoryFilter();
    _state.currentFilter = defaultFilter;
    // Update filter button UI to match
    const filterContainer = document.getElementById("run-history-filter");
    if (filterContainer) {
        filterContainer.querySelectorAll(".filter-btn").forEach(btn => {
            const filter = btn.dataset.filter;
            btn.classList.toggle("active", filter === defaultFilter);
        });
    }
    // Load and render
    await loadRunHistory();
    renderRunListItems();
}
// run_detail_modal.js
// swarm/tools/flow_studio_ui/src/run_detail_modal.ts
// Run Detail Modal for Flow Studio
//
// This module handles:
// - Displaying detailed information about a selected run
// - Run metadata (ID, backend, profile, timestamps)
// - Flow progress and status
// - Re-run and close actions
import { Api } from "./api.js";
import { escapeHtml, formatDateTime, createModalFocusManager } from "./utils.js";
import { updateCompactInventory, injectInventoryCSS } from "./inventory_counts.js";
import { updateBoundaryReviewPanel, injectBoundaryReviewCSS } from "./boundary_review.js";
// ============================================================================
// Module State
// ============================================================================
let _callbacks = {};
let _focusManager = null;
let _currentRunId = null;
// ============================================================================
// Configuration
// ============================================================================
/**
 * Configure the run detail modal with callbacks.
 */
export function configure(callbacks = {}) {
    _callbacks = callbacks;
}
// ============================================================================
// Modal Visibility
// ============================================================================
/**
 * Get or create the modal element.
 */
function getOrCreateModal() {
    let modal = document.getElementById("run-detail-modal");
    if (modal)
        return modal;
    // Create modal structure
    modal = document.createElement("div");
    modal.id = "run-detail-modal";
    modal.className = "selftest-modal"; // Reuse selftest modal styling
    modal.setAttribute("data-uiid", "flow_studio.modal.run_detail");
    modal.setAttribute("role", "dialog");
    modal.setAttribute("aria-modal", "true");
    modal.setAttribute("aria-labelledby", "run-detail-modal-title");
    modal.innerHTML = `
    <div class="selftest-step-content" data-uiid="flow_studio.modal.run_detail.body">
      <button class="selftest-modal-close" data-uiid="flow_studio.modal.run_detail.close" aria-label="Close modal">&times;</button>
      <div id="run-detail-modal-content">
        <div class="muted">Loading...</div>
      </div>
    </div>
  `;
    document.body.appendChild(modal);
    // Initialize close handlers
    initModalCloseHandlers(modal);
    return modal;
}
/**
 * Initialize modal close handlers.
 */
function initModalCloseHandlers(modal) {
    // Close on backdrop click
    modal.addEventListener("click", (e) => {
        if (e.target === modal) {
            closeRunDetailModal();
        }
    });
    // Close on Escape key
    modal.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
            e.preventDefault();
            closeRunDetailModal();
        }
    });
    // Close button click
    const closeBtn = modal.querySelector('[data-uiid="flow_studio.modal.run_detail.close"]');
    if (closeBtn) {
        closeBtn.addEventListener("click", () => closeRunDetailModal());
    }
}
/**
 * Toggle modal visibility with focus management.
 */
function toggleModal(show) {
    const modal = getOrCreateModal();
    // Lazy-init focus manager
    if (!_focusManager) {
        _focusManager = createModalFocusManager(modal, ".selftest-step-content");
    }
    if (show) {
        modal.classList.add("open");
        _focusManager.open(document.activeElement);
    }
    else {
        modal.classList.remove("open");
        _focusManager.close();
    }
}
// ============================================================================
// Public API
// ============================================================================
/**
 * Show the run detail modal for a specific run.
 */
export async function showRunDetailModal(runId) {
    _currentRunId = runId;
    const modal = getOrCreateModal();
    const contentEl = modal.querySelector("#run-detail-modal-content");
    if (contentEl) {
        contentEl.innerHTML = '<div class="muted">Loading run details...</div>';
    }
    toggleModal(true);
    try {
        const summary = await Api.getRunSummary(runId);
        if (contentEl) {
            contentEl.innerHTML = renderRunDetailContent(runId, summary);
            attachActionHandlers(modal, runId, summary);
        }
    }
    catch (err) {
        console.error("Failed to load run details", err);
        if (contentEl) {
            contentEl.innerHTML = renderRunDetailError(runId, err);
        }
    }
}
/**
 * Close the run detail modal.
 */
export function closeRunDetailModal() {
    toggleModal(false);
    _currentRunId = null;
    if (_callbacks.onClose) {
        _callbacks.onClose();
    }
}
// ============================================================================
// Rendering
// ============================================================================
/**
 * Render the run detail modal content.
 */
export function renderRunDetailContent(runId, summary) {
    const statusClass = getStatusClass(summary.status);
    const statusLabel = getStatusLabel(summary.status);
    const flowProgress = renderFlowProgress(summary.flows);
    const tagsHtml = renderTags(summary.tags, summary.is_exemplar, runId);
    return `
    <h3 id="run-detail-modal-title" class="selftest-step-title">Run Details</h3>

    <div class="selftest-step-header" style="flex-wrap: wrap; gap: 8px;">
      <div class="selftest-step-id">${escapeHtml(runId)}</div>
      <div class="${statusClass}" style="padding: 3px 8px; border-radius: 3px; font-size: 10px; font-weight: 600;">
        ${statusLabel}
      </div>
    </div>

    ${summary.title ? `<div class="fs-text-body" style="margin-bottom: 12px; color: #374151;">${escapeHtml(summary.title)}</div>` : ""}

    <div class="selftest-step-metadata" style="grid-template-columns: 1fr 1fr 1fr;">
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Run ID</div>
        <div class="selftest-metadata-value mono" style="font-size: 11px; word-break: break-all;">${escapeHtml(runId)}</div>
      </div>
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Backend</div>
        <div class="selftest-metadata-value">${escapeHtml(summary.backend || "unknown")}</div>
      </div>
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Profile</div>
        <div class="selftest-metadata-value">${escapeHtml(summary.profile_id || "(none)")}</div>
      </div>
    </div>

    <div class="selftest-step-metadata" style="grid-template-columns: 1fr 1fr 1fr;">
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Created</div>
        <div class="selftest-metadata-value">${formatDateTime(summary.created_at || null)}</div>
      </div>
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Started</div>
        <div class="selftest-metadata-value">${formatDateTime(summary.started_at || null)}</div>
      </div>
      <div class="selftest-metadata-row">
        <div class="selftest-metadata-label">Completed</div>
        <div class="selftest-metadata-value">${formatDateTime(summary.completed_at || null)}</div>
      </div>
    </div>

    <div class="kv-section" style="margin-top: 16px;">
      <div class="kv-label">Flow Progress</div>
      ${flowProgress}
    </div>

    <div class="kv-section" style="margin-top: 16px;" data-uiid="flow_studio.modal.run_detail.inventory">
      <div class="kv-label">Inventory Markers</div>
      <div id="run-detail-inventory-container" data-uiid="flow_studio.modal.run_detail.inventory.container" style="margin-top: 8px;">
        <div class="muted fs-text-xs">Loading inventory...</div>
      </div>
    </div>

    <div class="kv-section" style="margin-top: 16px;" data-uiid="flow_studio.modal.run_detail.boundary">
      <div class="kv-label" style="display: flex; align-items: center; gap: 8px;">
        <span>Boundary Summary</span>
        <button id="run-detail-boundary-toggle" class="fs-button-small" data-uiid="flow_studio.modal.run_detail.boundary.toggle" style="padding: 2px 8px; font-size: 10px;">Load Review</button>
      </div>
      <div id="run-detail-boundary-container" data-uiid="flow_studio.modal.run_detail.boundary.container" style="display: none; margin-top: 8px;">
        <div class="muted fs-text-xs">Click "Load Review" to view boundary data...</div>
      </div>
    </div>

    <div class="kv-section" style="margin-top: 16px;">
      <div class="kv-label" style="display: flex; align-items: center; gap: 8px;">
        <span>Events Timeline</span>
        <button id="run-detail-events-toggle" class="fs-button-small" data-uiid="flow_studio.modal.run_detail.events.toggle" style="padding: 2px 8px; font-size: 10px;">Load Events</button>
      </div>
      <div id="run-detail-events-container" data-uiid="flow_studio.modal.run_detail.events.container" style="display: none; margin-top: 8px; max-height: 200px; overflow-y: auto; background: #f9fafb; border-radius: 4px; padding: 8px;">
        <div class="muted fs-text-xs">Click "Load Events" to view execution events...</div>
      </div>
    </div>

    <div class="kv-section" style="margin-top: 16px;" data-uiid="flow_studio.modal.run_detail.wisdom">
      <div class="kv-label" style="display: flex; align-items: center; gap: 8px;">
        <span>Wisdom Summary</span>
        <button id="run-detail-wisdom-toggle" class="fs-button-small" data-uiid="flow_studio.modal.run_detail.wisdom.toggle" style="padding: 2px 8px; font-size: 10px;">Load Wisdom</button>
      </div>
      <div id="run-detail-wisdom-container" data-uiid="flow_studio.modal.run_detail.wisdom.container" style="display: none; margin-top: 8px; background: #f0fdf4; border-radius: 4px; padding: 12px;">
        <div class="muted fs-text-xs">Click "Load Wisdom" to view wisdom metrics...</div>
      </div>
    </div>

    ${summary.error_message ? `
      <div class="selftest-dependencies" style="background: #fee2e2; border-left-color: #ef4444; margin-top: 16px;">
        <div class="selftest-dependencies-title" style="color: #991b1b;">Error</div>
        <div class="fs-text-sm" style="color: #7f1d1d; word-break: break-word;">${escapeHtml(summary.error_message)}</div>
      </div>
    ` : ""}

    ${tagsHtml}

    <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 20px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
      <div id="run-detail-rerun-error" class="fs-text-sm" style="color: #dc2626; min-height: 0;"></div>
      <div style="display: flex; gap: 12px;">
        <button id="run-detail-rerun-btn" data-uiid="flow_studio.modal.run_detail.rerun" class="fs-button-primary" style="flex: 1;">
          Re-run
        </button>
        <button id="run-detail-close-btn" class="fs-button-small" style="flex: 1;">
          Close
        </button>
      </div>
    </div>
  `;
}
/**
 * Render error state for run detail modal.
 */
function renderRunDetailError(runId, error) {
    return `
    <h3 id="run-detail-modal-title" class="selftest-step-title">Run Details</h3>

    <div class="fs-error" style="margin: 16px 0;">
      <div class="fs-error-icon">\u26A0\uFE0F</div>
      <p class="fs-error-title">Failed to load run</p>
      <p class="fs-error-description">${escapeHtml(error.message || "Unknown error")}</p>
    </div>

    <div class="selftest-step-header">
      <div class="selftest-step-id">${escapeHtml(runId)}</div>
    </div>

    <div style="display: flex; gap: 12px; margin-top: 20px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
      <button id="run-detail-close-btn" class="fs-button-small" style="flex: 1;">
        Close
      </button>
    </div>
  `;
}
/**
 * Render flow progress section.
 */
function renderFlowProgress(flows) {
    if (!flows) {
        return '<div class="muted fs-text-sm">No flow data available</div>';
    }
    const flowOrder = ["signal", "plan", "build", "gate", "deploy", "wisdom", "stepwise-demo"];
    const flowLabels = {
        signal: "Signal",
        plan: "Plan",
        build: "Build",
        gate: "Gate",
        deploy: "Deploy",
        wisdom: "Wisdom",
        "stepwise-demo": "Stepwise"
    };
    const flowItems = flowOrder.map(key => {
        const flowData = flows[key];
        const status = flowData?.status || "not_started";
        const icon = getFlowStatusIcon(status);
        const statusClass = getFlowStatusClass(status);
        const label = flowLabels[key] || key;
        return `
      <div class="flow-progress-item" style="display: flex; align-items: center; gap: 8px; padding: 6px 0; border-bottom: 1px solid #f3f4f6;">
        <span class="flow-progress-icon" style="font-size: 14px;">${icon}</span>
        <span class="flow-progress-label fs-text-sm" style="flex: 1;">${escapeHtml(label)}</span>
        <span class="flow-progress-status ${statusClass}" style="font-size: 11px; font-weight: 500;">${escapeHtml(status.toUpperCase())}</span>
      </div>
    `;
    });
    return `<div class="flow-progress-list">${flowItems.join("")}</div>`;
}
/**
 * Render tags and exemplar checkbox.
 */
function renderTags(tags, isExemplar, runId) {
    const tagBadges = [];
    if (tags && tags.length > 0) {
        tags.forEach(tag => {
            tagBadges.push(`<span class="selftest-ac-badge">${escapeHtml(tag)}</span>`);
        });
    }
    const exemplarChecked = isExemplar ? "checked" : "";
    return `
    <div class="kv-section" style="margin-top: 16px;">
      <div class="kv-label">Run Settings</div>
      <div style="margin-top: 8px;">
        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
          <input
            type="checkbox"
            id="run-detail-exemplar-checkbox"
            data-uiid="flow_studio.modal.run_detail.exemplar"
            ${exemplarChecked}
            style="width: 16px; height: 16px; cursor: pointer;"
          />
          <span>Mark as Exemplar</span>
          <span class="muted fs-text-xs" style="margin-left: 4px;">(Reference implementation)</span>
        </label>
        <div id="run-detail-exemplar-status" class="fs-text-xs muted" style="margin-left: 24px; margin-top: 4px; min-height: 16px;"></div>
      </div>
      ${tagBadges.length > 0 ? `
        <div style="margin-top: 12px;">
          <div class="kv-label">Tags</div>
          <div class="selftest-ac-badges" style="margin-top: 6px;">
            ${tagBadges.join("")}
          </div>
        </div>
      ` : ""}
    </div>
  `;
}
// ============================================================================
// Status Helpers
// ============================================================================
/**
 * Get CSS class for run status.
 */
function getStatusClass(status) {
    switch (status) {
        case "completed":
            return "fs-status-badge success";
        case "running":
            return "fs-status-badge info";
        case "failed":
            return "fs-status-badge error";
        case "canceled":
            return "fs-status-badge warning";
        case "pending":
        default:
            return "fs-status-badge";
    }
}
/**
 * Get label for run status.
 */
function getStatusLabel(status) {
    switch (status) {
        case "completed":
            return "\u2713 COMPLETED";
        case "running":
            return "\u25CF RUNNING";
        case "failed":
            return "\u2717 FAILED";
        case "canceled":
            return "\u2014 CANCELED";
        case "pending":
            return "\u2026 PENDING";
        default:
            return "\u2014 UNKNOWN";
    }
}
/**
 * Get icon for flow status.
 */
function getFlowStatusIcon(status) {
    switch (status) {
        case "done":
        case "complete":
            return "\u2705";
        case "in_progress":
            return "\u23F3";
        case "partial":
            return "\u26A0\uFE0F";
        case "missing":
        case "not_started":
        default:
            return "\u2B1C";
    }
}
/**
 * Get CSS class for flow status.
 */
function getFlowStatusClass(status) {
    switch (status) {
        case "done":
        case "complete":
            return "status-complete";
        case "in_progress":
            return "status-partial";
        case "partial":
            return "status-partial";
        case "missing":
            return "status-missing";
        case "not_started":
        default:
            return "status-na";
    }
}
// ============================================================================
// Action Handlers
// ============================================================================
/**
 * Attach action handlers to modal buttons.
 */
function attachActionHandlers(modal, runId, summary) {
    // Inject CSS for inventory and boundary components
    injectInventoryCSS();
    injectBoundaryReviewCSS();
    // Load inventory counts immediately (compact view)
    const inventoryContainer = modal.querySelector("#run-detail-inventory-container");
    if (inventoryContainer) {
        updateCompactInventory(inventoryContainer, runId).catch((err) => {
            console.error("Failed to load inventory counts", err);
            inventoryContainer.innerHTML = '<span class="muted fs-text-xs">Failed to load inventory data.</span>';
        });
    }
    // Boundary review toggle button (lazy-load on click)
    const boundaryToggle = modal.querySelector("#run-detail-boundary-toggle");
    const boundaryContainer = modal.querySelector("#run-detail-boundary-container");
    if (boundaryToggle && boundaryContainer) {
        boundaryToggle.addEventListener("click", async () => {
            const btn = boundaryToggle;
            const container = boundaryContainer;
            // Toggle visibility
            if (container.style.display === "none") {
                container.style.display = "block";
                btn.textContent = "Loading...";
                btn.disabled = true;
                try {
                    await updateBoundaryReviewPanel(container, runId, { scope: "run" });
                    btn.textContent = "Hide Review";
                }
                catch (err) {
                    console.error("Failed to load boundary review", err);
                    container.innerHTML = `<div class="fs-text-xs" style="color: #dc2626;">Failed to load boundary review: ${escapeHtml(err.message || "Unknown error")}</div>`;
                    btn.textContent = "Retry";
                }
                finally {
                    btn.disabled = false;
                }
            }
            else {
                container.style.display = "none";
                btn.textContent = "Load Review";
            }
        });
    }
    // Exemplar checkbox
    const exemplarCheckbox = modal.querySelector("#run-detail-exemplar-checkbox");
    const exemplarStatus = modal.querySelector("#run-detail-exemplar-status");
    if (exemplarCheckbox) {
        exemplarCheckbox.addEventListener("change", async () => {
            const isExemplar = exemplarCheckbox.checked;
            exemplarCheckbox.disabled = true;
            if (exemplarStatus) {
                exemplarStatus.textContent = isExemplar ? "Marking as exemplar..." : "Removing exemplar status...";
                exemplarStatus.className = "fs-text-xs muted";
            }
            try {
                await Api.setRunExemplar(runId, isExemplar);
                if (exemplarStatus) {
                    exemplarStatus.textContent = isExemplar ? "Marked as exemplar" : "Exemplar status removed";
                    exemplarStatus.className = "fs-text-xs";
                    exemplarStatus.style.color = "#059669"; // Green for success
                    // Clear success message after 2 seconds
                    setTimeout(() => {
                        if (exemplarStatus) {
                            exemplarStatus.textContent = "";
                        }
                    }, 2000);
                }
            }
            catch (err) {
                console.error("Failed to update exemplar status", err);
                // Revert checkbox state on error
                exemplarCheckbox.checked = !isExemplar;
                if (exemplarStatus) {
                    exemplarStatus.textContent = `Error: ${err.message || "Failed to update"}`;
                    exemplarStatus.className = "fs-text-xs";
                    exemplarStatus.style.color = "#dc2626"; // Red for error
                }
            }
            finally {
                exemplarCheckbox.disabled = false;
            }
        });
    }
    // Re-run button
    const rerunBtn = modal.querySelector("#run-detail-rerun-btn");
    if (rerunBtn) {
        rerunBtn.addEventListener("click", async () => {
            const btn = rerunBtn;
            btn.disabled = true;
            btn.textContent = "Starting...";
            try {
                // Determine flows to run based on the original run's flows
                const flowsToRun = summary?.flows
                    ? Object.keys(summary.flows).filter(key => {
                        const flowData = summary.flows[key];
                        return flowData && flowData.status !== "not_started";
                    })
                    : ["signal", "plan", "build", "gate", "deploy", "wisdom"]; // Default: all flows
                // Start the new run via API
                const result = await Api.startRun({
                    flows: flowsToRun,
                    profile_id: summary?.profile_id,
                    backend: summary?.backend,
                });
                // Started new run: result.run_id
                // Call the callback if provided (for additional UI updates)
                if (_callbacks.onRerun) {
                    await _callbacks.onRerun(runId);
                }
                closeRunDetailModal();
            }
            catch (err) {
                console.error("Failed to re-run", err);
                btn.textContent = "Re-run";
                btn.disabled = false;
                // Show error in a status area if available
                const errorArea = modal.querySelector("#run-detail-rerun-error");
                if (errorArea) {
                    errorArea.textContent = `Error: ${err.message || "Failed to start run"}`;
                }
            }
        });
    }
    // Close button
    const closeBtn = modal.querySelector("#run-detail-close-btn");
    if (closeBtn) {
        closeBtn.addEventListener("click", () => closeRunDetailModal());
    }
    // Events toggle button
    const eventsToggle = modal.querySelector("#run-detail-events-toggle");
    const eventsContainer = modal.querySelector("#run-detail-events-container");
    if (eventsToggle && eventsContainer) {
        eventsToggle.addEventListener("click", async () => {
            const btn = eventsToggle;
            const container = eventsContainer;
            // Toggle visibility
            if (container.style.display === "none") {
                container.style.display = "block";
                btn.textContent = "Loading...";
                btn.disabled = true;
                try {
                    const response = await Api.getRunEvents(runId);
                    container.innerHTML = renderEventsTimeline(response.events);
                    btn.textContent = "Hide Events";
                }
                catch (err) {
                    console.error("Failed to load events", err);
                    container.innerHTML = `<div class="fs-text-xs" style="color: #dc2626;">Failed to load events: ${escapeHtml(err.message || "Unknown error")}</div>`;
                    btn.textContent = "Retry";
                }
                finally {
                    btn.disabled = false;
                }
            }
            else {
                container.style.display = "none";
                btn.textContent = "Load Events";
            }
        });
    }
    // Wisdom toggle button
    const wisdomToggle = modal.querySelector("#run-detail-wisdom-toggle");
    const wisdomContainer = modal.querySelector("#run-detail-wisdom-container");
    if (wisdomToggle && wisdomContainer) {
        wisdomToggle.addEventListener("click", async () => {
            const btn = wisdomToggle;
            const container = wisdomContainer;
            // Toggle visibility
            if (container.style.display === "none") {
                container.style.display = "block";
                btn.textContent = "Loading...";
                btn.disabled = true;
                try {
                    const wisdom = await Api.getRunWisdom(runId);
                    container.innerHTML = renderWisdomSummary(wisdom);
                    btn.textContent = "Hide Wisdom";
                }
                catch (err) {
                    console.error("Failed to load wisdom", err);
                    // 404 means no wisdom available - show helpful message
                    const errorMsg = err.message || "Unknown error";
                    if (errorMsg.includes("404")) {
                        container.innerHTML = renderWisdomEmpty(runId);
                    }
                    else {
                        container.innerHTML = `<div class="fs-text-xs" style="color: #dc2626;">Failed to load wisdom: ${escapeHtml(errorMsg)}</div>`;
                    }
                    btn.textContent = "Retry";
                }
                finally {
                    btn.disabled = false;
                }
            }
            else {
                container.style.display = "none";
                btn.textContent = "Load Wisdom";
            }
        });
    }
}
/**
 * Render events timeline.
 */
function renderEventsTimeline(events) {
    if (!events || events.length === 0) {
        return '<div class="muted fs-text-xs">No events recorded for this run.</div>';
    }
    const eventItems = events.map(event => {
        const time = event.ts ? new Date(event.ts).toLocaleTimeString() : "";
        const kindClass = getEventKindClass(event.kind);
        const payload = event.payload ? JSON.stringify(event.payload).slice(0, 100) : "";
        return `
      <div class="run-event-item" style="display: flex; gap: 8px; padding: 4px 0; border-bottom: 1px solid #e5e7eb; font-size: 11px;">
        <span class="mono" style="color: #6b7280; flex-shrink: 0; width: 70px;">${escapeHtml(time)}</span>
        <span class="${kindClass}" style="flex-shrink: 0; width: 100px; font-weight: 500;">${escapeHtml(event.kind)}</span>
        <span style="color: #9ca3af; flex-shrink: 0; width: 60px;">${escapeHtml(event.flow_key)}</span>
        ${event.step_id ? `<span style="color: #6b7280;">${escapeHtml(event.step_id)}</span>` : ""}
        ${payload ? `<span class="mono" style="color: #9ca3af; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(payload)}</span>` : ""}
      </div>
    `;
    }).join("");
    return `<div class="run-events-list">${eventItems}</div>`;
}
/**
 * Get CSS class for event kind.
 */
function getEventKindClass(kind) {
    if (kind.includes("error") || kind.includes("fail"))
        return "fs-text-error";
    if (kind.includes("start") || kind.includes("created"))
        return "fs-text-info";
    if (kind.includes("end") || kind.includes("complete"))
        return "fs-text-success";
    return "";
}
/**
 * Render wisdom summary content.
 */
function renderWisdomSummary(wisdom) {
    const { summary, flows, labels, created_at } = wisdom;
    // Flow status rows
    const flowOrder = ["signal", "plan", "build", "gate", "deploy", "wisdom"];
    const flowRows = flowOrder.map(key => {
        const flowData = flows[key];
        const status = flowData?.status || "unknown";
        const dot = getWisdomStatusDot(status);
        const loopInfo = getLoopInfo(flowData);
        return `
      <div style="display: flex; align-items: center; gap: 8px; padding: 4px 0; border-bottom: 1px solid #d1fae5;">
        <span>${dot}</span>
        <span style="width: 60px; font-weight: 500; text-transform: capitalize;">${escapeHtml(key)}</span>
        <span style="color: #059669; font-size: 12px;">${escapeHtml(status)}</span>
        ${loopInfo ? `<span style="color: #6b7280; font-size: 11px; margin-left: auto;">${escapeHtml(loopInfo)}</span>` : ""}
      </div>
    `;
    }).join("");
    // Labels badges
    const labelBadges = labels.length > 0
        ? labels.map(l => `<span class="selftest-ac-badge" style="background: #dcfce7; color: #166534;">${escapeHtml(l)}</span>`).join(" ")
        : '<span class="muted fs-text-xs">No labels</span>';
    return `
    <div data-uiid="flow_studio.modal.run_detail.wisdom.summary">
      <div style="font-size: 11px; color: #6b7280; margin-bottom: 12px;">
        Generated: ${created_at ? formatDateTime(created_at) : "Unknown"}
      </div>

      <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 16px;">
        <div style="background: #f0fdf4; padding: 8px; border-radius: 4px; text-align: center;">
          <div style="font-size: 20px; font-weight: 600; color: #166534;">${summary.artifacts_present}</div>
          <div style="font-size: 10px; color: #6b7280;">Artifacts</div>
        </div>
        <div style="background: ${summary.regressions_found > 0 ? "#fef2f2" : "#f0fdf4"}; padding: 8px; border-radius: 4px; text-align: center;">
          <div style="font-size: 20px; font-weight: 600; color: ${summary.regressions_found > 0 ? "#dc2626" : "#166534"};">${summary.regressions_found}</div>
          <div style="font-size: 10px; color: #6b7280;">Regressions</div>
        </div>
        <div style="background: #f0fdf4; padding: 8px; border-radius: 4px; text-align: center;">
          <div style="font-size: 20px; font-weight: 600; color: #166534;">${summary.learnings_count}</div>
          <div style="font-size: 10px; color: #6b7280;">Learnings</div>
        </div>
      </div>

      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
        <div style="background: #eff6ff; padding: 8px; border-radius: 4px; text-align: center;">
          <div style="font-size: 16px; font-weight: 600; color: #1d4ed8;">${summary.feedback_actions_count}</div>
          <div style="font-size: 10px; color: #6b7280;">Feedback Actions</div>
        </div>
        <div style="background: #fefce8; padding: 8px; border-radius: 4px; text-align: center;">
          <div style="font-size: 16px; font-weight: 600; color: #a16207;">${summary.issues_created}</div>
          <div style="font-size: 10px; color: #6b7280;">Issues Created</div>
        </div>
      </div>

      <div style="margin-bottom: 12px;">
        <div style="font-weight: 500; margin-bottom: 6px; font-size: 12px;">Flow Status</div>
        ${flowRows}
      </div>

      <div>
        <div style="font-weight: 500; margin-bottom: 6px; font-size: 12px;">Labels</div>
        <div style="display: flex; flex-wrap: wrap; gap: 4px;">
          ${labelBadges}
        </div>
      </div>
    </div>
  `;
}
/**
 * Get status dot for wisdom flow status.
 */
function getWisdomStatusDot(status) {
    const colors = {
        succeeded: "#22c55e",
        failed: "#ef4444",
        skipped: "#9ca3af",
        partial: "#eab308",
    };
    const color = colors[status] || "#9ca3af";
    return `<span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${color};"></span>`;
}
/**
 * Get loop info string for flow data.
 */
function getLoopInfo(flowData) {
    if (!flowData)
        return "";
    const parts = [];
    if (flowData.microloops)
        parts.push(`Œº:${flowData.microloops}`);
    if (flowData.test_loops)
        parts.push(`T:${flowData.test_loops}`);
    if (flowData.code_loops)
        parts.push(`C:${flowData.code_loops}`);
    return parts.join(" ");
}
/**
 * Render empty wisdom state.
 */
function renderWisdomEmpty(runId) {
    return `
    <div data-uiid="flow_studio.modal.run_detail.wisdom.empty" style="text-align: center; padding: 16px;">
      <div style="font-size: 24px; margin-bottom: 8px;">üìä</div>
      <div style="font-weight: 500; color: #374151; margin-bottom: 4px;">No Wisdom Data</div>
      <div class="muted fs-text-xs" style="margin-bottom: 12px;">
        Wisdom summary not yet generated for this run.
      </div>
      <div style="background: #f9fafb; border-radius: 4px; padding: 8px; font-family: monospace; font-size: 11px; color: #6b7280;">
        uv run swarm/tools/wisdom_summarizer.py ${escapeHtml(runId)}
      </div>
    </div>
  `;
}
// ============================================================================
// Window Exports (for onclick handlers in HTML)
// ============================================================================
if (typeof window !== "undefined") {
    window.showRunDetailModal = showRunDetailModal;
    window.closeRunDetailModal = closeRunDetailModal;
}
// boundary_review.js
// swarm/tools/flow_studio_ui/src/boundary_review.ts
// Boundary review panel for Flow Studio
//
// Displays aggregated run state at flow boundaries:
// - Assumptions (count, high-risk, details)
// - Decisions (count, details)
// - Detours taken
// - Verification results
// - Evolution suggestions (if present)
import { Api } from "./api.js";
// =============================================================================
// State
// =============================================================================
let currentRunId = null;
let currentData = null;
let isExpanded = false;
// Monotonic sequence counter for request coalescing
// Prevents out-of-order UI renders under bursty SSE events
let loadSeq = 0;
// =============================================================================
// Confidence Badge Rendering
// =============================================================================
function getConfidenceBadgeClass(score) {
    if (score >= 0.8)
        return "confidence-high";
    if (score >= 0.5)
        return "confidence-medium";
    return "confidence-low";
}
function getConfidenceLabel(score) {
    if (score >= 0.8)
        return "High";
    if (score >= 0.5)
        return "Medium";
    return "Low";
}
// =============================================================================
// Assumption Rendering
// =============================================================================
function renderAssumptionCard(assumption) {
    const confidenceClass = `assumption-${assumption.confidence}`;
    const statusClass = assumption.status === "active" ? "status-active" : "status-resolved";
    return `
    <div class="boundary-card assumption-card ${confidenceClass}" data-assumption-id="${assumption.assumption_id}">
      <div class="card-header">
        <span class="card-id">${assumption.assumption_id}</span>
        <span class="card-status ${statusClass}">${assumption.status}</span>
        <span class="card-confidence confidence-${assumption.confidence}">${assumption.confidence}</span>
      </div>
      <div class="card-statement">${escapeHtml(assumption.statement)}</div>
      <details class="card-details">
        <summary>Details</summary>
        <div class="card-detail-row">
          <label>Rationale:</label>
          <span>${escapeHtml(assumption.rationale)}</span>
        </div>
        <div class="card-detail-row">
          <label>Impact if wrong:</label>
          <span>${escapeHtml(assumption.impact_if_wrong)}</span>
        </div>
        ${assumption.agent ? `
        <div class="card-detail-row">
          <label>Agent:</label>
          <span class="agent-badge">${escapeHtml(assumption.agent)}</span>
        </div>
        ` : ""}
        ${assumption.tags.length > 0 ? `
        <div class="card-detail-row">
          <label>Tags:</label>
          <span class="tag-list">${assumption.tags.map(t => `<span class="tag">${escapeHtml(t)}</span>`).join("")}</span>
        </div>
        ` : ""}
      </details>
    </div>
  `;
}
// =============================================================================
// Decision Rendering
// =============================================================================
function renderDecisionCard(decision) {
    return `
    <div class="boundary-card decision-card" data-decision-id="${decision.decision_id}">
      <div class="card-header">
        <span class="card-id">${decision.decision_id}</span>
        <span class="card-type">${escapeHtml(decision.decision_type)}</span>
      </div>
      <div class="card-subject">${escapeHtml(decision.subject)}</div>
      <div class="card-decision">${escapeHtml(decision.decision)}</div>
      <details class="card-details">
        <summary>Details</summary>
        <div class="card-detail-row">
          <label>Rationale:</label>
          <span>${escapeHtml(decision.rationale)}</span>
        </div>
        ${decision.supporting_evidence.length > 0 ? `
        <div class="card-detail-row">
          <label>Evidence:</label>
          <span>${decision.supporting_evidence.map(e => escapeHtml(e)).join(", ")}</span>
        </div>
        ` : ""}
        ${decision.assumptions_applied.length > 0 ? `
        <div class="card-detail-row">
          <label>Assumptions:</label>
          <span>${decision.assumptions_applied.map(a => `<span class="assumption-ref">${escapeHtml(a)}</span>`).join(" ")}</span>
        </div>
        ` : ""}
        ${decision.agent ? `
        <div class="card-detail-row">
          <label>Agent:</label>
          <span class="agent-badge">${escapeHtml(decision.agent)}</span>
        </div>
        ` : ""}
      </details>
    </div>
  `;
}
// =============================================================================
// Detour Rendering
// =============================================================================
function renderDetourCard(detour) {
    return `
    <div class="boundary-card detour-card" data-detour-id="${detour.detour_id}">
      <div class="card-header">
        <span class="card-id">${detour.detour_id}</span>
        <span class="card-type">${escapeHtml(detour.detour_type)}</span>
      </div>
      <div class="card-path">
        <span class="from-step">${escapeHtml(detour.from_step)}</span>
        <span class="arrow">‚Üí</span>
        <span class="to-step">${escapeHtml(detour.to_step)}</span>
      </div>
      <div class="card-reason">${escapeHtml(detour.reason)}</div>
    </div>
  `;
}
// =============================================================================
// Verification Rendering
// =============================================================================
function renderVerificationCard(verification) {
    const statusClass = verification.verified ? "status-verified" : "status-unverified";
    const icon = verification.verified ? "‚úì" : "‚úó";
    return `
    <div class="boundary-card verification-card ${statusClass}" data-step-id="${verification.step_id}">
      <div class="card-header">
        <span class="status-icon">${icon}</span>
        <span class="card-id">${escapeHtml(verification.step_id)}</span>
        <span class="card-status">${escapeHtml(verification.status)}</span>
      </div>
      ${verification.station_id ? `
      <div class="card-station">Station: ${escapeHtml(verification.station_id)}</div>
      ` : ""}
      ${verification.issues.length > 0 ? `
      <div class="card-issues">
        <ul>
          ${verification.issues.map(i => `<li>${escapeHtml(i)}</li>`).join("")}
        </ul>
      </div>
      ` : ""}
    </div>
  `;
}
// =============================================================================
// Main Panel Rendering
// =============================================================================
function renderSummaryBar(data) {
    const confidenceClass = getConfidenceBadgeClass(data.confidence_score);
    const confidenceLabel = getConfidenceLabel(data.confidence_score);
    const confidencePercent = Math.round(data.confidence_score * 100);
    return `
    <div class="boundary-summary-bar">
      <div class="summary-item confidence-summary ${confidenceClass}">
        <span class="summary-label">Confidence</span>
        <span class="summary-value">${confidencePercent}% (${confidenceLabel})</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Assumptions</span>
        <span class="summary-value">${data.assumptions_count}${data.assumptions_high_risk > 0 ? ` (${data.assumptions_high_risk} high-risk)` : ""}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Decisions</span>
        <span class="summary-value">${data.decisions_count}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Detours</span>
        <span class="summary-value">${data.detours_count}</span>
      </div>
      <div class="summary-item">
        <span class="summary-label">Verification</span>
        <span class="summary-value verification-summary">
          <span class="passed">${data.verification_passed} ‚úì</span>
          ${data.verification_failed > 0 ? `<span class="failed">${data.verification_failed} ‚úó</span>` : ""}
        </span>
      </div>
      ${data.has_evolution_patches ? `
      <div class="summary-item evolution-summary">
        <span class="summary-label">Evolution</span>
        <span class="summary-value">${data.evolution_patch_count} patches pending</span>
      </div>
      ` : ""}
    </div>
  `;
}
function renderUncertaintyNotes(notes) {
    if (notes.length === 0)
        return "";
    return `
    <div class="uncertainty-notes">
      <h4>Uncertainty Notes</h4>
      <ul>
        ${notes.map(n => `<li>${escapeHtml(n)}</li>`).join("")}
      </ul>
    </div>
  `;
}
function renderSection(title, items, collapsed = false) {
    if (items.length === 0)
        return "";
    const openAttr = collapsed ? "" : "open";
    return `
    <details class="boundary-section" ${openAttr}>
      <summary>${title} (${items.length})</summary>
      <div class="section-content">
        ${items.join("")}
      </div>
    </details>
  `;
}
export function renderBoundaryReviewPanel(data) {
    const assumptionCards = data.assumptions.map(renderAssumptionCard);
    const decisionCards = data.decisions.map(renderDecisionCard);
    const detourCards = data.detours.map(renderDetourCard);
    const verificationCards = data.verifications.map(renderVerificationCard);
    return `
    <div class="boundary-review-panel" data-run-id="${data.run_id}" data-scope="${data.scope}">
      <div class="panel-header">
        <h3>Boundary Review</h3>
        ${data.current_flow ? `<span class="current-flow">Flow: ${data.current_flow}</span>` : ""}
        <button class="toggle-expand" title="Toggle expand">
          ${isExpanded ? "‚ñº" : "‚ñ∂"}
        </button>
      </div>

      ${renderSummaryBar(data)}
      ${renderUncertaintyNotes(data.uncertainty_notes)}

      <div class="boundary-sections ${isExpanded ? "expanded" : "collapsed"}">
        ${renderSection("Assumptions", assumptionCards, assumptionCards.length > 5)}
        ${renderSection("Decisions", decisionCards, decisionCards.length > 5)}
        ${renderSection("Detours", detourCards)}
        ${renderSection("Verification Results", verificationCards, verificationCards.length > 5)}
      </div>
    </div>
  `;
}
// =============================================================================
// Public API
// =============================================================================
/**
 * Load and render boundary review for a run.
 * Uses monotonic request ID guard to prevent out-of-order UI renders
 * when multiple requests are in flight (e.g., under bursty SSE).
 */
export async function loadBoundaryReview(runId, options) {
    const seq = ++loadSeq;
    try {
        currentRunId = runId;
        const data = await Api.getBoundaryReview(runId, options);
        // Ignore stale response if a newer request was initiated
        if (seq !== loadSeq) {
            return currentData;
        }
        currentData = data;
        return currentData;
    }
    catch (err) {
        // Only update state if this is still the latest request
        if (seq === loadSeq) {
            console.error("Failed to load boundary review:", err);
            currentData = null;
        }
        return null;
    }
}
/**
 * Get the current boundary review data.
 */
export function getCurrentBoundaryData() {
    return currentData;
}
/**
 * Toggle the expanded state of the panel.
 */
export function toggleExpanded() {
    isExpanded = !isExpanded;
}
/**
 * Set up event handlers for the boundary review panel.
 */
export function setupBoundaryReviewHandlers(container) {
    // Toggle expand button
    container.addEventListener("click", (e) => {
        const target = e.target;
        if (target.classList.contains("toggle-expand")) {
            toggleExpanded();
            const sections = container.querySelector(".boundary-sections");
            if (sections) {
                sections.classList.toggle("expanded", isExpanded);
                sections.classList.toggle("collapsed", !isExpanded);
            }
            target.textContent = isExpanded ? "‚ñº" : "‚ñ∂";
        }
    });
}
/**
 * Update the boundary review panel in a container.
 */
export async function updateBoundaryReviewPanel(container, runId, options) {
    const data = await loadBoundaryReview(runId, options);
    if (data) {
        container.innerHTML = renderBoundaryReviewPanel(data);
        setupBoundaryReviewHandlers(container);
    }
    else {
        container.innerHTML = `
      <div class="boundary-review-panel empty">
        <div class="panel-header">
          <h3>Boundary Review</h3>
        </div>
        <div class="empty-message">No boundary data available for this run.</div>
      </div>
    `;
    }
}
// =============================================================================
// Utility
// =============================================================================
function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
}
// =============================================================================
// CSS (injected on first use)
// =============================================================================
let cssInjected = false;
export function injectBoundaryReviewCSS() {
    if (cssInjected)
        return;
    cssInjected = true;
    const style = document.createElement("style");
    style.textContent = `
    .boundary-review-panel {
      background: var(--bg-secondary, #f5f5f5);
      border-radius: 8px;
      padding: 16px;
      margin: 8px 0;
    }

    .boundary-review-panel .panel-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .boundary-review-panel .panel-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }

    .boundary-review-panel .current-flow {
      color: var(--text-secondary, #666);
      font-size: 12px;
    }

    .boundary-review-panel .toggle-expand {
      margin-left: auto;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 12px;
      padding: 4px 8px;
    }

    .boundary-summary-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      margin-bottom: 12px;
      padding: 8px;
      background: var(--bg-tertiary, #e8e8e8);
      border-radius: 4px;
    }

    .summary-item {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .summary-label {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--text-tertiary, #888);
    }

    .summary-value {
      font-size: 14px;
      font-weight: 500;
    }

    .confidence-summary.confidence-high { color: #22c55e; }
    .confidence-summary.confidence-medium { color: #f59e0b; }
    .confidence-summary.confidence-low { color: #ef4444; }

    .verification-summary .passed { color: #22c55e; }
    .verification-summary .failed { color: #ef4444; margin-left: 8px; }

    .evolution-summary .summary-value { color: #8b5cf6; }

    .uncertainty-notes {
      background: #fef3c7;
      border: 1px solid #fbbf24;
      border-radius: 4px;
      padding: 8px 12px;
      margin-bottom: 12px;
    }

    .uncertainty-notes h4 {
      margin: 0 0 4px 0;
      font-size: 12px;
      color: #92400e;
    }

    .uncertainty-notes ul {
      margin: 0;
      padding-left: 16px;
      font-size: 12px;
      color: #78350f;
    }

    .boundary-sections.collapsed .boundary-section:not([open]) .section-content {
      display: none;
    }

    .boundary-section {
      margin-bottom: 8px;
      border: 1px solid var(--border-color, #ddd);
      border-radius: 4px;
      overflow: hidden;
    }

    .boundary-section summary {
      padding: 8px 12px;
      background: var(--bg-tertiary, #e8e8e8);
      cursor: pointer;
      font-weight: 500;
    }

    .section-content {
      padding: 8px;
      display: grid;
      gap: 8px;
    }

    .boundary-card {
      background: white;
      border: 1px solid var(--border-color, #ddd);
      border-radius: 4px;
      padding: 8px 12px;
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .card-id {
      font-family: monospace;
      font-size: 11px;
      color: var(--text-tertiary, #888);
    }

    .card-status {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .status-active { background: #dbeafe; color: #1d4ed8; }
    .status-resolved { background: #dcfce7; color: #166534; }

    .card-confidence {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: auto;
    }

    .confidence-high { background: #dcfce7; color: #166534; }
    .confidence-medium { background: #fef3c7; color: #92400e; }
    .confidence-low { background: #fee2e2; color: #991b1b; }

    .assumption-card.assumption-low {
      border-left: 3px solid #ef4444;
    }

    .card-statement, .card-subject, .card-decision, .card-reason {
      font-size: 13px;
      margin-bottom: 4px;
    }

    .card-details {
      margin-top: 8px;
      font-size: 12px;
    }

    .card-details summary {
      cursor: pointer;
      color: var(--text-secondary, #666);
    }

    .card-detail-row {
      display: flex;
      gap: 8px;
      margin-top: 4px;
    }

    .card-detail-row label {
      color: var(--text-tertiary, #888);
      min-width: 100px;
    }

    .agent-badge, .tag {
      display: inline-block;
      padding: 1px 6px;
      background: var(--bg-tertiary, #e8e8e8);
      border-radius: 3px;
      font-size: 11px;
    }

    .tag-list {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .assumption-ref {
      font-family: monospace;
      font-size: 10px;
      padding: 1px 4px;
      background: #dbeafe;
      border-radius: 2px;
    }

    .card-type {
      font-size: 10px;
      text-transform: uppercase;
      color: var(--text-tertiary, #888);
    }

    .card-path {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: monospace;
      font-size: 12px;
    }

    .card-path .arrow {
      color: var(--text-tertiary, #888);
    }

    .verification-card.status-verified {
      border-left: 3px solid #22c55e;
    }

    .verification-card.status-unverified {
      border-left: 3px solid #ef4444;
    }

    .status-icon {
      font-weight: bold;
    }

    .status-verified .status-icon { color: #22c55e; }
    .status-unverified .status-icon { color: #ef4444; }

    .card-station {
      font-size: 11px;
      color: var(--text-tertiary, #888);
    }

    .card-issues ul {
      margin: 4px 0 0 0;
      padding-left: 16px;
      font-size: 12px;
      color: #991b1b;
    }

    .boundary-review-panel.empty {
      text-align: center;
      color: var(--text-secondary, #666);
    }

    .empty-message {
      padding: 24px;
      font-style: italic;
    }
  `;
    document.head.appendChild(style);
}
// context_budget_settings.js
/**
 * Context Budget Settings Module
 *
 * Provides state management and UI for context budget configuration.
 * Follows the same pattern as teaching_mode.ts.
 */
// ============================================================================
// Constants
// ============================================================================
// Storage key for localStorage persistence
const STORAGE_KEY = "flowStudio.contextBudgetOverrides";
// Default values (matching runtime.yaml defaults in v2.4.0)
const DEFAULT_BUDGETS = {
    context_budget_chars: 200000, // ~50k tokens
    history_max_recent_chars: 60000, // ~15k tokens
    history_max_older_chars: 10000, // ~2.5k tokens
    source: "default",
};
// ============================================================================
// Presets
// ============================================================================
/** Preset configurations for common context budget scenarios */
export const PRESETS = {
    lean: {
        id: "lean",
        label: "Lean (25k tokens)",
        description: "Minimal history for fast execution",
        context_budget_chars: 100000,
        history_max_recent_chars: 30000,
        history_max_older_chars: 5000,
    },
    balanced: {
        id: "balanced",
        label: "Balanced (50k tokens)",
        description: "Default balanced settings",
        context_budget_chars: 200000,
        history_max_recent_chars: 60000,
        history_max_older_chars: 10000,
    },
    heavy: {
        id: "heavy",
        label: "Heavy (100k tokens)",
        description: "Maximum context for complex flows",
        context_budget_chars: 400000,
        history_max_recent_chars: 120000,
        history_max_older_chars: 20000,
    },
};
// ============================================================================
// Internal State
// ============================================================================
let _profileOverride = null;
let _effectiveBudgets = { ...DEFAULT_BUDGETS };
let _initialized = false;
/** Registered callbacks */
const _callbacks = [];
// ============================================================================
// localStorage Helpers
// ============================================================================
/**
 * Read profile override from localStorage.
 * Returns null if localStorage is unavailable or key is missing.
 */
function readFromStorage() {
    if (typeof window === "undefined")
        return null;
    try {
        const stored = window.localStorage.getItem(STORAGE_KEY);
        if (stored) {
            return JSON.parse(stored);
        }
    }
    catch (e) {
        console.warn("Failed to read context budget overrides from storage:", e);
    }
    return null;
}
/**
 * Write profile override to localStorage.
 * Silently fails if localStorage is unavailable.
 */
function writeToStorage(override) {
    if (typeof window === "undefined")
        return;
    try {
        if (override) {
            window.localStorage.setItem(STORAGE_KEY, JSON.stringify(override));
        }
        else {
            window.localStorage.removeItem(STORAGE_KEY);
        }
    }
    catch (e) {
        console.warn("Failed to write context budget overrides to storage:", e);
    }
}
// ============================================================================
// Budget Computation
// ============================================================================
/**
 * Apply profile override to defaults to get effective budgets.
 */
function computeEffectiveBudgets(override) {
    if (!override) {
        return { ...DEFAULT_BUDGETS };
    }
    const hasOverrides = override.context_budget_chars !== undefined ||
        override.history_max_recent_chars !== undefined ||
        override.history_max_older_chars !== undefined;
    return {
        context_budget_chars: override.context_budget_chars ?? DEFAULT_BUDGETS.context_budget_chars,
        history_max_recent_chars: override.history_max_recent_chars ?? DEFAULT_BUDGETS.history_max_recent_chars,
        history_max_older_chars: override.history_max_older_chars ?? DEFAULT_BUDGETS.history_max_older_chars,
        source: hasOverrides ? "profile" : "default",
    };
}
/**
 * Notify all registered callbacks of budget changes.
 */
function notifyCallbacks() {
    for (const callback of _callbacks) {
        try {
            callback(_effectiveBudgets);
        }
        catch (e) {
            console.error("Context budget callback error:", e);
        }
    }
}
// ============================================================================
// Preset Detection and Application
// ============================================================================
/**
 * Detect which preset (if any) matches the current effective budgets.
 * Returns null if no preset matches exactly.
 */
export function detectCurrentPreset() {
    const budgets = getContextBudgets();
    for (const presetId of Object.keys(PRESETS)) {
        const preset = PRESETS[presetId];
        if (budgets.context_budget_chars === preset.context_budget_chars &&
            budgets.history_max_recent_chars === preset.history_max_recent_chars &&
            budgets.history_max_older_chars === preset.history_max_older_chars) {
            return presetId;
        }
    }
    return null;
}
/**
 * Apply a preset's values to the current context budgets.
 * @param presetId - The preset to apply ("lean", "balanced", or "heavy")
 */
export async function applyPreset(presetId) {
    const preset = PRESETS[presetId];
    if (!preset) {
        console.warn(`Unknown preset: ${presetId}`);
        return;
    }
    await setContextBudgets({
        context_budget_chars: preset.context_budget_chars,
        history_max_recent_chars: preset.history_max_recent_chars,
        history_max_older_chars: preset.history_max_older_chars,
    });
}
// ============================================================================
// State Management
// ============================================================================
/**
 * Initialize the context budget settings module.
 * Should be called once during app startup.
 */
export function initContextBudgetSettings() {
    if (_initialized)
        return;
    _profileOverride = readFromStorage();
    _effectiveBudgets = computeEffectiveBudgets(_profileOverride);
    _initialized = true;
    // Context budget settings initialized: _effectiveBudgets
}
/**
 * Get the current effective context budgets.
 */
export function getContextBudgets() {
    if (!_initialized) {
        initContextBudgetSettings();
    }
    return { ..._effectiveBudgets };
}
/**
 * Get the current profile override (may be null if using defaults).
 */
export function getProfileOverride() {
    return _profileOverride ? { ..._profileOverride } : null;
}
/**
 * Update profile-level context budget overrides.
 * Pass null to reset to defaults.
 */
export async function setContextBudgets(budgets) {
    if (budgets === null) {
        _profileOverride = null;
    }
    else {
        _profileOverride = {
            ...(_profileOverride ?? {}),
            ...budgets,
        };
    }
    writeToStorage(_profileOverride);
    _effectiveBudgets = computeEffectiveBudgets(_profileOverride);
    notifyCallbacks();
    // TODO: Persist to backend via API call
    // await Api.saveContextBudgets(_profileOverride);
}
/**
 * Reset to default budgets (clear all overrides).
 */
export async function resetToDefaults() {
    await setContextBudgets(null);
}
/**
 * Register a callback to be notified when budgets change.
 * Returns an unsubscribe function.
 */
export function onContextBudgetChange(callback) {
    _callbacks.push(callback);
    // Return unsubscribe function
    return () => {
        const index = _callbacks.indexOf(callback);
        if (index >= 0) {
            _callbacks.splice(index, 1);
        }
    };
}
// ============================================================================
// Modal UI Functions
// ============================================================================
/**
 * Open the context budget settings modal.
 * This should be wired to a button in the header.
 */
export function openContextBudgetModal() {
    const modal = document.getElementById("context-budget-modal");
    if (modal) {
        modal.classList.add("open");
        populateModalForm();
        // Focus first input for accessibility
        const firstInput = modal.querySelector("input");
        if (firstInput) {
            firstInput.focus();
        }
    }
}
/**
 * Close the context budget settings modal.
 */
export function closeContextBudgetModal() {
    const modal = document.getElementById("context-budget-modal");
    if (modal) {
        modal.classList.remove("open");
    }
}
/**
 * Populate the modal form with current values.
 */
function populateModalForm() {
    const budgets = getContextBudgets();
    const totalInput = document.getElementById("budget-total");
    const recentInput = document.getElementById("budget-recent");
    const olderInput = document.getElementById("budget-older");
    if (totalInput)
        totalInput.value = String(budgets.context_budget_chars);
    if (recentInput)
        recentInput.value = String(budgets.history_max_recent_chars);
    if (olderInput)
        olderInput.value = String(budgets.history_max_older_chars);
    // Update source display
    const sourceDisplay = document.querySelector('[data-uiid="flow_studio.modal.context_budget.effective"]');
    if (sourceDisplay) {
        sourceDisplay.innerHTML = `
      <div class="budget-value"><strong>Total Budget:</strong> ${budgets.context_budget_chars.toLocaleString()} chars (~${Math.round(budgets.context_budget_chars / 4000)}k tokens)</div>
      <div class="budget-value"><strong>Recent Step:</strong> ${budgets.history_max_recent_chars.toLocaleString()} chars (~${Math.round(budgets.history_max_recent_chars / 4000)}k tokens)</div>
      <div class="budget-value"><strong>Older Steps:</strong> ${budgets.history_max_older_chars.toLocaleString()} chars (~${Math.round(budgets.history_max_older_chars / 4000)}k tokens)</div>
      <div class="budget-source">Source: <code>${budgets.source}</code></div>
    `;
    }
    // Update preset button active states
    updatePresetButtonStates();
}
/**
 * Read values from the modal form.
 */
function readModalForm() {
    const totalInput = document.getElementById("budget-total");
    const recentInput = document.getElementById("budget-recent");
    const olderInput = document.getElementById("budget-older");
    return {
        context_budget_chars: totalInput ? parseInt(totalInput.value, 10) : undefined,
        history_max_recent_chars: recentInput ? parseInt(recentInput.value, 10) : undefined,
        history_max_older_chars: olderInput ? parseInt(olderInput.value, 10) : undefined,
    };
}
/**
 * Update the active state of preset buttons based on current settings.
 * Toggles the `.active` class on preset buttons based on whether the current
 * budget settings match that preset.
 */
export function updatePresetButtonStates() {
    const currentPreset = detectCurrentPreset();
    const presetButtons = document.querySelectorAll(".btn-preset[data-preset]");
    presetButtons.forEach((btn) => {
        const presetId = btn.dataset.preset;
        if (presetId === currentPreset) {
            btn.classList.add("active");
        }
        else {
            btn.classList.remove("active");
        }
    });
}
// ============================================================================
// Event Handler Initialization
// ============================================================================
/**
 * Initialize modal event handlers.
 * Should be called after DOM is ready.
 */
export function initContextBudgetModalHandlers() {
    // Close button
    const closeBtn = document.querySelector('[data-uiid="flow_studio.modal.context_budget.close"]');
    if (closeBtn) {
        closeBtn.addEventListener("click", closeContextBudgetModal);
    }
    // Save button
    const saveBtn = document.querySelector('[data-uiid="flow_studio.modal.context_budget.save"]');
    if (saveBtn) {
        saveBtn.addEventListener("click", async () => {
            const values = readModalForm();
            await setContextBudgets(values);
            closeContextBudgetModal();
        });
    }
    // Reset button
    const resetBtn = document.querySelector('[data-uiid="flow_studio.modal.context_budget.reset"]');
    if (resetBtn) {
        resetBtn.addEventListener("click", async () => {
            await resetToDefaults();
            populateModalForm();
        });
    }
    // Backdrop click to close
    const modal = document.getElementById("context-budget-modal");
    if (modal) {
        modal.addEventListener("click", (e) => {
            if (e.target === modal) {
                closeContextBudgetModal();
            }
        });
    }
    // Header trigger button
    const triggerBtn = document.querySelector('[data-uiid="flow_studio.header.context_budget.trigger"]');
    if (triggerBtn) {
        triggerBtn.addEventListener("click", openContextBudgetModal);
    }
    // Escape key to close
    document.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modal?.classList.contains("open")) {
            closeContextBudgetModal();
        }
    });
    // Preset buttons - listen for clicks on .btn-preset[data-preset] elements
    const presetButtons = document.querySelectorAll(".btn-preset[data-preset]");
    presetButtons.forEach((btn) => {
        btn.addEventListener("click", async () => {
            const presetId = btn.dataset.preset;
            if (presetId && PRESETS[presetId]) {
                await applyPreset(presetId);
                populateModalForm();
            }
        });
    });
}
// inventory_counts.js
// swarm/tools/flow_studio_ui/src/inventory_counts.ts
// Inventory counts component for Flow Studio
//
// Displays deterministic marker statistics:
// - Counts per marker type (REQ, SOL, TRC, ASM, DEC)
// - Counts per flow
// - Deltas between steps (what changed)
import { Api, fetchJSON } from "./api.js";
// =============================================================================
// State
// =============================================================================
let currentRunId = null;
let currentData = null;
// Monotonic sequence counter for request coalescing
// Prevents out-of-order UI renders under bursty SSE events
let loadSeq = 0;
// =============================================================================
// API
// =============================================================================
async function getFactsSummary(runId) {
    return fetchJSON(`/api/runs/${encodeURIComponent(runId)}/facts/summary`);
}
// =============================================================================
// Rendering Helpers
// =============================================================================
const MARKER_COLORS = {
    REQ: "#3b82f6", // blue
    SOL: "#22c55e", // green
    TRC: "#a855f7", // purple
    ASM: "#f59e0b", // amber
    DEC: "#06b6d4", // cyan
    TRC_MISSING: "#ef4444", // red
};
function getMarkerColor(markerType) {
    return MARKER_COLORS[markerType] || "#6b7280";
}
function formatDelta(delta) {
    if (delta > 0)
        return `+${delta}`;
    if (delta < 0)
        return `${delta}`;
    return "0";
}
function getDeltaClass(delta) {
    if (delta > 0)
        return "delta-positive";
    if (delta < 0)
        return "delta-negative";
    return "delta-neutral";
}
// =============================================================================
// Scoreboard Rendering
// =============================================================================
function renderScoreboard(data) {
    const items = data.by_type.map((mc) => {
        const color = getMarkerColor(mc.marker_type);
        return `
      <div class="scoreboard-item" data-marker-type="${mc.marker_type}" style="--marker-color: ${color}">
        <span class="marker-type">${escapeHtml(mc.marker_type)}</span>
        <span class="marker-count">${mc.count}</span>
        <span class="marker-label">${escapeHtml(mc.label)}</span>
      </div>
    `;
    }).join("");
    return `
    <div class="inventory-scoreboard">
      <div class="scoreboard-header">
        <h4>Inventory</h4>
        <span class="total-count">${data.total_facts} facts</span>
      </div>
      <div class="scoreboard-items">
        ${items}
      </div>
    </div>
  `;
}
// =============================================================================
// Flow Breakdown Rendering
// =============================================================================
function renderFlowBreakdown(data) {
    if (data.by_flow.length === 0) {
        return "";
    }
    const flowItems = data.by_flow.map((fc) => {
        // Build mini bar chart
        const markerTypes = Object.keys(fc.counts).sort();
        const bars = markerTypes.map((mt) => {
            const count = fc.counts[mt];
            const color = getMarkerColor(mt);
            const width = fc.total > 0 ? (count / fc.total) * 100 : 0;
            return `<div class="bar-segment" style="width: ${width}%; background: ${color}" title="${mt}: ${count}"></div>`;
        }).join("");
        return `
      <div class="flow-item" data-flow="${fc.flow_key}">
        <span class="flow-key">${escapeHtml(fc.flow_key)}</span>
        <div class="flow-bar">${bars}</div>
        <span class="flow-total">${fc.total}</span>
      </div>
    `;
    }).join("");
    return `
    <div class="inventory-flows">
      <h5>By Flow</h5>
      <div class="flow-breakdown">
        ${flowItems}
      </div>
    </div>
  `;
}
// =============================================================================
// Delta View Rendering
// =============================================================================
function renderDeltaView(data) {
    if (data.deltas.length === 0) {
        return "";
    }
    // Show only the most recent deltas (last 5)
    const recentDeltas = data.deltas.slice(-5);
    const deltaItems = recentDeltas.map((d) => {
        const deltaChips = Object.entries(d.deltas).map(([mt, delta]) => {
            const color = getMarkerColor(mt);
            const deltaClass = getDeltaClass(delta);
            return `<span class="delta-chip ${deltaClass}" style="--marker-color: ${color}">${mt} ${formatDelta(delta)}</span>`;
        }).join(" ");
        return `
      <div class="delta-item">
        <span class="delta-path">${escapeHtml(d.to_step)}</span>
        <div class="delta-chips">${deltaChips || "no change"}</div>
      </div>
    `;
    }).join("");
    return `
    <details class="inventory-deltas">
      <summary>Recent Changes (${data.deltas.length})</summary>
      <div class="delta-list">
        ${deltaItems}
      </div>
    </details>
  `;
}
// =============================================================================
// Compact View (for header bar)
// =============================================================================
export function renderCompactInventory(data) {
    const items = data.by_type.map((mc) => {
        if (mc.count === 0)
            return "";
        const color = getMarkerColor(mc.marker_type);
        return `<span class="compact-marker" style="color: ${color}">${mc.marker_type}:${mc.count}</span>`;
    }).filter(Boolean).join(" ");
    return `
    <div class="inventory-compact">
      ${items || "No facts"}
    </div>
  `;
}
// =============================================================================
// Full Panel Rendering
// =============================================================================
export function renderInventoryPanel(data) {
    return `
    <div class="inventory-panel" data-run-id="${data.run_id}">
      ${renderScoreboard(data)}
      ${renderFlowBreakdown(data)}
      ${renderDeltaView(data)}
      ${data.errors.length > 0 ? `
        <div class="inventory-errors">
          <details>
            <summary>${data.errors.length} extraction error(s)</summary>
            <ul>
              ${data.errors.map((e) => `<li>${escapeHtml(e)}</li>`).join("")}
            </ul>
          </details>
        </div>
      ` : ""}
    </div>
  `;
}
// =============================================================================
// Public API
// =============================================================================
/**
 * Load and cache facts summary for a run.
 * Uses monotonic request ID guard to prevent out-of-order UI renders
 * when multiple requests are in flight (e.g., under bursty SSE).
 */
export async function loadFactsSummary(runId) {
    const seq = ++loadSeq;
    try {
        currentRunId = runId;
        const data = await getFactsSummary(runId);
        // Ignore stale response if a newer request was initiated
        if (seq !== loadSeq) {
            return currentData;
        }
        currentData = data;
        return currentData;
    }
    catch (err) {
        // Only update state if this is still the latest request
        if (seq === loadSeq) {
            console.error("Failed to load facts summary:", err);
            currentData = null;
        }
        return null;
    }
}
/**
 * Get the current cached facts data.
 */
export function getCurrentFactsData() {
    return currentData;
}
/**
 * Update the inventory panel in a container.
 */
export async function updateInventoryPanel(container, runId) {
    const data = await loadFactsSummary(runId);
    if (data) {
        container.innerHTML = renderInventoryPanel(data);
    }
    else {
        container.innerHTML = `
      <div class="inventory-panel empty">
        <div class="empty-message">No inventory data available.</div>
      </div>
    `;
    }
}
/**
 * Update the compact inventory display in a container.
 */
export async function updateCompactInventory(container, runId) {
    const data = await loadFactsSummary(runId);
    if (data) {
        container.innerHTML = renderCompactInventory(data);
    }
    else {
        container.innerHTML = `<span class="inventory-compact">--</span>`;
    }
}
// =============================================================================
// Utility
// =============================================================================
function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
}
// =============================================================================
// CSS (injected on first use)
// =============================================================================
let cssInjected = false;
export function injectInventoryCSS() {
    if (cssInjected)
        return;
    cssInjected = true;
    const style = document.createElement("style");
    style.textContent = `
    .inventory-panel {
      background: var(--bg-secondary, #f5f5f5);
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
    }

    .inventory-scoreboard {
      margin-bottom: 12px;
    }

    .scoreboard-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .scoreboard-header h4 {
      margin: 0;
      font-size: 14px;
      font-weight: 600;
    }

    .total-count {
      font-size: 12px;
      color: var(--text-secondary, #666);
    }

    .scoreboard-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .scoreboard-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 12px;
      background: white;
      border-radius: 6px;
      border-left: 3px solid var(--marker-color);
      min-width: 60px;
    }

    .marker-type {
      font-size: 10px;
      font-weight: 600;
      color: var(--marker-color);
      text-transform: uppercase;
    }

    .marker-count {
      font-size: 20px;
      font-weight: 700;
      color: var(--text-primary, #111);
    }

    .marker-label {
      font-size: 9px;
      color: var(--text-tertiary, #888);
      text-align: center;
      max-width: 80px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .inventory-flows h5 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary, #666);
    }

    .flow-breakdown {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .flow-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .flow-key {
      font-size: 11px;
      font-weight: 500;
      width: 60px;
      text-transform: capitalize;
    }

    .flow-bar {
      flex: 1;
      height: 12px;
      background: var(--bg-tertiary, #e8e8e8);
      border-radius: 2px;
      display: flex;
      overflow: hidden;
    }

    .bar-segment {
      height: 100%;
      transition: width 0.3s ease;
    }

    .flow-total {
      font-size: 11px;
      font-weight: 600;
      width: 30px;
      text-align: right;
    }

    .inventory-deltas {
      margin-top: 12px;
      font-size: 12px;
    }

    .inventory-deltas summary {
      cursor: pointer;
      color: var(--text-secondary, #666);
      font-weight: 500;
    }

    .delta-list {
      margin-top: 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .delta-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
      border-bottom: 1px solid var(--border-color, #eee);
    }

    .delta-item:last-child {
      border-bottom: none;
    }

    .delta-path {
      font-family: monospace;
      font-size: 10px;
      color: var(--text-tertiary, #888);
      min-width: 100px;
    }

    .delta-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .delta-chip {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }

    .delta-positive {
      background: #dcfce7;
      color: #166534;
    }

    .delta-negative {
      background: #fee2e2;
      color: #991b1b;
    }

    .delta-neutral {
      background: var(--bg-tertiary, #e8e8e8);
      color: var(--text-tertiary, #888);
    }

    .inventory-errors {
      margin-top: 12px;
      font-size: 11px;
      color: var(--text-secondary, #666);
    }

    .inventory-errors summary {
      cursor: pointer;
      color: #f59e0b;
    }

    .inventory-errors ul {
      margin: 4px 0 0 0;
      padding-left: 16px;
      color: #92400e;
    }

    .inventory-compact {
      display: flex;
      gap: 8px;
      font-size: 11px;
      font-family: monospace;
    }

    .compact-marker {
      font-weight: 500;
    }

    .inventory-panel.empty {
      text-align: center;
      color: var(--text-secondary, #666);
    }

    .empty-message {
      padding: 16px;
      font-style: italic;
    }
  `;
    document.head.appendChild(style);
}
// run_control.js
// swarm/tools/flow_studio_ui/src/run_control.ts
// Run Control panel module for Flow Studio
//
// This module handles:
// - Starting, pausing, resuming, and stopping runs
// - Run state management and UI updates
// - Integration with the API client
import { flowStudioApi } from "./api/client.js";
import { state } from "./state.js";
// ============================================================================
// Module State
// ============================================================================
const _state = {
    activeRunId: null,
    runState: "pending",
    currentStep: null,
    currentFlow: null,
    progress: 0,
    error: null,
    isLoading: false,
    unsubscribe: null,
    etag: null,
    isAutopilot: false,
    flowKeys: [],
    planId: null,
    completedFlows: [],
};
let _callbacks = {};
// ============================================================================
// Configuration
// ============================================================================
/**
 * Configure callbacks for run control events.
 */
export function configure(callbacks = {}) {
    _callbacks = { ..._callbacks, ...callbacks };
}
// ============================================================================
// State Accessors
// ============================================================================
/**
 * Get the current run control state.
 */
export function getRunControlState() {
    return { ..._state };
}
/**
 * Check if there's an active run.
 */
export function hasActiveRun() {
    return _state.activeRunId !== null &&
        (_state.runState === "running" || _state.runState === "paused");
}
/**
 * Check if the current run is an autopilot run.
 */
export function isAutopilotRun() {
    return _state.isAutopilot;
}
/**
 * Get the list of completed flows in the current autopilot run.
 */
export function getCompletedFlows() {
    return [..._state.completedFlows];
}
/**
 * Get the current flow being executed (for autopilot runs).
 */
export function getCurrentFlow() {
    return _state.currentFlow;
}
// ============================================================================
// Run Control Actions
// ============================================================================
/**
 * Start a new run.
 *
 * @param flowId - Flow ID to run (defaults to current flow)
 * @param options - Optional run configuration
 */
export async function startRun(flowId, options) {
    if (_state.isLoading)
        return;
    const targetFlowId = flowId || state.currentFlowKey || "signal";
    _state.isLoading = true;
    _state.error = null;
    updateUI();
    try {
        const runInfo = await flowStudioApi.startRun(targetFlowId, options);
        _state.activeRunId = runInfo.run_id;
        _state.runState = runInfo.state || "running";
        _state.currentStep = runInfo.currentStep || null;
        _state.progress = runInfo.progress || 0;
        _state.isLoading = false;
        // Subscribe to run events
        subscribeToRunEvents(runInfo.run_id);
        if (_callbacks.onRunStart) {
            _callbacks.onRunStart(runInfo.run_id);
        }
        if (_callbacks.onSelectRun) {
            await _callbacks.onSelectRun(runInfo.run_id);
        }
        updateUI();
    }
    catch (err) {
        _state.isLoading = false;
        _state.error = err.message || "Failed to start run";
        console.error("Failed to start run", err);
        updateUI();
    }
}
/**
 * Pause the current run.
 */
export async function pauseRun() {
    if (!_state.activeRunId || _state.isLoading || _state.runState !== "running") {
        return;
    }
    _state.isLoading = true;
    updateUI();
    try {
        await flowStudioApi.pauseRun(_state.activeRunId, _state.etag || undefined);
        _state.runState = "paused";
        _state.isLoading = false;
        if (_callbacks.onStateChange) {
            _callbacks.onStateChange("paused", _state.activeRunId);
        }
        updateUI();
    }
    catch (err) {
        _state.isLoading = false;
        _state.error = err.message || "Failed to pause run";
        console.error("Failed to pause run", err);
        updateUI();
    }
}
/**
 * Resume the current paused run.
 */
export async function resumeRun() {
    if (!_state.activeRunId || _state.isLoading || _state.runState !== "paused") {
        return;
    }
    _state.isLoading = true;
    updateUI();
    try {
        await flowStudioApi.resumeRun(_state.activeRunId, _state.etag || undefined);
        _state.runState = "running";
        _state.isLoading = false;
        if (_callbacks.onStateChange) {
            _callbacks.onStateChange("running", _state.activeRunId);
        }
        updateUI();
    }
    catch (err) {
        _state.isLoading = false;
        _state.error = err.message || "Failed to resume run";
        console.error("Failed to resume run", err);
        updateUI();
    }
}
/**
 * Stop the current run.
 *
 * Stopped is a clean user-initiated termination, distinct from a failure.
 * Stopped runs remain selectable and reviewable (no auto-reset).
 */
export async function stopRun() {
    if (!_state.activeRunId || _state.isLoading) {
        return;
    }
    // Only allow stop if running or paused
    if (_state.runState !== "running" && _state.runState !== "paused") {
        return;
    }
    _state.isLoading = true;
    updateUI();
    try {
        // Use the existing cancelRun API endpoint (backend still calls it cancel)
        await flowStudioApi.cancelRun(_state.activeRunId, _state.etag || undefined);
        const runId = _state.activeRunId;
        // Unsubscribe from events
        if (_state.unsubscribe) {
            _state.unsubscribe();
            _state.unsubscribe = null;
        }
        // Set state to "stopped" - distinct from "failed"
        _state.runState = "stopped";
        _state.isLoading = false;
        // No error message - stopped is a clean state, not an error
        _state.error = null;
        // Fire the stopped callback (not failed)
        if (_callbacks.onRunStopped) {
            _callbacks.onRunStopped(runId);
        }
        // Also fire state change for general listeners
        if (_callbacks.onStateChange) {
            _callbacks.onStateChange("stopped", runId);
        }
        // No auto-reset: stopped runs remain selectable and reviewable
        updateUI();
    }
    catch (err) {
        _state.isLoading = false;
        _state.error = err.message || "Failed to stop run";
        console.error("Failed to stop run", err);
        updateUI();
    }
}
/**
 * Cancel the current run.
 * @deprecated Use stopRun() instead. This alias is kept for backwards compatibility.
 */
export async function cancelRun() {
    return stopRun();
}
// ============================================================================
// SSE Subscription
// ============================================================================
/**
 * Subscribe to run events via SSE.
 */
function subscribeToRunEvents(runId) {
    // Clean up existing subscription
    if (_state.unsubscribe) {
        _state.unsubscribe();
    }
    _state.unsubscribe = flowStudioApi.subscribeToRun(runId, handleSSEEvent);
}
/**
 * Handle incoming SSE events.
 */
function handleSSEEvent(event) {
    switch (event.type) {
        case "step_start":
            _state.currentStep = event.stepId || null;
            // Update current flow if provided
            if (event.flowKey) {
                _state.currentFlow = event.flowKey;
            }
            break;
        case "step_end":
            // Calculate progress based on completed steps
            if (event.payload?.progress !== undefined) {
                _state.progress = event.payload.progress;
            }
            break;
        case "flow_completed":
            // Individual flow completed (relevant for autopilot runs)
            if (event.flowKey && !_state.completedFlows.includes(event.flowKey)) {
                _state.completedFlows.push(event.flowKey);
            }
            // Notify listeners of flow completion
            if (_callbacks.onFlowCompleted && _state.activeRunId && event.flowKey) {
                _callbacks.onFlowCompleted(_state.activeRunId, event.flowKey);
            }
            break;
        case "plan_completed":
            // Entire plan completed (autopilot run finished)
            if (_callbacks.onPlanCompleted && _state.activeRunId && _state.planId) {
                _callbacks.onPlanCompleted(_state.activeRunId, _state.planId);
            }
            // Fall through to complete handling
            _state.runState = "completed";
            _state.progress = 100;
            if (_state.unsubscribe) {
                _state.unsubscribe();
                _state.unsubscribe = null;
            }
            if (_callbacks.onRunComplete && _state.activeRunId) {
                _callbacks.onRunComplete(_state.activeRunId, _state.isAutopilot);
            }
            break;
        case "complete":
            _state.runState = "completed";
            _state.progress = 100;
            if (_state.unsubscribe) {
                _state.unsubscribe();
                _state.unsubscribe = null;
            }
            if (_callbacks.onRunComplete && _state.activeRunId) {
                _callbacks.onRunComplete(_state.activeRunId, _state.isAutopilot);
            }
            break;
        case "error":
            _state.runState = "failed";
            _state.error = event.payload?.error || "Run failed";
            if (_state.unsubscribe) {
                _state.unsubscribe();
                _state.unsubscribe = null;
            }
            if (_callbacks.onRunFailed && _state.activeRunId) {
                _callbacks.onRunFailed(_state.activeRunId, _state.error);
            }
            break;
    }
    // Notify listeners of every SSE event for UI propagation
    _callbacks.onRunEvent?.(event, _state.activeRunId);
    updateUI();
}
// ============================================================================
// State Management
// ============================================================================
/**
 * Reset the run control state.
 */
function resetState() {
    if (_state.unsubscribe) {
        _state.unsubscribe();
    }
    _state.activeRunId = null;
    _state.runState = "pending";
    _state.currentStep = null;
    _state.currentFlow = null;
    _state.progress = 0;
    _state.error = null;
    _state.isLoading = false;
    _state.unsubscribe = null;
    _state.etag = null;
    _state.isAutopilot = false;
    _state.flowKeys = [];
    _state.planId = null;
    _state.completedFlows = [];
}
/**
 * Set the active run to monitor (for existing runs).
 */
export async function setActiveRun(runId) {
    if (_state.activeRunId === runId)
        return;
    // Clean up existing subscription
    if (_state.unsubscribe) {
        _state.unsubscribe();
        _state.unsubscribe = null;
    }
    try {
        const { data, etag } = await flowStudioApi.getRunState(runId);
        _state.activeRunId = runId;
        _state.runState = data.status;
        _state.currentStep = data.current_step;
        _state.etag = etag;
        _state.error = data.error;
        // Subscribe to events if run is active
        if (_state.runState === "running" || _state.runState === "paused") {
            subscribeToRunEvents(runId);
        }
        updateUI();
    }
    catch (err) {
        console.error("Failed to get run state", err);
        // Run might not exist in backend - just show idle state
        resetState();
        updateUI();
    }
}
/**
 * Clear the active run (e.g., when selecting a different run in the UI).
 */
export function clearActiveRun() {
    resetState();
    updateUI();
}
// ============================================================================
// UI Updates
// ============================================================================
/**
 * Update the run control UI based on current state.
 */
function updateUI() {
    const playBtn = document.getElementById("run-control-play");
    const pauseBtn = document.getElementById("run-control-pause");
    const resumeBtn = document.getElementById("run-control-resume");
    const cancelBtn = document.getElementById("run-control-cancel");
    const statusText = document.getElementById("run-control-status-text");
    const statusContainer = document.getElementById("run-control-status");
    if (!playBtn || !pauseBtn || !resumeBtn || !cancelBtn || !statusText || !statusContainer) {
        return;
    }
    // Remove all state classes
    statusContainer.classList.remove("run-control-status--pending", "run-control-status--running", "run-control-status--paused", "run-control-status--completed", "run-control-status--failed", "run-control-status--stopped");
    // Handle loading state
    if (_state.isLoading) {
        playBtn.disabled = true;
        pauseBtn.disabled = true;
        resumeBtn.disabled = true;
        cancelBtn.disabled = true;
        statusText.textContent = "Processing...";
        statusText.className = "run-control-status-text run-control-status-text--loading";
        return;
    }
    // Update based on run state
    switch (_state.runState) {
        case "pending":
            // No active run - can start
            playBtn.disabled = false;
            playBtn.style.display = "";
            pauseBtn.disabled = true;
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            cancelBtn.disabled = true;
            statusText.textContent = "No active run";
            statusText.className = "muted";
            statusContainer.classList.add("run-control-status--pending");
            break;
        case "running":
            // Run in progress - can pause or stop
            playBtn.disabled = true;
            playBtn.style.display = "";
            pauseBtn.disabled = false;
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            cancelBtn.disabled = false;
            statusText.textContent = _state.currentStep
                ? `Running: ${_state.currentStep}`
                : "Running...";
            statusText.className = "run-control-status-text run-control-status-text--running";
            statusContainer.classList.add("run-control-status--running");
            break;
        case "paused":
            // Run paused - can resume or stop
            playBtn.style.display = "none";
            pauseBtn.style.display = "none";
            resumeBtn.disabled = false;
            resumeBtn.style.display = "";
            cancelBtn.disabled = false;
            statusText.textContent = _state.currentStep
                ? `Paused at: ${_state.currentStep}`
                : "Paused";
            statusText.className = "run-control-status-text run-control-status-text--paused";
            statusContainer.classList.add("run-control-status--paused");
            break;
        case "completed":
            // Run completed - can start new
            playBtn.disabled = false;
            playBtn.style.display = "";
            pauseBtn.disabled = true;
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            cancelBtn.disabled = true;
            statusText.textContent = "Completed";
            statusText.className = "run-control-status-text run-control-status-text--completed";
            statusContainer.classList.add("run-control-status--completed");
            break;
        case "failed":
            // Run failed - can start new
            playBtn.disabled = false;
            playBtn.style.display = "";
            pauseBtn.disabled = true;
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            cancelBtn.disabled = true;
            statusText.textContent = _state.error || "Failed";
            statusText.className = "run-control-status-text run-control-status-text--failed";
            statusContainer.classList.add("run-control-status--failed");
            break;
        case "stopped":
            // Run stopped by user - can start new, remains selectable for review
            playBtn.disabled = false;
            playBtn.style.display = "";
            pauseBtn.disabled = true;
            pauseBtn.style.display = "";
            resumeBtn.style.display = "none";
            cancelBtn.disabled = true;
            statusText.textContent = _state.currentStep
                ? `Stopped at: ${_state.currentStep}`
                : "Stopped";
            statusText.className = "run-control-status-text run-control-status-text--stopped";
            statusContainer.classList.add("run-control-status--stopped");
            break;
    }
    // Add progress indicator if running
    if (_state.runState === "running" && _state.progress > 0) {
        const progressBar = statusContainer.querySelector(".run-control-progress");
        if (progressBar) {
            progressBar.style.width = `${_state.progress}%`;
        }
    }
}
// ============================================================================
// Initialization
// ============================================================================
/**
 * Initialize the run control panel.
 * Call this during app initialization to wire up event handlers.
 */
export function initRunControl() {
    const playBtn = document.getElementById("run-control-play");
    const pauseBtn = document.getElementById("run-control-pause");
    const resumeBtn = document.getElementById("run-control-resume");
    const cancelBtn = document.getElementById("run-control-cancel");
    if (playBtn) {
        playBtn.addEventListener("click", () => {
            void startRun();
        });
    }
    if (pauseBtn) {
        pauseBtn.addEventListener("click", () => {
            void pauseRun();
        });
    }
    if (resumeBtn) {
        resumeBtn.addEventListener("click", () => {
            void resumeRun();
        });
    }
    if (cancelBtn) {
        cancelBtn.addEventListener("click", () => {
            void stopRun();
        });
    }
    // Initial UI update
    updateUI();
}
// ============================================================================
// Exports for SDK
// ============================================================================
export { startRun as start, pauseRun as pause, resumeRun as resume, stopRun as stop, cancelRun as cancel, // deprecated alias for stopRun
 };
  </script>

</body>
</html>
