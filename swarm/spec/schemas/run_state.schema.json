{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://flowstudio.dev/schemas/run_state.schema.json",
  "title": "RunState",
  "description": "Durable program counter for stepwise flow execution with GPS-style detour routing support. Enables resumption from any step, tracking of dynamic detours/injections, and version consistency validation.",
  "type": "object",
  "required": ["run_id", "flow_key", "status", "timestamp"],
  "properties": {
    "run_id": {
      "type": "string",
      "pattern": "^run-[0-9]{8}-[0-9]{6}-[a-z0-9]{6,8}$",
      "description": "Unique run identifier (format: run-YYYYMMDD-HHMMSS-random)"
    },
    "flow_key": {
      "type": "string",
      "pattern": "^[a-z][a-z0-9_-]*$",
      "description": "Current flow being executed (e.g., 'signal', 'plan', 'build')"
    },
    "current_step_id": {
      "type": ["string", "null"],
      "pattern": "^[a-z][a-z0-9_-]*$",
      "description": "ID of the current step being executed, or null if not yet started"
    },
    "step_index": {
      "type": "integer",
      "minimum": 0,
      "default": 0,
      "description": "0-based index of current step in the flow's step list"
    },
    "status": {
      "type": "string",
      "enum": ["pending", "running", "succeeded", "failed", "canceled", "paused", "interrupted"],
      "default": "pending",
      "description": "Current execution status of the run"
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "ISO 8601 timestamp when this state was last updated"
    },
    "loop_state": {
      "type": "object",
      "additionalProperties": {
        "type": "integer",
        "minimum": 0
      },
      "default": {},
      "description": "Map of loop_key to iteration count for microloop tracking (e.g., 'critique_reqs:author_reqs': 3)"
    },
    "handoff_envelopes": {
      "type": "object",
      "additionalProperties": {
        "$ref": "handoff_envelope.schema.json"
      },
      "default": {},
      "description": "Map of step_id to HandoffEnvelope for completed steps"
    },
    "current_flow_index": {
      "type": "integer",
      "minimum": 1,
      "maximum": 6,
      "default": 1,
      "description": "1-based index of the current flow (1=signal, 2=plan, 3=build, 4=gate, 5=deploy, 6=wisdom)"
    },
    "flow_transition_history": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/FlowTransitionRecord"
      },
      "default": [],
      "description": "Ordered list of flow transitions with timestamps and reasons"
    },
    "interruption_stack": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/InterruptionFrame"
      },
      "default": [],
      "description": "Stack of active interruptions/detours. Last item is the current detour context. Enables GPS-style rerouting where execution temporarily diverts to handle an injection, then resumes."
    },
    "resume_stack": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/ResumeFrame"
      },
      "default": [],
      "description": "Stack of resume points for returning from detours. Each entry captures where to resume after completing a detour sequence."
    },
    "spec_versions": {
      "$ref": "#/definitions/SpecVersions",
      "description": "Version hashes for spec artifacts, enabling drift detection and consistency validation"
    },
    "injected_nodes": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/InjectedNode"
      },
      "default": [],
      "description": "Dynamic nodes injected during execution (e.g., by human operator, policy enforcement, or runtime decision). These are tracked separately from the base flow spec."
    },
    "routing_cursor": {
      "$ref": "#/definitions/RoutingCursor",
      "description": "Detailed routing state for the smart orchestrator, including pending branch evaluations and deferred decisions"
    },
    "metrics": {
      "$ref": "#/definitions/RunMetrics",
      "description": "Aggregate metrics for the run (total duration, step counts, token usage)"
    },
    "annotations": {
      "type": "object",
      "additionalProperties": true,
      "description": "User-defined annotations and tags for the run (not interpreted by orchestrator)"
    }
  },
  "definitions": {
    "FlowTransitionRecord": {
      "type": "object",
      "required": ["from_flow", "to_flow", "timestamp", "reason"],
      "properties": {
        "from_flow": {
          "type": ["string", "null"],
          "description": "Previous flow key, or null if this is the initial flow"
        },
        "to_flow": {
          "type": "string",
          "description": "Flow key being transitioned to"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When the transition occurred"
        },
        "reason": {
          "type": "string",
          "description": "Why the transition occurred (e.g., 'flow_complete', 'bounce_back', 'escalation')"
        },
        "triggering_step": {
          "type": "string",
          "description": "Step that triggered this transition (if applicable)"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "description": "Additional context about the transition"
        }
      },
      "additionalProperties": false
    },
    "InterruptionFrame": {
      "type": "object",
      "required": ["id", "type", "timestamp", "trigger"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^int-[a-z0-9]{8}$",
          "description": "Unique identifier for this interruption"
        },
        "type": {
          "type": "string",
          "enum": ["human_injection", "policy_enforcement", "error_recovery", "priority_override", "branch_detour", "external_event"],
          "description": "Type of interruption that caused the detour"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When the interruption was triggered"
        },
        "trigger": {
          "type": "object",
          "required": ["source"],
          "properties": {
            "source": {
              "type": "string",
              "enum": ["operator", "policy_engine", "step_output", "external_api", "timeout", "signal"],
              "description": "What triggered the interruption"
            },
            "source_id": {
              "type": "string",
              "description": "Identifier of the triggering source (user ID, policy name, step ID, etc.)"
            },
            "payload": {
              "type": "object",
              "additionalProperties": true,
              "description": "Data associated with the trigger"
            }
          },
          "additionalProperties": false
        },
        "detour_steps": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Ordered list of step IDs to execute as part of this detour"
        },
        "current_detour_index": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Index into detour_steps indicating current position"
        },
        "priority": {
          "type": "integer",
          "minimum": 0,
          "maximum": 100,
          "default": 50,
          "description": "Priority of this interruption (higher = more urgent). Used when multiple interruptions are pending."
        },
        "timeout_ms": {
          "type": "integer",
          "minimum": 0,
          "description": "Maximum time allowed for this detour before auto-resume (0 = no timeout)"
        },
        "can_abort": {
          "type": "boolean",
          "default": true,
          "description": "Whether this detour can be aborted by higher-priority interruptions"
        },
        "completion_condition": {
          "type": "object",
          "properties": {
            "type": {
              "type": "string",
              "enum": ["all_steps_complete", "status_reached", "condition_met", "timeout", "manual"],
              "description": "How to determine when the detour is complete"
            },
            "value": {
              "type": ["string", "array", "object"],
              "description": "Value for the completion condition (status value, condition expression, etc.)"
            }
          },
          "additionalProperties": false
        },
        "context": {
          "type": "object",
          "additionalProperties": true,
          "description": "Additional context data for the detour (passed to detour steps)"
        }
      },
      "additionalProperties": false
    },
    "ResumeFrame": {
      "type": "object",
      "required": ["flow_key", "step_id", "step_index", "interruption_id"],
      "properties": {
        "flow_key": {
          "type": "string",
          "description": "Flow to resume in"
        },
        "step_id": {
          "type": "string",
          "description": "Step to resume from"
        },
        "step_index": {
          "type": "integer",
          "minimum": 0,
          "description": "Index of the step to resume from"
        },
        "interruption_id": {
          "type": "string",
          "description": "ID of the interruption that created this resume point"
        },
        "loop_state_snapshot": {
          "type": "object",
          "additionalProperties": {
            "type": "integer"
          },
          "description": "Snapshot of loop_state at time of interruption"
        },
        "context_snapshot": {
          "type": "object",
          "additionalProperties": true,
          "description": "Any context that should be restored on resume"
        },
        "resume_mode": {
          "type": "string",
          "enum": ["continue", "retry", "skip", "conditional"],
          "default": "continue",
          "description": "How to handle resumption: continue from where left off, retry the step, skip to next, or evaluate condition"
        },
        "resume_condition": {
          "type": "object",
          "description": "Condition to evaluate if resume_mode is 'conditional'"
        }
      },
      "additionalProperties": false
    },
    "SpecVersions": {
      "type": "object",
      "properties": {
        "flow_hash": {
          "type": "string",
          "pattern": "^[a-f0-9]{64}$",
          "description": "SHA-256 hash of the FlowSpec YAML at run start"
        },
        "station_hashes": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "pattern": "^[a-f0-9]{64}$"
          },
          "description": "Map of station_id to SHA-256 hash of StationSpec YAML"
        },
        "template_hashes": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "pattern": "^[a-f0-9]{64}$"
          },
          "description": "Map of template_id to SHA-256 hash of TemplateSpec YAML"
        },
        "prompt_hashes": {
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "pattern": "^[a-f0-9]{64}$"
          },
          "description": "Map of prompt_id to SHA-256 hash of compiled prompt"
        },
        "captured_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the version hashes were captured"
        },
        "drift_detected": {
          "type": "boolean",
          "default": false,
          "description": "Whether spec drift was detected during execution"
        },
        "drift_details": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "spec_type": {
                "type": "string",
                "enum": ["flow", "station", "template", "prompt"]
              },
              "spec_id": {
                "type": "string"
              },
              "old_hash": {
                "type": "string"
              },
              "new_hash": {
                "type": "string"
              },
              "detected_at": {
                "type": "string",
                "format": "date-time"
              }
            }
          },
          "description": "Details of any detected spec drift"
        }
      },
      "additionalProperties": false
    },
    "InjectedNode": {
      "type": "object",
      "required": ["id", "type", "injected_at", "source"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^inj-[a-z0-9]{8}$",
          "description": "Unique identifier for this injected node"
        },
        "type": {
          "type": "string",
          "enum": ["step", "checkpoint", "gate", "fork", "join", "conditional"],
          "description": "Type of node being injected"
        },
        "injected_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the node was injected"
        },
        "source": {
          "type": "string",
          "enum": ["operator", "policy", "api", "self_heal", "auto_scale"],
          "description": "Source that requested the injection"
        },
        "source_id": {
          "type": "string",
          "description": "Identifier of the injection source"
        },
        "position": {
          "type": "object",
          "required": ["relative_to", "placement"],
          "properties": {
            "relative_to": {
              "type": "string",
              "description": "Step ID this injection is positioned relative to"
            },
            "placement": {
              "type": "string",
              "enum": ["before", "after", "replace", "parallel"],
              "description": "Where to place the injected node relative to reference"
            }
          },
          "additionalProperties": false
        },
        "step_definition": {
          "$ref": "#/definitions/InlineStepDefinition",
          "description": "Step definition for type='step' injections"
        },
        "gate_definition": {
          "$ref": "#/definitions/InlineGateDefinition",
          "description": "Gate definition for type='gate' injections"
        },
        "executed": {
          "type": "boolean",
          "default": false,
          "description": "Whether this injected node has been executed"
        },
        "execution_result": {
          "type": "object",
          "properties": {
            "status": {
              "type": "string",
              "enum": ["succeeded", "failed", "skipped", "pending"]
            },
            "envelope": {
              "$ref": "handoff_envelope.schema.json"
            },
            "completed_at": {
              "type": "string",
              "format": "date-time"
            }
          },
          "additionalProperties": false
        },
        "ttl_steps": {
          "type": "integer",
          "minimum": 1,
          "description": "Number of steps this injection remains active (for temporary injections)"
        },
        "reason": {
          "type": "string",
          "description": "Human-readable reason for the injection"
        }
      },
      "additionalProperties": false
    },
    "InlineStepDefinition": {
      "type": "object",
      "required": ["id", "station", "objective"],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^[a-z][a-z0-9_-]*$",
          "description": "Step identifier"
        },
        "station": {
          "type": "string",
          "description": "Station spec to use"
        },
        "objective": {
          "type": "string",
          "description": "What this step must accomplish"
        },
        "inputs": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Additional inputs"
        },
        "outputs": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Expected outputs"
        },
        "routing": {
          "type": "object",
          "description": "Routing configuration"
        },
        "sdk_overrides": {
          "type": "object",
          "description": "SDK setting overrides"
        }
      },
      "additionalProperties": false
    },
    "InlineGateDefinition": {
      "type": "object",
      "required": ["id", "condition"],
      "properties": {
        "id": {
          "type": "string",
          "description": "Gate identifier"
        },
        "condition": {
          "type": "object",
          "required": ["type"],
          "properties": {
            "type": {
              "type": "string",
              "enum": ["human_approval", "policy_check", "status_check", "time_gate", "external_api"],
              "description": "Type of gate condition"
            },
            "config": {
              "type": "object",
              "additionalProperties": true,
              "description": "Gate-type-specific configuration"
            }
          },
          "additionalProperties": false
        },
        "timeout_ms": {
          "type": "integer",
          "minimum": 0,
          "description": "Timeout for gate evaluation"
        },
        "on_pass": {
          "type": "string",
          "description": "Step to proceed to on pass"
        },
        "on_fail": {
          "type": "string",
          "description": "Step to proceed to on fail"
        }
      },
      "additionalProperties": false
    },
    "RoutingCursor": {
      "type": "object",
      "properties": {
        "decision_history": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RoutingDecisionRecord"
          },
          "description": "History of routing decisions made during this run"
        },
        "pending_branches": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "branch_id": {
                "type": "string"
              },
              "condition": {
                "type": "object"
              },
              "deferred_at": {
                "type": "string",
                "format": "date-time"
              },
              "reason": {
                "type": "string"
              }
            }
          },
          "description": "Branches awaiting evaluation (for deferred decisions)"
        },
        "route_overrides": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Manual route overrides (step_id -> forced_next_step_id)"
        },
        "blacklisted_steps": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Steps that should be skipped during routing"
        },
        "preferred_route": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Preferred route hint (list of step IDs in order)"
        }
      },
      "additionalProperties": false
    },
    "RoutingDecisionRecord": {
      "type": "object",
      "required": ["timestamp", "from_step", "decision", "reason"],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "from_step": {
          "type": "string",
          "description": "Step where decision was made"
        },
        "to_step": {
          "type": ["string", "null"],
          "description": "Step decided to proceed to"
        },
        "decision": {
          "type": "string",
          "enum": ["advance", "loop", "branch", "terminate", "detour", "resume"],
          "description": "Type of routing decision"
        },
        "reason": {
          "type": "string",
          "description": "Why this decision was made"
        },
        "confidence": {
          "type": "string",
          "enum": ["high", "medium", "low"]
        },
        "alternatives_considered": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "step": { "type": "string" },
              "reason_rejected": { "type": "string" }
            }
          },
          "description": "Other routes that were considered but not taken"
        }
      },
      "additionalProperties": false
    },
    "RunMetrics": {
      "type": "object",
      "properties": {
        "total_duration_ms": {
          "type": "integer",
          "minimum": 0,
          "description": "Total execution time in milliseconds"
        },
        "steps_completed": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of steps successfully completed"
        },
        "steps_failed": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of steps that failed"
        },
        "steps_skipped": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of steps skipped"
        },
        "total_iterations": {
          "type": "integer",
          "minimum": 0,
          "description": "Total microloop iterations across all loops"
        },
        "detours_taken": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of detour sequences executed"
        },
        "injections_processed": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of injected nodes processed"
        },
        "token_usage": {
          "type": "object",
          "properties": {
            "input_tokens": { "type": "integer", "minimum": 0 },
            "output_tokens": { "type": "integer", "minimum": 0 },
            "total_tokens": { "type": "integer", "minimum": 0 }
          },
          "additionalProperties": false
        },
        "cost_estimate_usd": {
          "type": "number",
          "minimum": 0,
          "description": "Estimated cost in USD based on token usage"
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}
