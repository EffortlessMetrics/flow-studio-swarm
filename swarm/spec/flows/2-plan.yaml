# Flow: 2-plan
# Purpose: Spec -> Design: Transform requirements into architecture decisions

id: 2-plan
version: 1
title: "Flow 2 - Plan"
description: |
  Transform requirements into concrete design decisions.
  Produces ADR, API contracts, observability spec, test plan, and work plan.
  Design critic validates coherence before proceeding to Build.

defaults:
  context_pack:
    include_upstream_artifacts: true
    include_previous_envelopes: true
    max_envelopes: 10
    include_scent_trail: true
  sdk_overrides: {}

steps:
  # Step 1: Analyze impact
  - id: analyze_impact
    station: impact-analyzer
    objective: |
      Map the blast radius of proposed changes.
      Identify affected modules, dependencies, and ripple effects.
      Heavy context loading (20-50k tokens) to surface hidden coupling.
    inputs:
      - signal/requirements.md
      - signal/bdd_scenarios.md
      - signal/scope_assessment.md
    outputs:
      - plan/impact_map.json
    routing:
      kind: linear
      next: design_options
    teaching:
      highlight: true
      note: "Heavy context loading: surface all affected components"

  # Step 2: Propose design options
  - id: design_options
    station: design-optioneer
    objective: |
      Propose 2-3 architecture options with explicit trade-offs.
      No recommendation - present options objectively for ADR author.
    inputs:
      - plan/impact_map.json
      - signal/requirements.md
      - signal/problem_statement.md
    outputs:
      - plan/design_options.md
    routing:
      kind: linear
      next: author_adr
    teaching:
      note: "Multiple options enable informed decision-making"

  # Step 3: Write ADR
  - id: author_adr
    station: adr-author
    objective: |
      Write Architecture Decision Record for chosen design.
      Document context, decision, and consequences.
      Reference rejected alternatives from design_options.md.
    inputs:
      - plan/design_options.md
      - plan/impact_map.json
      - signal/requirements.md
    outputs:
      - plan/adr.md
    routing:
      kind: linear
      next: design_interfaces
    teaching:
      highlight: true
      note: "ADR is the single source of truth for design decisions"

  # Step 4: Define interfaces
  - id: design_interfaces
    station: interface-designer
    objective: |
      Define API contracts, data models, and schema.
      Plan migration strategy if database changes needed.
      Contracts must be verifiable by Gate flow.
    inputs:
      - plan/adr.md
      - signal/requirements.md
    outputs:
      - plan/api_contracts.yaml
      - plan/interface_spec.md
      - plan/schema.md
    routing:
      kind: linear
      next: design_observability
    teaching:
      highlight: true
      note: "Contracts define boundaries that Gate will enforce"

  # Step 5: Design observability
  - id: design_observability
    station: observability-designer
    objective: |
      Define metrics, logs, traces, SLOs, and alerting.
      Cover both happy paths and error scenarios.
      Respect privacy requirements.
    inputs:
      - plan/adr.md
      - plan/api_contracts.yaml
      - signal/requirements.md
    outputs:
      - plan/observability_spec.md
    routing:
      kind: linear
      next: plan_tests
    teaching:
      note: "Observability is designed, not bolted on after"

  # Step 6: Plan tests
  - id: plan_tests
    station: test-strategist
    objective: |
      Map BDD scenarios to test types and coverage targets.
      Plan integration test strategy.
      Identify property-based test opportunities.
    inputs:
      - signal/bdd_scenarios.md
      - plan/adr.md
      - plan/api_contracts.yaml
      - plan/schema.md
    outputs:
      - plan/test_plan.md
    routing:
      kind: linear
      next: plan_work
    teaching:
      note: "Test plan drives test-first development in Flow 3"

  # Step 7: Plan work
  - id: plan_work
    station: work-planner
    objective: |
      Break design into atomic subtasks with clear dependencies.
      Define rollout sequence and parallelization opportunities.
      Subtasks should be independently testable.
    inputs:
      - plan/adr.md
      - plan/test_plan.md
      - plan/api_contracts.yaml
      - signal/scope_assessment.md
    outputs:
      - plan/work_plan.md
    routing:
      kind: linear
      next: critique_design
    teaching:
      note: "Work plan becomes subtask index for Flow 3"

  # Step 8: Critique design
  - id: critique_design
    station: design-critic
    objective: |
      Validate design coherence across all plan artifacts.
      Check ADR addresses requirements.
      Verify contracts are complete.
      Identify design risks before implementation.
    inputs:
      - plan/adr.md
      - plan/api_contracts.yaml
      - plan/interface_spec.md
      - plan/observability_spec.md
      - plan/test_plan.md
      - plan/work_plan.md
      - signal/requirements.md
    outputs:
      - plan/design_critique.md
    routing:
      kind: microloop
      loop_target: author_adr
      loop_condition_field: status
      loop_success_values:
        - VERIFIED
        - verified
      max_iterations: 2
    teaching:
      highlight: true
      note: "MICROLOOP: adr-author <-> design-critic until VERIFIED"

cross_cutting_stations:
  - clarifier
  - risk-analyst
  - policy-analyst
